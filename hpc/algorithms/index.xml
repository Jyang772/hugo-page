<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms Case Studies on Algorithmica</title><link>https://en.algorithmica.org/hpc/algorithms/</link><description>Recent content in Algorithms Case Studies on Algorithmica</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://en.algorithmica.org/hpc/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Binary GCD</title><link>https://en.algorithmica.org/hpc/algorithms/gcd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://en.algorithmica.org/hpc/algorithms/gcd/</guid><description>In this section, we will derive a variant of gcd that is ~2x faster than the one in the C++ standard library.
#Euclid&amp;rsquo;s AlgorithmEuclid&amp;rsquo;s algorithm solves the problem of finding the greatest common divisor (GCD) of two integer numbers $a$ and $b$, which is defined as the largest such number $g$ that divides both $a$ and $b$:
$$ \gcd(a, b) = \max_{g: ; g|a , \land , g | b} g $$</description></item><item><title>Integer Factorization</title><link>https://en.algorithmica.org/hpc/algorithms/factorization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://en.algorithmica.org/hpc/algorithms/factorization/</guid><description>The problem of factoring integers into primes is central to computational number theory. It has been studied since at least the 3rd century BC, and many methods have been developed that are efficient for different inputs.
In this case study, we specifically consider the factorization of word-sized integers: those on the order of $10^9$ and $10^{18}$. Untypical for this book, in this one, you may actually learn an asymptotically better algorithm: we start with a few basic approaches and gradually build up to the $O(\sqrt[4]{n})$-time Pollard&amp;rsquo;s rho algorithm and optimize it to the point where it can factorize 60-bit semiprimes in 0.</description></item><item><title>Argmin with SIMD</title><link>https://en.algorithmica.org/hpc/algorithms/argmin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://en.algorithmica.org/hpc/algorithms/argmin/</guid><description>Computing the minimum of an array is easily vectorizable, as it is not different from any other reduction: in AVX2, you just need to use a convenient _mm256_min_epi32 intrinsic as the inner operation. It computes the minimum of two 8-element vectors in one cycle — even faster than in the scalar case, which requires at least a comparison and a conditional move.
Finding the index of that minimum element (argmin) is much harder, but it is still possible to vectorize very efficiently.</description></item><item><title>Prefix Sum with SIMD</title><link>https://en.algorithmica.org/hpc/algorithms/prefix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://en.algorithmica.org/hpc/algorithms/prefix/</guid><description>The prefix sum, also known as cumulative sum, inclusive scan, or simply scan, is a sequence of numbers $b_i$ generated from another sequence $a_i$ using the following rule:
$$ \begin{aligned} b_0 &amp;amp;= a_0 \ b_1 &amp;amp;= a_0 + a_1 \ b_2 &amp;amp;= a_0 + a_1 + a_2 \ &amp;amp;\ldots \end{aligned} $$
In other words, the $k$-th element of the output sequence is the sum of the first $k$ elements of the input sequence.</description></item><item><title>Matrix Multiplication</title><link>https://en.algorithmica.org/hpc/algorithms/matmul/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://en.algorithmica.org/hpc/algorithms/matmul/</guid><description>In this case study, we will design and implement several algorithms for matrix multiplication.
We start with the naive &amp;ldquo;for-for-for&amp;rdquo; algorithm and incrementally improve it, eventually arriving at a version that is 50 times faster and matches the performance of BLAS libraries while being under 40 lines of C.
All implementations are compiled with GCC 13 and run on a Zen 2 CPU clocked at 2GHz.
#BaselineThe result of multiplying an $l \times n$ matrix $A$ by an $n \times m$ matrix $B$ is defined as an $l \times m$ matrix $C$ such that:</description></item></channel></rss>