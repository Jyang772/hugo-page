<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WBN59M8Y5S")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(53961409,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/53961409 style=position:absolute;left:-9999px alt></div></noscript><meta charset=utf-8><link rel=stylesheet href=/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8+ZXdZy0="><link rel=stylesheet href=/syntax.css id=syntax-theme><link rel=stylesheet type=text/css href=https://tikzjax.com/v1/fonts.css><script src=https://tikzjax.com/v1/tikzjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js></script><script src=/scripts/lunr.stemmer.support.min.js></script><script src=/scripts/lunr.ru.min.js></script><script src=/scripts/lunr.multi.min.js></script><link rel=stylesheet id=theme><script>function toggleSidebar(){console.log("Toggling sidebar visibility");var e=document.getElementById("sidebar"),t=document.getElementById("wrapper");(e.classList.contains("sidebar-toggled")||window.getComputedStyle(e).display=="block")&&(e.classList.toggle("sidebar-hidden"),t.classList.toggle("sidebar-hidden")),e.classList.add("sidebar-toggled"),t.classList.add("sidebar-toggled")}function switchTheme(e){console.log("Changing theme:",e),document.getElementById("theme").href=e=="dark"?"/hugo-page/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css":"",document.getElementById("syntax-theme").href=e=="dark"?"/syntax-dark.css":"/syntax.css",localStorage.setItem("theme",e)}async function toggleSearch(){console.log("Toggling search");var e=document.getElementById("search");if(window.getComputedStyle(e).display=="none"?(e.style.display="block",window.scrollTo({top:0}),document.getElementById("search-bar").focus()):e.style.display="none",!index){console.log("Fetching index");const e=await fetch("/searchindex.json"),t=await e.json();index=lunr(function(){this.use(lunr.multiLanguage("en","ru")),this.field("title",{boost:5}),this.field("content",{boost:1}),t.forEach(function(e){this.add(e),articles.push(e)},this)}),console.log("Ready to search")}}var articles=[],index=void 0;function search(){var n,e=document.getElementById("search-bar").value,s=document.getElementById("search-results"),o=document.getElementById("search-count");if(e==""){s.innerHTML="",o.innerHTML="";return}n=index.search(e),o.innerHTML="Found <b>"+n.length+"</b> pages";let t="";for(const a in n){const i=articles[n[a].ref];t+='<li><a href="'+i.path+'">'+i.title+"</a> <p>";const s=i.content,o=80;if(s.includes(e)){const n=s.indexOf(e);n>o&&(t+="…"),t+=s.substring(n-o,n)+"<b>"+e+"</b>"+s.substring(n+e.length,n+e.length+o)}else t+=s.substring(0,o*2);t+="…</p></li>"}s.innerHTML=t}localStorage.getItem("theme")=="dark"&&switchTheme("dark"),window.addEventListener("load",function(){var e=document.getElementById("active-element");e&&e.scrollIntoView({block:"center"})}),window.addEventListener("scroll",function(){var e=document.getElementById("menu");window.scrollY<120?e.classList.remove("scrolled"):e.classList.add("scrolled")}),window.addEventListener("keydown",function(e){if(e.altKey)return;if(document.activeElement.tagName=="INPUT")return;e.key=="ArrowLeft"?document.getElementById("prev-article").click():e.key=="ArrowRight"&&document.getElementById("next-article").click()})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><title>Segment Trees - Algorithmica</title></head><body><nav id=sidebar><div class=title><a href=/>Algorithmica</a>
<span class=slash>/</span>
<a href=/hugo-page/hpc/ class=divisionAbbr>HPC</a></div><ul><li class=part>Performance Engineering</li><li><a href=/hugo-page/hpc/complexity/>Complexity Models</a></li><ol><li><a href=/hugo-page/hpc/complexity/hardware/>Modern Hardware</a></li><li><a href=/hugo-page/hpc/complexity/languages/>Programming Languages</a></li></ol><li><a href=/hugo-page/hpc/architecture/>Computer Architecture</a></li><ol><li><a href=/hugo-page/hpc/architecture/isa/>Instruction Set Architectures</a></li><li><a href=/hugo-page/hpc/architecture/assembly/>Assembly Language</a></li><li><a href=/hugo-page/hpc/architecture/loops/>Loops and Conditionals</a></li><li><a href=/hugo-page/hpc/architecture/functions/>Functions and Recursion</a></li><li><a href=/hugo-page/hpc/architecture/indirect/>Indirect Branching</a></li><li><a href=/hugo-page/hpc/architecture/layout/>Machine Code Layout</a></li></ol><li><a href=/hugo-page/hpc/pipelining/>Instruction-Level Parallelism</a></li><ol><li><a href=/hugo-page/hpc/pipelining/hazards/>Pipeline Hazards</a></li><li><a href=/hugo-page/hpc/pipelining/branching/>The Cost of Branching</a></li><li><a href=/hugo-page/hpc/pipelining/branchless/>Branchless Programming</a></li><li><a href=/hugo-page/hpc/pipelining/tables/>Instruction Tables</a></li><li><a href=/hugo-page/hpc/pipelining/throughput/>Throughput Computing</a></li></ol><li><a href=/hugo-page/hpc/compilation/>Compilation</a></li><ol><li><a href=/hugo-page/hpc/compilation/stages/>Stages of Compilation</a></li><li><a href=/hugo-page/hpc/compilation/flags/>Flags and Targets</a></li><li><a href=/hugo-page/hpc/compilation/situational/>Situational Optimizations</a></li><li><a href=/hugo-page/hpc/compilation/contracts/>Contract Programming</a></li><li><a href=/hugo-page/hpc/compilation/precalc/>Precomputation</a></li></ol><li><a href=/hugo-page/hpc/profiling/>Profiling</a></li><ol><li><a href=/hugo-page/hpc/profiling/instrumentation/>Instrumentation</a></li><li><a href=/hugo-page/hpc/profiling/events/>Statistical Profiling</a></li><li><a href=/hugo-page/hpc/profiling/simulation/>Program Simulation</a></li><li><a href=/hugo-page/hpc/profiling/mca/>Machine Code Analyzers</a></li><li><a href=/hugo-page/hpc/profiling/benchmarking/>Benchmarking</a></li><li><a href=/hugo-page/hpc/profiling/noise/>Getting Accurate Results</a></li></ol><li><a href=/hugo-page/hpc/arithmetic/>Arithmetic</a></li><ol><li><a href=/hugo-page/hpc/arithmetic/float/>Floating-Point Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/ieee-754/>IEEE 754 Floats</a></li><li><a href=/hugo-page/hpc/arithmetic/errors/>Rounding Errors</a></li><li><a href=/hugo-page/hpc/arithmetic/newton/>Newton's Method</a></li><li><a href=/hugo-page/hpc/arithmetic/rsqrt/>Fast Inverse Square Root</a></li><li><a href=/hugo-page/hpc/arithmetic/integer/>Integer Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/division/>Integer Division</a></li></ol><li><a href=/hugo-page/hpc/number-theory/>Number Theory</a></li><ol><li><a href=/hugo-page/hpc/number-theory/modular/>Modular Arithmetic</a></li><li><a href=/hugo-page/hpc/number-theory/exponentiation/>Binary Exponentiation</a></li><li><a href=/hugo-page/hpc/number-theory/euclid-extended/>Extended Euclidean Algorithm</a></li><li><a href=/hugo-page/hpc/number-theory/montgomery/>Montgomery Multiplication</a></li></ol><li><a href=/hugo-page/hpc/external-memory/>External Memory</a></li><ol><li><a href=/hugo-page/hpc/external-memory/hierarchy/>Memory Hierarchy</a></li><li><a href=/hugo-page/hpc/external-memory/virtual/>Virtual Memory</a></li><li><a href=/hugo-page/hpc/external-memory/model/>External Memory Model</a></li><li><a href=/hugo-page/hpc/external-memory/sorting/>External Sorting</a></li><li><a href=/hugo-page/hpc/external-memory/list-ranking/>List Ranking</a></li><li><a href=/hugo-page/hpc/external-memory/policies/>Eviction Policies</a></li><li><a href=/hugo-page/hpc/external-memory/oblivious/>Cache-Oblivious Algorithms</a></li><li><a href=/hugo-page/hpc/external-memory/locality/>Spatial and Temporal Locality</a></li></ol><li><a href=/hugo-page/hpc/cpu-cache/>RAM & CPU Caches</a></li><ol><li><a href=/hugo-page/hpc/cpu-cache/bandwidth/>Memory Bandwidth</a></li><li><a href=/hugo-page/hpc/cpu-cache/latency/>Memory Latency</a></li><li><a href=/hugo-page/hpc/cpu-cache/cache-lines/>Cache Lines</a></li><li><a href=/hugo-page/hpc/cpu-cache/sharing/>Memory Sharing</a></li><li><a href=/hugo-page/hpc/cpu-cache/mlp/>Memory-Level Parallelism</a></li><li><a href=/hugo-page/hpc/cpu-cache/prefetching/>Prefetching</a></li><li><a href=/hugo-page/hpc/cpu-cache/alignment/>Alignment and Packing</a></li><li><a href=/hugo-page/hpc/cpu-cache/pointers/>Pointer Alternatives</a></li><li><a href=/hugo-page/hpc/cpu-cache/associativity/>Cache Associativity</a></li><li><a href=/hugo-page/hpc/cpu-cache/paging/>Memory Paging</a></li><li><a href=/hugo-page/hpc/cpu-cache/aos-soa/>AoS and SoA</a></li></ol><li><a href=/hugo-page/hpc/simd/>SIMD Parallelism</a></li><ol><li><a href=/hugo-page/hpc/simd/intrinsics/>Intrinsics and Vector Types</a></li><li><a href=/hugo-page/hpc/simd/moving/>Moving Data</a></li><li><a href=/hugo-page/hpc/simd/reduction/>Reductions</a></li><li><a href=/hugo-page/hpc/simd/masking/>Masking and Blending</a></li><li><a href=/hugo-page/hpc/simd/shuffling/>In-Register Shuffles</a></li><li><a href=/hugo-page/hpc/simd/auto-vectorization/>Auto-Vectorization and SPMD</a></li></ol><li><a href=/hugo-page/hpc/algorithms/>Algorithms Case Studies</a></li><ol><li><a href=/hugo-page/hpc/algorithms/gcd/>Binary GCD</a></li><li><a href=/hugo-page/hpc/algorithms/factorization/>Integer Factorization</a></li><li><a href=/hugo-page/hpc/algorithms/argmin/>Argmin with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/prefix/>Prefix Sum with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/matmul/>Matrix Multiplication</a></li></ol><li><a href=/hugo-page/hpc/data-structures/>Data Structures Case Studies</a></li><ol><li><a href=/hugo-page/hpc/data-structures/binary-search/>Binary Search</a></li><li><a href=/hugo-page/hpc/data-structures/s-tree/>Static B-Trees</a></li><li><a href=/hugo-page/hpc/data-structures/b-tree/>Search Trees</a></li><li><a href=/hugo-page/hpc/data-structures/segment-trees/ id=active-element>Segment Trees</a></li></ol></ul></nav><div id=wrapper><menu id=menu><div class=left><a><img src=/icons/bars-solid.svg onclick=toggleSidebar() title='open table of contents'>
</a><a><img src=/icons/adjust-solid.svg style=position:relative;top:-1px onclick='switchTheme(localStorage.getItem("theme")=="dark"?"light":"dark")' title='dark theme'>
</a><a><img src=/icons/search-solid.svg onclick=toggleSearch() title=search></a></div><div class=title>Segment Trees</div><div class=right><a onclick=window.print()><img src=/icons/print-solid.svg title=print>
</a><a href=https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2fdata-structures%2fsegment-trees.md><img src=/icons/edit-solid.svg title=edit style=width:18px;position:relative;right:-2px;top:-1px>
</a><a href=https://github.com/algorithmica-org/algorithmica/blob/master//hpc/data-structures/segment-trees.md class=github-main><img src=/icons/github-brands.svg title='view on github'></a></div></menu><main><div id=search><input id=search-bar type=search placeholder='Search this book…' oninput=search()><div id=search-count></div><div id=search-results></div></div><header><h1>Segment Trees</h1><div class=info></div></header><article><p>The lessons learned from <a href=../s-tree>optimizing</a> <a href=../binary-search>binary search</a> can be applied to a broad range of data structures.</p><p>In this article, instead of trying to optimize something from the STL again, we focus on <em>segment trees</em>, the structures that may be unfamiliar to most <em>normal</em> programmers and perhaps even most computer science researchers<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>, but that are used <a href="https://www.google.com/search?q=segment+tree+site%3Acodeforces.com&amp;newwindow=1&amp;sxsrf=APq-WBuTupSOnSn9JNEHhaqtmv0Uq0eogQ%3A1645969931499&amp;ei=C4IbYrb2HYibrgS9t6qgDQ&amp;ved=0ahUKEwj2p8_og6D2AhWIjYsKHb2bCtQQ4dUDCA4&amp;uact=5&amp;oq=segment+tree+site%3Acodeforces.com&amp;gs_lcp=Cgdnd3Mtd2l6EAM6BwgAEEcQsAM6BwgAELADEEM6BAgjECc6BAgAEEM6BQgAEIAEOgYIABAWEB46BQghEKABSgQIQRgASgQIRhgAUMkFWLUjYOgkaANwAXgAgAHzAYgB9A-SAQYxNS41LjGYAQCgAQHIAQrAAQE&amp;sclient=gws-wiz">very extensively</a> in programming competitions for their speed and simplicity of implementation.</p><p>(If you already know the context, jump straight to the <a href=#wide-segment-trees>last section</a> for the novelty: the <em>wide segment tree</em> that works 4 to 12 times faster than the Fenwick tree.)</p><span class=anchor id=dynamic-prefix-sum></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#dynamic-prefix-sum>#</a>Dynamic Prefix Sum</h3><p>Segment trees are cool and can do lots of different things, but in this article, we will focus on their simplest non-trivial application — <em>the dynamic prefix sum problem</em>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>);</span> <span class=c1>// react to a[k] += x (zero-based indexing)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>);</span>         <span class=c1>// return the sum of the first k elements (from 0 to k - 1)
</span></span></span></code></pre></div><p>As we have to support two types of queries, our optimization problem becomes multi-dimensional, and the optimal solution depends on the distribution of queries. For example, if one type of the queries were extremely rare, we would only optimize for the other, which is relatively easy to do:</p><ul><li>If we only cared about the cost of <em>updating the array</em>, we would store it as it is and <a href=/hpc/simd/reduction>calculate the sum</a> directly on each <code>sum</code> query.</li><li>If we only cared about the cost of <em>prefix sum queries</em>, we would keep it ready and <a href=/hpc/algorithms/prefix>re-calculate them entirely from scratch</a> on each update.</li></ul><p>Both of these options perform $O(1)$ work on one query type but $O(n)$ work on the other. When the query frequencies are relatively close, we can trade off some performance on one type of query for increased performance on the other. Segment trees let you do exactly that, achieving the equilibrium of $O(\log n)$ work for both queries.</p><span class=anchor id=segment-tree-structure></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#segment-tree-structure>#</a>Segment Tree Structure</h3><p>The main idea behind segment trees is this:</p><ul><li>calculate the sum of the entire array and write it down somewhere;</li><li>split the array into two halves, calculate the sum on both halves, and also write them down somewhere;</li><li>split these halves into halves, calculate the total of four sums on them, and also write them down;</li><li>…and so on, until we recursively reach segments of length one.</li></ul><p>These computed subsegment sums can be logically represented as a binary tree — which is what we call a <em>segment tree</em>:</p><p><figure><img src=../img/segtree-path.png><figcaption>A segment tree with with the nodes relevant for the sum(11) and add(10) queries highlighted</figcaption></figure></p><p>Segment trees have some nice properties:</p><ul><li>If the underlying array has $n$ elements, the segment tree has exactly $(2n - 1)$ nodes — $n$ leaves and $(n - 1)$ internal nodes — because each internal node splits a segment in two, and you only need $(n - 1)$ of them to completely split the original $[0, n-1]$ range.</li><li>The height of the tree is $\Theta(\log n)$: on each next level starting from the root, the number of nodes roughly doubles and the size of their segments roughly halves.</li><li>Each segment can be split into $O(\log n)$ non-intersecting segments that correspond to the nodes of the segment tree: you need at most two from each layer.</li></ul><p>When $n$ is not a perfect power of two, not all levels are filled entirely — the last layer may be incomplete — but the truthfulness of these properties remains unaffected. The first property allows us to use only $O(n)$ memory to store the tree, and the last two let us solve the problem in $O(\log n)$ time:</p><ul><li>The <code>add(k, x)</code> query can be handled by adding the value <code>x</code> to all nodes whose segments contain the element <code>k</code>, and we&rsquo;ve already established that there are only $O(\log n)$ of them.</li><li>The <code>sum(k)</code> query can be answered by finding all nodes that collectively compose the <code>[0, k)</code> prefix and summing the values stored in them — and we&rsquo;ve also established that there would be at most $O(\log n)$ of them.</li></ul><p>But this is still theory. As we&rsquo;ll see later, there are remarkably many ways one can implement this data structure.</p><span class=anchor id=pointer-based-implementation></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#pointer-based-implementation>#</a>Pointer-Based Implementation</h3><p>The most straightforward way to implement a segment tree is to store everything we need in a node explicitly: including the array segment boundaries, the sum, and the pointers to its children.</p><p>If we were at the &ldquo;Introduction to OOP&rdquo; class, we would implement a segment tree recursively like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>segtree</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>lb</span><span class=p>,</span> <span class=n>rb</span><span class=p>;</span>                         <span class=c1>// the range this node is responsible for 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>                          <span class=c1>// the sum of elements [lb, rb)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>segtree</span> <span class=o>*</span><span class=n>l</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>,</span> <span class=o>*</span><span class=n>r</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span> <span class=c1>// pointers to its children
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>segtree</span><span class=p>(</span><span class=kt>int</span> <span class=n>lb</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rb</span><span class=p>)</span> <span class=o>:</span> <span class=n>lb</span><span class=p>(</span><span class=n>lb</span><span class=p>),</span> <span class=n>rb</span><span class=p>(</span><span class=n>rb</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>lb</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>rb</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// if the node is not a leaf, create children
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>lb</span> <span class=o>+</span> <span class=n>rb</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=k>new</span> <span class=n>segtree</span><span class=p>(</span><span class=n>lb</span><span class=p>,</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=k>new</span> <span class=n>segtree</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>rb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* react to a[k] += x */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* compute the sum of the first k elements */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>If we needed to build it over an existing array, we would rewrite the body of the constructor like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>lb</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>==</span> <span class=n>rb</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>lb</span><span class=p>];</span> <span class=c1>// the node is a leaf -- its sum is just the element a[lb]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=p>(</span><span class=n>lb</span> <span class=o>+</span> <span class=n>rb</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>=</span> <span class=k>new</span> <span class=n>segtree</span><span class=p>(</span><span class=n>lb</span><span class=p>,</span> <span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>=</span> <span class=k>new</span> <span class=n>segtree</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>rb</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>s</span> <span class=o>+</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>s</span><span class=p>;</span> <span class=c1>// we can use the sums of children that we&#39;ve just calculated
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>The construction time is of no significant interest to us, so to reduce the mental burden, we will just assume that the array is zero-initialized in all future implementations.</p><p>Now, to implement <code>add</code>, we need to descend down the tree until we reach a leaf node, adding the delta to the <code>s</code> fields:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// check whether it is a leaf node
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>rb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span><span class=o>-&gt;</span><span class=n>add</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span><span class=o>-&gt;</span><span class=n>add</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To calculate the sum on a segment, we can check if the query covers the current segment fully or doesn&rsquo;t intersect with it at all — and return the result for this node right away. If neither is the case, we recursively pass the query to the children so that they figure it out themselves:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>lq</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rq</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rb</span> <span class=o>&lt;=</span> <span class=n>lq</span> <span class=o>&amp;&amp;</span> <span class=n>rb</span> <span class=o>&lt;=</span> <span class=n>rq</span><span class=p>)</span> <span class=c1>// if we&#39;re fully inside the query, return the sum
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rq</span> <span class=o>&lt;=</span> <span class=n>lb</span> <span class=o>||</span> <span class=n>lq</span> <span class=o>&gt;=</span> <span class=n>rb</span><span class=p>)</span> <span class=c1>// if we don&#39;t intersect with the query, return zero
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>sum</span><span class=p>(</span><span class=n>lq</span><span class=p>,</span> <span class=n>rq</span><span class=p>)</span> <span class=o>+</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>sum</span><span class=p>(</span><span class=n>lq</span><span class=p>,</span> <span class=n>rq</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This function visits a total of $O(\log n)$ nodes because it only spawns children when a segment only partially intersects with the query, and there are at most $O(\log n)$ of such segments.</p><p>For <em>prefix sums</em>, these checks can be simplified as the left border of the query is always zero:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>rb</span> <span class=o>&lt;=</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>lb</span> <span class=o>&gt;=</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>l</span><span class=o>-&gt;</span><span class=n>sum</span><span class=p>(</span><span class=n>k</span><span class=p>)</span> <span class=o>+</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>sum</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since we have two types of queries, we also got two graphs to look at:</p><p><figure><img src=../img/segtree-pointers.svg><figcaption></figcaption></figure></p><p>While this object-oriented implementation is quite good in terms of software engineering practices, there are several aspects that make it terrible in terms of performance:</p><ul><li>Both query implementations use <a href=/hpc/architecture/functions>recursion</a> — although the <code>add</code> query can be tail-call optimized.</li><li>Both query implementations use unpredictable <a href=/hpc/pipelining/branching>branching</a>, which stalls the CPU pipeline.</li><li>The nodes store extra metadata. The structure takes $4+4+4+8+8=28$ bytes and gets padded to 32 bytes for <a href=/hpc/cpu-cache/alignment>memory alignment</a> reasons, while only 4 bytes are really necessary to hold the integer sum.</li><li>Most importantly, we are doing a lot of <a href=/hpc/cpu-cache/latency>pointer chasing</a>: we have to fetch the pointers to the children to descend into them, even though we can infer, ahead of time, which segments we&rsquo;ll need just from the query.</li></ul><p>Pointer chasing outweighs all other issues by orders of magnitude — and to negate it, we need to get rid of pointers, making the structure <em>implicit</em>.</p><span class=anchor id=implicit-segment-trees></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#implicit-segment-trees>#</a>Implicit Segment Trees</h3><p>As a segment tree is a type of binary tree, we can use the <a href=../binary-search#eytzinger-layout>Eytzinger layout</a> to store its nodes in one large array and use index arithmetic instead of explicit pointers to navigate it.</p><p>More formally, we define node $1$ to be the root, holding the sum of the entire array $[0, n)$. Then, for every node $v$ corresponding to the range $[l, r]$, we define:</p><ul><li>the node $2v$ to be its left child corresponding to the range $[l, \lfloor \frac{l+r}{2} \rfloor)$;</li><li>the node $(2v+1)$ to be its right child corresponding to the range $[\lfloor \frac{l+r}{2} \rfloor, r)$.</li></ul><p>When $n$ is a perfect power of two, this layout packs the entire tree very nicely:</p><p><figure><img src=../img/segtree-layout.png><figcaption>The memory layout of the implicit segment tree with the same query path highlighted</figcaption></figure></p><p>However, when $n$ is not a power of two, the layout stops being compact: although we still have exactly $(2n - 1)$ nodes regardless of how we split segments, they are no longer mapped perfectly to the $[1, 2n)$ range.</p><p>For example, consider what happens when we descend to the rightmost leaf in a segment tree of size $17 = 2^4 + 1$:</p><ul><li>we start with the root numbered $1$ representing the range $[0, 16]$,</li><li>we go to node $3 = 2 \times 1 + 1$ representing the range $[8, 16]$,</li><li>we go to node $7 = 2 \times 2 + 1$ representing the range $[12, 16]$,</li><li>we go to node $15 = 2 \times 7 + 1$ representing the range $[14, 16]$,</li><li>we go to node $31 = 2 \times 15 + 1$ representing the range $[15, 16]$,</li><li>and we finally reach node $63 = 2 \times 31 + 1$ representing the range $[16, 16]$.</li></ul><p>So, as $63 > 2 \times 17 - 1 = 33$, there are some empty spaces in the layout, but the structure of the tree is still the same, and its height is still $O(\log n)$. For now, we can ignore this problem and just allocate a larger array for storing the nodes — it can be shown that the index of the rightmost leaf never exceeds $4n$, so allocating that many cells will always suffice:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>t</span><span class=p>[</span><span class=mi>4</span> <span class=o>*</span> <span class=n>N</span><span class=p>];</span> <span class=c1>// contains the node sums
</span></span></span></code></pre></div><p>Now, to implement <code>add</code>, we create a similar recursive function but using index arithmetic instead of pointers. Since we&rsquo;ve also stopped storing the borders of the segment in the nodes, we need to re-calculate them and pass them as parameters for each recursive call:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>add</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>v</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>add</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>v</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The implementation of the prefix sum query is largely the same:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>N</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>l</span> <span class=o>&gt;=</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>&lt;=</span> <span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>t</span><span class=p>[</span><span class=n>v</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>v</span><span class=p>,</span> <span class=n>l</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=o>+</span> <span class=n>sum</span><span class=p>(</span><span class=n>k</span><span class=p>,</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>v</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>r</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Passing around five variables in a recursive function seems clumsy, but the performance gains are clearly worth it:</p><p><figure><img src=../img/segtree-topdown.svg><figcaption></figcaption></figure></p><p>Apart from requiring much less memory, which is good for fitting into the CPU caches, the main advantage of this implementation is that we can now make use of the <a href=/hpc/cpu-cache/mlp>memory parallelism</a> and fetch the nodes we need in parallel, considerably improving the running time for both queries.</p><p>To improve the performance further, we can:</p><ul><li>manually optimize the index arithmetic (e.g., noticing that we need to multiply <code>v</code> by <code>2</code> either way),</li><li>replace division by two with an explicit binary shift (because <a href=/hpc/compilation/contracts/#arithmetic>compilers aren&rsquo;t always able to do it themselves</a>),</li><li>and, most importantly, get rid of <a href=/hpc/architecture/functions>recursion</a> and make the implementation fully iterative.</li></ul><p>As <code>add</code> is tail-recursive and has no return value, it is easy turn it into a single <code>while</code> loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>&lt;&lt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=n>m</span><span class=p>,</span> <span class=n>v</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span><span class=p>[</span><span class=n>v</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Doing the same for the <code>sum</code> query is slightly harder as it has two recursive calls. The key trick is to notice that when we make these calls, one of them is guaranteed to terminate immediately as <code>k</code> can only be in one of the halves, so we can simply check this condition before descending the tree:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>r</span> <span class=o>=</span> <span class=n>N</span><span class=p>,</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>l</span> <span class=o>+</span> <span class=n>r</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span> <span class=o>&lt;&lt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>&gt;=</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>v</span><span class=o>++</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>==</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>l</span> <span class=o>=</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>r</span> <span class=o>=</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This doesn&rsquo;t improve the performance for the update query by a lot (because it was tail-recursive, and the compiler already performed a similar optimization), but the running time on the prefix sum query has roughly halved for all problem sizes:</p><p><figure><img src=../img/segtree-iterative.svg><figcaption></figcaption></figure></p><p>This implementation still has some problems: we are using up to twice as much memory as necessary, we have costly <a href=/hpc/pipelining/branching>branching</a>, and we have to maintain and re-compute array bounds on each iteration. To get rid of these problems, we need to change our approach a little bit.</p><span class=anchor id=bottom-up-implementation></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#bottom-up-implementation>#</a>Bottom-Up Implementation</h3><p>Let&rsquo;s change the definition of the implicit segment tree layout. Instead of relying on the parent-to-child relationship, we first forcefully assign all the leaf nodes numbers in the $[n, 2n)$ range, and then recursively define the parent of node $k$ to be equal to node $\lfloor \frac{k}{2} \rfloor$.</p><p>This structure is largely the same as before: you can still reach the root (node $1$) by dividing any node number by two, and each node still has at most two children: $2k$ and $(2k + 1)$, as anything else yields a different parent number when floor-divided by two. The advantage we get is that we&rsquo;ve forced the last layer to be contiguous and start from $n$, so we can use the array of half the size:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>t</span><span class=p>[</span><span class=mi>2</span> <span class=o>*</span> <span class=n>N</span><span class=p>];</span>
</span></span></code></pre></div><p>When $n$ is a power of two, the structure of the tree is exactly the same as before and when implementing the queries, we can take advantage of this bottom-up approach and start from the $k$-th leaf node (simply indexed $N + k$) and ascend the tree until we reach the root:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>+=</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To calculate the sum on the $[l, r)$ subsegment, we can maintain pointers to the first and the last element that needs to be added, increase/decrease them respectively when we add a node and stop after they converge to the same node (which would be their least common ancestor):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>l</span> <span class=o>+=</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span> <span class=o>+=</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>l</span> <span class=o>&lt;=</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span> <span class=n>l</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>l</span><span class=o>++</span><span class=p>];</span> <span class=c1>// l is a right child: add it and move to a cousin
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>~</span><span class=n>r</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>r</span><span class=o>--</span><span class=p>];</span> <span class=c1>// r is a left child: add it and move to a cousin
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>l</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>r</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Surprisingly, both queries work correctly even when $n$ is not a power of two. To understand why, consider a 13-element segment tree:</p><p><figure><img src=../img/segtree-permuted.png><figcaption></figcaption></figure></p><p>The first index of the last layer is always a power of two, but when the array size is not a perfect power of two, some prefix of the leaf elements gets wrapped around to the right side of the tree. Magically, this fact does not pose a problem for our implementation:</p><ul><li>The <code>add</code> query still updates its parent nodes, even though some of them correspond to some prefix and some suffix of the array instead of a contiguous subsegment.</li><li>The <code>sum</code> query still computes the sum on the correct subsegment, even when <code>l</code> is on that wrapped prefix and logically &ldquo;to the right&rdquo; of <code>r</code> because eventually <code>l</code> becomes the last node on a layer and gets incremented, suddenly jumping to the first element of the next layer and proceeding normally after adding just the right nodes on the wrapped-around part of the tree (look at the dimmed nodes in the illustration).</li></ul><p>Compared to the top-down approach, we use half the memory and don&rsquo;t have to maintain query ranges, which results in simpler and consequently faster code:</p><p><figure><img src=../img/segtree-bottomup.svg><figcaption></figcaption></figure></p><p>When running the benchmarks, we use the <code>sum(l, r)</code> procedure for computing a general subsegment sum and just fix <code>l</code> equal to <code>0</code>. To achieve higher performance on the prefix sum query, we want to avoid maintaining <code>l</code> and only move the right border like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>+=</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>~</span><span class=n>k</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=c1>// if k is a right child
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=o>--</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>=</span> <span class=n>k</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In contrast, this prefix sum implementation doesn&rsquo;t work unless $n$ is not a power of two — because <code>k</code> could be on that wrapped-around part, and we&rsquo;d sum almost the entire array instead of a small prefix.</p><p>To make it work for arbitrary array sizes, we can permute the leaves so that they are in the left-to-right logical order in the last two layers of the tree. In the example above, this would mean adding $3$ to all leaf indexes and then moving the last three leaves one level higher by subtracting $13$.</p><p>In the general case, this can be done using predication in a few cycles like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>last_layer</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>__lg</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=n>N</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// calculate the index of the leaf k
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>leaf</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>+=</span> <span class=n>last_layer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>-=</span> <span class=p>(</span><span class=n>k</span> <span class=o>&gt;=</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>N</span><span class=p>)</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>When implementing the queries, all we need to do is to call the <code>leaf</code> function to get the correct leaf index:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=n>leaf</span><span class=p>(</span><span class=n>k</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=n>leaf</span><span class=p>(</span><span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>~</span><span class=n>k</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=o>--</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>&gt;&gt;=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The last touch: by replacing the <code>s += t[k--]</code> line with <a href=/hpc/pipelining/branchless>predication</a>, we can make the implementation branchless (except for the last branch — we still need to check the loop condition):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span> <span class=o>=</span> <span class=n>leaf</span><span class=p>(</span><span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>+=</span> <span class=p>(</span><span class=o>~</span><span class=n>k</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span> <span class=o>?</span> <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// will be replaced with a cmov
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>k</span> <span class=o>=</span> <span class=p>(</span><span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>When combined, these optimizations make the prefix sum queries run much faster:</p><p><figure><img src=../img/segtree-branchless.svg><figcaption></figcaption></figure></p><p>Notice that the bump in the latency for the prefix sum query starts at $2^{19}$ and not at $2^{20}$, the L3 cache boundary. This is because we are still storing $2n$ integers and also fetching the <code>t[k]</code> element regardless of whether we will add it to <code>s</code> or not. We can actually solve both of these problems.</p><span class=anchor id=fenwick-trees></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#fenwick-trees>#</a>Fenwick trees</h3><p>Implicit structures are great: they avoid pointer chasing, allow visiting all the relevant nodes in parallel, and take less space as they don&rsquo;t store metadata in nodes. Even better than implicit structures are <em>succinct</em> structures: they only require the information-theoretical minimum space to store the structure, using only $O(1)$ additional memory.</p><p>To make a segment tree succinct, we need to look at the values stored in the nodes and search for redundancies — the values that can be inferred from others — and remove them. One way to do this is to notice that in every implementation of prefix sum, we&rsquo;ve never used the sums stored in right children — therefore, for computing prefix sums, such nodes are redundant:</p><p><figure><img src=../img/segtree-succinct.png><figcaption></figcaption></figure></p><p><em>The Fenwick tree</em> (also called <em>binary indexed tree</em> — soon you&rsquo;ll understand why) is a type of segment tree that uses this consideration and gets rid of all <em>right</em> children, essentially removing every second node in each layer and making the total node count the same as the underlying array.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>t</span><span class=p>[</span><span class=n>N</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> <span class=c1>// +1 because we use use one-based indexing
</span></span></span></code></pre></div><p>To store these segment sums compactly, the Fenwick tree ditches the Eytzinger layout: instead, in place of every element $k$ that would be a leaf in the last layer of a segment tree, it stores the sum of its first non-removed ancestor. For example:</p><ul><li>the element $7$ would hold the sum on the $[0, 7]$ range ($282$),</li><li>the element $9$ would hold the sum on the $[8, 9]$ range ($-86$),</li><li>the element $10$ would hold the sum on the $[10, 10]$ range ($-52$, the element itself).</li></ul><p>How to compute this range for a given element $k$ (the left boundary, to be more specific: the right boundary is always the element $k$ itself) quicker than simulating the descend down the tree? Turns out, there is a smart bit trick that works when the tree size is a power of two and we use one-based indexing — just remove the least significant bit of the index:</p><ul><li>the left bound for element $7 + 1 = 8 = 1000_2$ is $0000_2 = 0$,</li><li>the left bound for element $9 + 1 = 10 = 1010_2$ is $1000_2 = 8$,</li><li>the left bound for element $10 + 1 = 11 = 1011_2$ is $1010_2 = 10$.</li></ul><p>And to get the last set bit of an integer, we can use this procedure:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>lowbit</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>&amp;</span> <span class=o>-</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This trick works by the virtue of how signed numbers are stored in binary using <a href=/hpc/arithmetic/integer>two&rsquo;s complement</a>. When we compute <code>-x</code>, we implicitly subtract it from a large power of two: some prefix of the number flips, some suffix of zeros at the end remains, and the only one-bit that stays unchanged is the last set bit — which will be the only one surviving <code>x & -x</code>. For example:</p><pre tabindex=0><code>+90 = 64 + 16 + 8 + 2 = (0)10110
-90 = 00000 - 10110   = (1)01010
    → (+90) &amp; (-90)   = (0)00010
</code></pre><p>We&rsquo;ve established what a Fenwick tree is just an array of size <code>n</code> where each element <code>k</code> is defined to be the sum of elements from <code>k - lowbit(k) + 1</code> and <code>k</code> inclusive in the original array, and now it&rsquo;s time to implement some queries.</p><p>Implementing the prefix sum query is easy. The <code>t[k]</code> holds the sum we need except for the first <code>k - lowbit(k)</code> elements, so we can just add it to the result and then jump to <code>k - lowbit(k)</code> and continue doing this until we reach the beginning of the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>-=</span> <span class=n>lowbit</span><span class=p>(</span><span class=n>k</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Since we are repeatedly removing the lowest set bit from <code>k</code>, and also since this procedure is equivalent to visiting the same left-child nodes in a segment tree, each <code>sum</code> query can touch at most $O(\log n)$ nodes:</p><p><figure><img src=../img/fenwick-sum.png><figcaption>A path for a prefix sum query in a Fenwick tree</figcaption></figure></p><p>To slightly improve the performance of the <code>sum</code> query, we use <code>k &= k - 1</code> to remove the lowest bit in one go, which is one instruction faster than <code>k -= k & -k</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&amp;=</span> <span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Unlike all previous segment tree implementations, a Fenwick tree is a structure where it is easier and more efficient to calculate the sum on a subsegment as the difference of two prefix sums:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// [l, r)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>sum</span> <span class=p>(</span><span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>(</span><span class=n>r</span><span class=p>)</span> <span class=o>-</span> <span class=n>sum</span><span class=p>(</span><span class=n>l</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The update query is easier to code but less intuitive. We need to add a value <code>x</code> to all nodes that are left-child ancestors of leaf <code>k</code>. Such nodes have indices <code>m</code> larger than <code>k</code> but <code>m - lowbit(m) &lt; k</code> so that <code>k</code> is included in their ranges.</p><p>All such indices need to have a common prefix with <code>k</code>, then a <code>1</code> where it was <code>0</code> in <code>k</code>, and then a suffix of zeros so that that <code>1</code> canceled and the result of <code>m - lowbit(m)</code> is less than <code>k</code>. All such indices can be generated iteratively like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>N</span><span class=p>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=n>k</span> <span class=o>&amp;</span> <span class=o>-</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Repeatedly adding the lowest set bit to <code>k</code> makes it &ldquo;more even&rdquo; and lifts it to its next left-child segment tree ancestor:</p><p><figure><img src=../img/fenwick-update.png><figcaption>A path for an update query in a Fenwick tree</figcaption></figure></p><p>Now, if we leave all the code as it is, it works correctly even when $n$ is not a power of two. In this case, the Fenwick tree is not equivalent to a segment tree of size $n$ but to a <em>forest</em> of up to $O(\log n)$ segment trees of power-of-two sizes — or to a single segment tree padded with zeros to a large power of two, if you like to think this way. In either case, all procedures still work correctly as they never touch anything outside the $[1, n]$ range.</p><p>The performance of the Fenwick tree is similar to the optimized bottom-up segment tree for the update queries and slightly faster for the prefix sum queries:</p><p><figure><img src=../img/segtree-fenwick.svg><figcaption></figcaption></figure></p><p>There is one weird thing on the graph. After we cross the L3 cache boundary, the performance takes off very rapidly. This is a <a href=/hpc/cpu-cache/associativity>cache associativity</a> effect: the most frequently used cells all have their indices divisible by large powers of two, so they get aliased to the same cache set, kicking each other out and effectively reducing the cache size.</p><p>One way to negate this effect is to insert &ldquo;holes&rdquo; in the layout like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kr>inline</span> <span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>hole</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span> <span class=o>+</span> <span class=p>(</span><span class=n>k</span> <span class=o>&gt;&gt;</span> <span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>t</span><span class=p>[</span><span class=n>hole</span><span class=p>(</span><span class=n>N</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>k</span> <span class=o>+=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>N</span><span class=p>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=n>k</span> <span class=o>&amp;</span> <span class=o>-</span><span class=n>k</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>t</span><span class=p>[</span><span class=n>hole</span><span class=p>(</span><span class=n>k</span><span class=p>)]</span> <span class=o>+=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>k</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&amp;=</span> <span class=n>k</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>hole</span><span class=p>(</span><span class=n>k</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Computing the <code>hole</code> function is not on the critical path between iterations, so it does not introduce any significant overhead but completely removes the cache associativity problem and shrinks the latency by up to 3x on large arrays:</p><p><figure><img src=../img/segtree-fenwick-holes.svg><figcaption></figcaption></figure></p><p>Fenwick trees are fast, but there are still other minor issues with them. Similar to <a href=../binary-search>binary search</a>, the temporal locality of their memory accesses is not the greatest, as rarely accessed elements are grouped with the most frequently accessed ones. Fenwick trees also execute a non-constant number of iterations and have to perform end-of-loop checks, very likely causing a branch misprediction — although just a single one.</p><p>There are probably still some things to optimize, but we are going to leave it there and focus on an entirely different approach, and if you know <a href=../s-tree>S-trees</a>, you probably already know where this is headed.</p><span class=anchor id=wide-segment-trees></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#wide-segment-trees>#</a>Wide Segment Trees</h3><p>Here is the main idea: if the memory system is fetching a full <a href=/hpc/cpu-cache/cache-lines>cache line</a> for us anyway, let&rsquo;s fill it to the maximum with information that lets us process the query quicker. For segment trees, this means storing more than one data point in a node. This lets us reduce the tree height and perform fewer iterations when descending or ascending it:</p><p><figure><img src=../img/segtree-wide.png><figcaption></figcaption></figure></p><p>We will use the term <em>wide (B-ary) segment tree</em> to refer to this modification.</p><p>To implement this layout, we can use a similar <a href=/hpc/compilation/precalc>constexpr</a>-based approach we used in <a href=../s-tree#implicit-b-tree-1>S+ trees</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>4</span><span class=p>,</span> <span class=n>B</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=n>b</span><span class=p>);</span> <span class=c1>// cache line size (in integers, not bytes)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// the height of the tree over an n-element array 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>height</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=n>B</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=n>height</span><span class=p>(</span><span class=n>n</span> <span class=o>/</span> <span class=n>B</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// where the h-th layer starts
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>offset</span><span class=p>(</span><span class=kt>int</span> <span class=n>h</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=n>N</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>h</span><span class=o>--</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>n</span> <span class=o>=</span> <span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=n>B</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>+=</span> <span class=n>n</span> <span class=o>*</span> <span class=n>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>H</span> <span class=o>=</span> <span class=n>height</span><span class=p>(</span><span class=n>N</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>alignas</span><span class=p>(</span><span class=mi>64</span><span class=p>)</span> <span class=kt>int</span> <span class=n>t</span><span class=p>[</span><span class=n>offset</span><span class=p>(</span><span class=n>H</span><span class=p>)];</span> <span class=c1>// an array for storing nodes
</span></span></span></code></pre></div><p>This way, we effectively reduce the height of the tree by approximately $\frac{\log_B n}{\log_2 n} = \log_2 B$ times ($\sim4$ times if $B = 16$), but it becomes non-trivial to implement in-node operations efficiently. For our problem, we have two main options:</p><ol><li>We could store $B$ <em>sums</em> in each node (for each of its $B$ children).</li><li>We could store $B$ <em>prefix sums</em> in each node (the $i$-th being the sum of the first $(i + 1)$ children).</li></ol><p>If we go with the first option, the <code>add</code> query would be largely the same as in the bottom-up segment tree, but the <code>sum</code> query would need to add up to $B$ scalars in each node it visits. And if we go with the second option, the <code>sum</code> query would be trivial, but the <code>add</code> query would need to add <code>x</code> to some suffix on each node it visits.</p><p>In either case, one operation would perform $O(\log_B n)$ operations, touching just one scalar in each node, while the other would perform $O(B \cdot \log_B n)$ operations, touching up to $B$ scalars in each node. We can, however, use <a href=/hpc/simd>SIMD</a> to accelerate the slower operation, and since there are no fast <a href=/hpc/simd/reduction>horizontal reductions</a> in SIMD instruction sets, but it is easy to add a vector to a vector, we will choose the second approach and store prefix sums in each node.</p><p>This makes the <code>sum</code> query extremely fast and easy to implement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>sum</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>h</span> <span class=o>&lt;</span> <span class=n>H</span><span class=p>;</span> <span class=n>h</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>+=</span> <span class=n>t</span><span class=p>[</span><span class=n>offset</span><span class=p>(</span><span class=n>h</span><span class=p>)</span> <span class=o>+</span> <span class=p>(</span><span class=n>k</span> <span class=o>&gt;&gt;</span> <span class=p>(</span><span class=n>h</span> <span class=o>*</span> <span class=n>b</span><span class=p>))];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>add</code> query is more complicated and slower. We need to add a number only to a suffix of a node, and we can do this by <a href=/hpc/simd/masking>masking out</a> the positions that should not be modified.</p><p>We can pre-calculate a $B \times B$ array corresponding to $B$ such masks that tell, for each of $B$ positions within a node, whether a certain prefix sum value needs to be updated or not:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Precalc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>alignas</span><span class=p>(</span><span class=mi>64</span><span class=p>)</span> <span class=kt>int</span> <span class=n>mask</span><span class=p>[</span><span class=n>B</span><span class=p>][</span><span class=n>B</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>Precalc</span><span class=p>()</span> <span class=o>:</span> <span class=n>mask</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>B</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>B</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>mask</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;</span> <span class=n>k</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>Precalc</span> <span class=n>T</span><span class=p>;</span>
</span></span></code></pre></div><p>Apart from this masking trick, the rest of the computation is simple enough to be handled with <a href=/hpc/simd/intrinsics#gcc-vector-extensions>GCC vector types</a> only. When processing the <code>add</code> query, we just use these masks to bitwise-and them with the broadcasted <code>x</code> value to mask it and then add it to the values stored in the node:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>int</span> <span class=n>vec</span> <span class=nf>__attribute__</span> <span class=p>((</span> <span class=n>vector_size</span><span class=p>(</span><span class=mi>32</span><span class=p>)</span> <span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=nf>round</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span> <span class=o>&amp;</span> <span class=o>~</span><span class=p>(</span><span class=n>B</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// = k / B * B
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vec</span> <span class=n>v</span> <span class=o>=</span> <span class=n>x</span> <span class=o>+</span> <span class=n>vec</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>h</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>h</span> <span class=o>&lt;</span> <span class=n>H</span><span class=p>;</span> <span class=n>h</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>a</span> <span class=o>=</span> <span class=p>(</span><span class=n>vec</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>t</span><span class=p>[</span><span class=n>offset</span><span class=p>(</span><span class=n>h</span><span class=p>)</span> <span class=o>+</span> <span class=n>round</span><span class=p>(</span><span class=n>k</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>m</span> <span class=o>=</span> <span class=p>(</span><span class=n>vec</span><span class=o>*</span><span class=p>)</span> <span class=n>T</span><span class=p>.</span><span class=n>mask</span><span class=p>[</span><span class=n>k</span> <span class=o>%</span> <span class=n>B</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>B</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+=</span> <span class=n>v</span> <span class=o>&amp;</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>&gt;&gt;=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This speeds up the <code>sum</code> query by more than 10x and the <code>add</code> query by up to 4x compared to the Fenwick tree:</p><p><figure><img src=../img/segtree-simd.svg><figcaption></figcaption></figure></p><p>Unlike <a href=../s-tree>S-trees</a>, the block size can be easily changed in this implementation (by literally changing one character). Expectedly, when we increase it, the update time also increases as we need to fetch more cache lines and process them, but the <code>sum</code> query time decreases as the height of the tree becomes smaller:</p><p><figure><img src=../img/segtree-simd-others.svg><figcaption></figcaption></figure></p><p>Similar to the <a href=../s-tree/#modifications-and-further-optimizations>S+ trees</a>, the optimal memory layout probably has non-uniform block sizes, depending on the problem size and the distribution of queries, but we are not going to explore this idea and just leave the optimization here.</p><span class=anchor id=comparisons></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#comparisons>#</a>Comparisons</h3><p>Wide segment trees are significantly faster compared to other popular segment tree implementations:</p><p><figure><img src=../img/segtree-popular.svg><figcaption></figcaption></figure></p><p>The relative speedup is in the orders of magnitude:</p><p><figure><img src=../img/segtree-popular-relative.svg><figcaption></figcaption></figure></p><p>Compared to the original pointer-based implementation, the wide segment tree is up to 200 and 40 times faster for the prefix sum and update queries, respectively — although, for sufficiently large arrays, both implementations become purely memory-bound, and this speedup goes down to around 60 and 15 respectively.</p><span class=anchor id=modifications></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#modifications>#</a>Modifications</h3><p>We have only focused on the prefix sum problem for 32-bit integers — to make this already long article slightly less long and also to make the comparison with the Fenwick tree fair — but wide segment trees can be used for other common range operations, although implementing them efficiently with SIMD requires some creativity.</p><p><em>Disclaimer:</em> I haven&rsquo;t implemented any of these ideas, so some of them may be fatally flawed.</p><p><strong>Other data types</strong> can be trivially supported by changing the vector type and, if they differ in size, the node size $B$ — which also changes the tree height and hence the total number of iterations for both queries.</p><p>It may also be that the queries have different limits on the updates and the prefix sum queries. For example, it is not uncommon to have only &ldquo;$\pm 1$&rdquo; update queries with a guarantee that the result of the prefix sum query always fits into a 32-bit integer. If the result could fit into 8 bits, we&rsquo;d simply use a 8-bit <code>char</code> with block size of $B=64$ bytes, making the total tree height $\frac{\log_{16} n}{\log_{64} n} = \log_{16} 64 = 1.5$ times smaller and both queries proportionally faster.</p><p>Unfortunately, that doesn&rsquo;t work in the general case, but we still have a way to speed up queries when the update deltas are small: we can <em>buffer</em> the updates queries. Using the same &ldquo;$\pm 1$&rdquo; example, we can make the branching factor $B=64$ as we wanted, and in each node, we store $B$ 32-bit integers, $B$ 8-bit signed chars, and a single 8-bit counter variable that starts at $127$ and decrements each time we update a node. Then, when we process the queries in nodes:</p><ul><li>For the update query, we add a vector of masked 8-bit plus-or-minus ones to the <code>char</code> array, decrement the counter, and, if it is zero, <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=3037,3009,4870,6715,4845,3853,288,6570,90,7307,5993,2692,6946,6949,5456,6938,5456,1021,3007,514,518,7253,7183,3892,5135,5260,3915,4027,3873,7401,4376,4229,151,2324,2310,2324,591,4075,3011,3009,6130,4875,6385,5259,6385,6250,1395,7253,6452,7492,4669,4669,7253,1039,1029,4669,4707,7253,7242,848,879,848,7251,4275,879,874,849,833,6046,7250,4870,4872,4875,849,849,5144,4875,4787,4787,4787,3016,3018,5227,7359,7335,7392,4787,5259,5230,5230,5223,5214,6438,5229,488,483,6527,6527,6554,1829,1829,1829&amp;techs=AVX,AVX2&amp;text=cvtepi8_">convert</a> the values in the <code>char</code> array to 32-bit integers, add them to the integer array, set the <code>char</code> array to zero, and reset the counter back to 127.</li><li>For the prefix sum query, we visit the same nodes but add <em>both</em> <code>int</code> and <code>char</code> values to the result.</li></ul><p>This update accumulation trick lets us increase the performance by up to 1.5x at the cost of using ~25% more memory.</p><p>Having a conditional branch in the <code>add</code> query and adding the <code>char</code> array to the <code>int</code> array is rather slow, but since we only have to do it every 127 iterations, it doesn&rsquo;t cost us anything in the amortized sense. The processing time for the <code>sum</code> query increases, but not significantly — because it mostly depends on the slowest read rather than the number of iterations.</p><p><strong>General range queries</strong> can be supported the same way as in the Fenwick tree: just decompose the range $[l, r)$ as the difference of two prefix sums $[0, r)$ and $[0, l)$.</p><p>This also works for some operations other than addition (multiplication modulo prime, xor, etc.), although they have to be <em>reversible:</em> there should be a way to quickly &ldquo;cancel&rdquo; the operation on the left prefix from the final result.</p><p><strong>Non-reversible operations</strong> can also be supported, although they should still satisfy some other properties:</p><ul><li>They must be <em>associative:</em> $(a \circ b) \circ c = a \circ (b \circ c)$.</li><li>They must have an <em>identity element:</em> $a \circ e = e \circ a = a$.</li></ul><p>(Such algebraic structures are called <a href=https://en.wikipedia.org/wiki/Monoid>monoids</a> if you&rsquo;re a snob.)</p><p>Unfortunately, the prefix sum trick doesn&rsquo;t work when the operation is not reversible, so we have to switch to <a href=#wide-segment-trees>option one</a> and store the results of these operations separately for each segment. This requires some significant changes to the queries:</p><ul><li>The update query should replace one scalar at the leaf, perform a <a href=/hpc/simd/reduction/#horizontal-summation>horizontal reduction</a> at the leaf node, and then continue upwards, replacing one scalar of its parent and so on.</li><li>The range reduction query should, separately for left and right borders, calculate a vector with vertically reduced values on their paths, combine these two vectors into one, and then reduce it horizontally to return the final answer. Note that we still need to use masking to replace values outside of query with neutral elements, and this time, it probably requires some conditional moves/blending and either $B \times B$ precomputed masks or using two masks to account for both left and right borders of the query.</li></ul><p>This makes both queries much slower — especially the reduction — but this should still be faster compared to the bottom-up segment tree.</p><p><strong>Minimum</strong> is a nice exception where the update query can be made slightly faster if the new value of the element is less than the current one: we can skip the horizontal reduction part and just update $\log_B n$ nodes using a scalar procedure.</p><p>This works very fast when we mostly have such updates, which is the case, e.g., for the sparse-graph Dijkstra algorithm when we have more edges than vertices. For this problem, the wide segment tree can serve as an efficient fixed-universe min-heap.</p><p><strong>Lazy propagation</strong> can be done by storing a separate array for the delayed operations in a node. To propagate the updates, we need to go top to bottom (which can be done by simply reversing the direction of the <code>for</code> loop and using <code>k >> (h * b)</code> to calculate the <code>h</code>-th ancestor), <a href=/hpc/simd/moving/#broadcast>broadcast</a> and reset the delayed operation value stored in the parent of the current node, and apply it to all values stored in the current node with SIMD.</p><p>One minor problem is that for some operations, we need to know the lengths of the segments: for example, when we need to support a sum and a mass assignment. It can be solved by either padding the elements so that each segment on a layer is uniform in size, pre-calculating the segment lengths and storing them in the node, or using predication to check for the problematic nodes (there will be at most one on each layer).</p><span class=anchor id=acknowledgements></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/data-structures/segment-trees/#acknowledgements>#</a>Acknowledgements</h3><p>Many thanks to Giulio Ermanno Pibiri for collaborating on this case study, which is largely based on his 2020 paper &ldquo;<a href=https://arxiv.org/pdf/2006.14552.pdf>Practical Trade-Offs for the Prefix-Sum Problem</a>&rdquo; co-authored with Rossano Venturini. I highly recommend reading the original article if you are interested in the details we&rsquo;ve skipped through here for brevity.</p><p>The code and some ideas regarding bottom-up segment trees were adapted from a 2015 blog post &ldquo;<a href=https://codeforces.com/blog/entry/18051>Efficient and easy segment trees</a>&rdquo; by Oleksandr Bacherikov.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Segment trees are rarely mentioned in the theoretical computer science literature because they are relatively novel (invented ~2000), mostly don&rsquo;t do anything that <a href=https://en.wikipedia.org/wiki/Tree_(data_structure)>any other binary tree</a> can&rsquo;t do, and <em>asymptotically</em> aren&rsquo;t faster — although, in practice, they often win by a lot in terms of speed.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><div class=nextprev><div class=left><a href=http://jyang772.github.io/hugo-page/hpc/data-structures/b-tree/ id=prev-article>← Search Trees</a></div><div class=right></div></div></main><footer>Copyright 2021–2022 Sergey Slotin<br></footer></div></body></html>