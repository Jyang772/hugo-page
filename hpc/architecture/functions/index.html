<!doctype html>
<html lang='en-us'><head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WBN59M8Y5S');
</script>


<script type="text/javascript">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(53961409, "init", {
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<meta charset="utf-8">

  
  <link rel="stylesheet" href="/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css" integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8&#43;ZXdZy0=">
  <link rel="stylesheet" href="/syntax.css" id="syntax-theme">

  <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
  <script src="https://tikzjax.com/v1/tikzjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="/scripts/lunr.stemmer.support.min.js"></script>
  <script src="/scripts/lunr.ru.min.js"></script>
  <script src="/scripts/lunr.multi.min.js"></script>

  
  <link rel="stylesheet" id="theme">

  <script>
    function toggleSidebar() {
      console.log("Toggling sidebar visibility")
      var sidebar = document.getElementById('sidebar')
      var wrapper = document.getElementById('wrapper')
      if (sidebar.classList.contains('sidebar-toggled') || window.getComputedStyle(sidebar).display == 'block') { 
        sidebar.classList.toggle('sidebar-hidden')
        wrapper.classList.toggle('sidebar-hidden')
      }
      sidebar.classList.add('sidebar-toggled')
      wrapper.classList.add('sidebar-toggled')
    }

    function switchTheme(theme) {
      console.log("Changing theme:", theme)
      document.getElementById('theme').href = (theme == 'dark' ? "\/hugo-page\/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css" : "")
      document.getElementById('syntax-theme').href = (theme == 'dark' ? '/syntax-dark.css' : '/syntax.css')
      localStorage.setItem('theme', theme)
    }

    async function toggleSearch() {
      console.log("Toggling search")
      
      var searchDiv = document.getElementById('search')
      if (window.getComputedStyle(searchDiv).display == 'none') {
        searchDiv.style.display = 'block'
        window.scrollTo({ top: 0 });
        document.getElementById('search-bar').focus()
      } else {
        searchDiv.style.display = 'none'  
      }

      if (!index) {
        console.log("Fetching index")
        const response = await fetch('/searchindex.json')
        const pages = await response.json()
        index = lunr(function() {
          this.use(lunr.multiLanguage('en', 'ru'))
          this.field('title', {
            boost: 5
          })
          this.field('content', {
            boost: 1
          })
          pages.forEach(function(doc) {
            this.add(doc)
            articles.push(doc)
          }, this)
        })
        console.log("Ready to search")
      }
    }

    var articles = []
    var index = undefined

    function search() {
      var query = document.getElementById('search-bar').value
      var resultsDiv = document.getElementById('search-results')
      var countDiv = document.getElementById('search-count')
      
      if (query == '') {
        resultsDiv.innerHTML = ''
        countDiv.innerHTML = ''
        return
      }
      
      var results = index.search(query)

      countDiv.innerHTML = 'Found <b>' + results.length + '</b> pages'

      let resultList = ''

      for (const n in results) {
        const item = articles[results[n].ref]
        resultList += '<li><a href="' + item.path + '">' + item.title + '</a> <p>'
        const text = item.content

        const contextLimit = 80

        if (text.includes(query)) {
          const start = text.indexOf(query)
          if (start > contextLimit)
            resultList += '…'
          resultList += text.substring(start - contextLimit, start)
                      + '<b>' + query + '</b>' + text.substring(start + query.length, start + query.length + contextLimit)

        } else {
          resultList += text.substring(0, contextLimit * 2)
        }
        resultList += '…</p></li>'
      }

      resultsDiv.innerHTML = resultList
    }

    if (localStorage.getItem('theme') == 'dark') {
      switchTheme('dark')
    }

    window.addEventListener('load', function() {
      var el = document.getElementById("active-element")
      
      if (el) {
        el.scrollIntoView({block: "center"})
      }
      

    })

    window.addEventListener('scroll', function() {
      var menu = document.getElementById('menu')
      if (window.scrollY < 120) {
        
        menu.classList.remove('scrolled')
      } else {
        
        menu.classList.add('scrolled')
      }
    })

    window.addEventListener('keydown', function(e) {
      if (e.altKey) { return }
      if (document.activeElement.tagName == 'INPUT') { return }
      if (e.key == 'ArrowLeft') {
        document.getElementById('prev-article').click()
      } else if (e.key == 'ArrowRight') {
        document.getElementById('next-article').click()
      }
    })
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  })"></script>

  
  <title>Functions and Recursion - Algorithmica</title>
</head>
<body><nav id='sidebar' >
  
  
  <div class='title'>
    <a href='/'>Algorithmica</a>
    
      
        
        <span class='slash'>/</span>
        <a href='/hugo-page/hpc/' class='divisionAbbr'
           >
          HPC
        </a>
      
    
  </div>
  <ul>
    
      
        
          <li class='part'>Performance Engineering</li>
        
        <li class=' '><a href='/hugo-page/hpc/complexity/'
          
          >Complexity Models</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/complexity/hardware/'
                
                >Modern Hardware</a></li>
            
              <li ><a href='/hugo-page/hpc/complexity/languages/'
                
                >Programming Languages</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/architecture/'
          
          >Computer Architecture</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/architecture/isa/'
                
                >Instruction Set Architectures</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/assembly/'
                
                >Assembly Language</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/loops/'
                
                >Loops and Conditionals</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/functions/'
                id='active-element'
                >Functions and Recursion</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/indirect/'
                
                >Indirect Branching</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/layout/'
                
                >Machine Code Layout</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/pipelining/'
          
          >Instruction-Level Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/pipelining/hazards/'
                
                >Pipeline Hazards</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/branching/'
                
                >The Cost of Branching</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/branchless/'
                
                >Branchless Programming</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/tables/'
                
                >Instruction Tables</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/throughput/'
                
                >Throughput Computing</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/compilation/'
          
          >Compilation</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/compilation/stages/'
                
                >Stages of Compilation</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/flags/'
                
                >Flags and Targets</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/situational/'
                
                >Situational Optimizations</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/contracts/'
                
                >Contract Programming</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/precalc/'
                
                >Precomputation</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/profiling/'
          
          >Profiling</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/profiling/instrumentation/'
                
                >Instrumentation</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/events/'
                
                >Statistical Profiling</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/simulation/'
                
                >Program Simulation</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/mca/'
                
                >Machine Code Analyzers</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/benchmarking/'
                
                >Benchmarking</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/noise/'
                
                >Getting Accurate Results</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/arithmetic/'
          
          >Arithmetic</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/arithmetic/float/'
                
                >Floating-Point Numbers</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/ieee-754/'
                
                >IEEE 754 Floats</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/errors/'
                
                >Rounding Errors</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/newton/'
                
                >Newton&#39;s Method</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/rsqrt/'
                
                >Fast Inverse Square Root</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/integer/'
                
                >Integer Numbers</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/division/'
                
                >Integer Division</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/number-theory/'
          
          >Number Theory</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/number-theory/modular/'
                
                >Modular Arithmetic</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/exponentiation/'
                
                >Binary Exponentiation</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/euclid-extended/'
                
                >Extended Euclidean Algorithm</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/montgomery/'
                
                >Montgomery Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/external-memory/'
          
          >External Memory</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/external-memory/hierarchy/'
                
                >Memory Hierarchy</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/virtual/'
                
                >Virtual Memory</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/model/'
                
                >External Memory Model</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/sorting/'
                
                >External Sorting</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/list-ranking/'
                
                >List Ranking</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/policies/'
                
                >Eviction Policies</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/oblivious/'
                
                >Cache-Oblivious Algorithms</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/locality/'
                
                >Spatial and Temporal Locality</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/cpu-cache/'
          
          >RAM &amp; CPU Caches</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/bandwidth/'
                
                >Memory Bandwidth</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/latency/'
                
                >Memory Latency</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/cache-lines/'
                
                >Cache Lines</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/sharing/'
                
                >Memory Sharing</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/mlp/'
                
                >Memory-Level Parallelism</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/prefetching/'
                
                >Prefetching</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/alignment/'
                
                >Alignment and Packing</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/pointers/'
                
                >Pointer Alternatives</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/associativity/'
                
                >Cache Associativity</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/paging/'
                
                >Memory Paging</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/aos-soa/'
                
                >AoS and SoA</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/simd/'
          
          >SIMD Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/simd/intrinsics/'
                
                >Intrinsics and Vector Types</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/moving/'
                
                >Moving Data</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/reduction/'
                
                >Reductions</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/masking/'
                
                >Masking and Blending</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/shuffling/'
                
                >In-Register Shuffles</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/auto-vectorization/'
                
                >Auto-Vectorization and SPMD</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/algorithms/'
          
          >Algorithms Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/algorithms/gcd/'
                
                >Binary GCD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/factorization/'
                
                >Integer Factorization</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/argmin/'
                
                >Argmin with SIMD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/prefix/'
                
                >Prefix Sum with SIMD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/matmul/'
                
                >Matrix Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/data-structures/'
          
          >Data Structures Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/data-structures/binary-search/'
                
                >Binary Search</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/s-tree/'
                
                >Static B-Trees</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/b-tree/'
                
                >Search Trees</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/segment-trees/'
                
                >Segment Trees</a></li>
            
          </ol>
        
      
    
  </ul>
</nav>
<div id='wrapper' ><menu id='menu'>
  
  
  <div class='left'>
    <a>
      <img src='/icons/bars-solid.svg'
           onclick='toggleSidebar()'
           title='open table of contents'>
    </a>
    <a>
      <img src='/icons/adjust-solid.svg'
           style='position: relative; top: -1px'
           onclick='switchTheme(localStorage.getItem("theme") == "dark" ? "light" : "dark")'
           title='dark theme'>
    </a>
    <a>
      <img src='/icons/search-solid.svg'
           onclick='toggleSearch()'
           title='search'>
    </a>
  </div>
  <div class='title'>Functions and Recursion</div>
  <div class='right'>
    <a onClick='window.print()'>
      <img src='/icons/print-solid.svg' title='print'>
    </a>
    <a href='https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2farchitecture%2ffunctions.md'>
      <img src='/icons/edit-solid.svg'
           title='edit'
           style='width: 18px; position: relative; right: -2px; top: -1px'>
    </a>
    <a href='https://github.com/algorithmica-org/algorithmica/blob/master//hpc/architecture/functions.md' class='github-main'>
      <img src='/icons/github-brands.svg' title='view on github'>
    </a>
  </div>
</menu>
<main>
        <div id="search">
    <input id="search-bar" type="search" placeholder='Search this book…' oninput="search()">
    <div id="search-count"></div>
    <div id="search-results">
    </div>
</div>
<header>
  
  <h1>Functions and Recursion</h1>
  
    <div class='info'></div>
  
</header>
<article>
  


  
    
    
      
        <p>To &ldquo;call a function&rdquo; in assembly, you need to <a href="../loops">jump</a> to its beginning and then jump back. But then two important problems arise:</p>
<ol>
<li>What if the caller stores data in the same registers as the callee?</li>
<li>Where is &ldquo;back&rdquo;?</li>
</ol>
<p>Both of these concerns can be solved by having a dedicated location in memory where we can write all the information we need to return from the function before calling it. This location is called <em>the stack</em>.</p>
<span class='anchor' id="the-stack"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/architecture/functions/#the-stack">#</a>The Stack</h3><p>The hardware stack works the same way software stacks do and is similarly implemented as just two pointers:</p>
<ul>
<li>The <em>base pointer</em> marks the start of the stack and is conventionally stored in <code>rbp</code>.</li>
<li>The <em>stack pointer</em> marks the last element of the stack and is conventionally stored in <code>rsp</code>.</li>
</ul>
<p>When you need to call a function, you push all your local variables onto the stack (which you can also do in other circumstances; e.g., when you run out of registers), push the current instruction pointer, and then jump to the beginning of the function. When exiting from a function, you look at the pointer stored on top of the stack, jump there, and then carefully read all the variables stored on the stack back into their registers.</p>
<!--

Function parameters and local variables are accessed by adding and subtracting, respectively, a constant offset from `ebp`.

ebp itself actually points to the previous frame's base pointer, which enables stack walking in a debugger and viewing other frames local variables to work. Fun things, such as stopping the program and seeing which functions are called by which.

push ebp      ; Preserve current frame pointer
mov ebp, esp  ; Create new frame pointer pointing to current stack top
sub esp, 20   ; allocate 20 bytes worth of locals on stack.

frame pointer omission optimization which you can enable will actually eliminate this and use ebp as another register and access locals directly off of esp, but this makes debugging a bit more difficult since the debugger can no longer directly access the stack frames of earlier function calls.

When a function starts, it executed a *function prologue*: saves the previous base pointer on the stack and sets `rbp = rsp`.

-->
<p>You can implement all that with the usual memory operations and jumps, but because of how frequently it is used, there are 4 special instructions for doing this:</p>
<ul>
<li><code>push</code> writes data at the stack pointer and decrements it.</li>
<li><code>pop</code> reads data from the stack pointer and increments it.</li>
<li><code>call</code> puts the address of the following instruction on top of the stack and jumps to a label.</li>
<li><code>ret</code> reads the return address from the top of the stack and jumps to it.</li>
</ul>
<p>You would call them &ldquo;syntactic sugar&rdquo; if they weren&rsquo;t actual hardware instructions — they are just fused equivalents of these two-instruction snippets:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; &#34;push rax&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="kt">QWORD</span> <span class="nv">PTR</span><span class="p">[</span><span class="nb">rsp</span><span class="p">],</span> <span class="nb">rax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; &#34;pop rax&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">rax</span><span class="p">,</span> <span class="kt">QWORD</span> <span class="nv">PTR</span><span class="p">[</span><span class="nb">rsp</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nf">add</span> <span class="nb">rsp</span><span class="p">,</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; &#34;call func&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nf">push</span> <span class="nv">rip</span> <span class="c1">; &lt;- instruction pointer (although accessing it like that is probably illegal)</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nv">func</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; &#34;ret&#34;</span>
</span></span><span class="line"><span class="cl"><span class="nf">pop</span>  <span class="nb">rcx</span> <span class="c1">; &lt;- choose any unused register</span>
</span></span><span class="line"><span class="cl"><span class="nf">jmp</span> <span class="nb">rcx</span>
</span></span></code></pre></div><p>The memory region between <code>rbp</code> and <code>rsp</code> is called a <em>stack frame</em>, and this is where local variables of functions are typically stored. It is pre-allocated at the start of the program, and if you push more data on the stack than its capacity (8MB by default on Linux), you encounter a <em>stack overflow</em> error. Because modern operating systems don&rsquo;t actually give you memory pages until you read or write to their address space, you can freely specify a very large stack size, which acts more like a limit on how much stack memory can be used, and not a fixed amount every program has to use.</p>
<!--

It is convenient to save the frame pointer `rbp` at the beginning of a function and replace it with `rsp` — this way, when leaving a function, you could just restore `rbp` and forget about all its local variables. This sequence is called *function prologue* and usually looks somewhat like that (which is often optimized away by the compiler):

```nasm
push rbp     ; preserve the current frame pointer
mov rbp, rsp ; create a new frame pointer pointing to the current top of the stack
sub rsp, 20  ; allocate 20 bytes worth of locals on stack
```

-->
<!--
The memory region dedicated for stack memory (called *stack frame*) is not any different from any other memory region. It is allocated on the start of the program. You could also do tricky stuff, such as 

Functions execute a *prologue* which usually looks somewhat like that:

```nasm
push rbp     ; preserve the current frame pointer
mov rbp, rsp ; create a new frame pointer pointing to the current top of the stack
sub rsp, 20  ; allocate 20 bytes worth of locals on stack
```

Note that the data in the stack is written top-to-bottom. This is just a convention: it could be the other way around. When you need to "leave" a function or a visibility scope such as the body of an `if` or a `for`, you can just increase the stack pointer.

-->
<span class='anchor' id="calling-conventions"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/architecture/functions/#calling-conventions">#</a>Calling Conventions</h3><p>The people who develop compilers and operating systems eventually came up with <a href="https://wiki.osdev.org/Calling_Conventions">conventions</a> on how to write and call functions. These conventions enable some important <a href="/hpc/compilation/stages/">software engineering marvels</a> such as splitting compilation into separate units, reusing already-compiled libraries, and even writing them in different programming languages.</p>
<p>Consider the following example in C:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">square</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">distance</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="nf">square</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><!--

When compiled without any optimization flags, it produces the following assembly:

```nasm
square:
    push    rbp
    mov     rbp, rsp
    mov     DWORD PTR [rbp-4], edi
    mov     eax, DWORD PTR [rbp-4]
    imul    eax, eax
    pop     rbp
    ret
length:
    push    rbp
    mov     rbp, rsp
    push    rbx
    sub     rsp, 8
    mov     DWORD PTR [rbp-12], edi
    mov     DWORD PTR [rbp-16], esi
    mov     eax, DWORD PTR [rbp-12]
    mov     edi, eax
    call    square
    mov     ebx, eax
    mov     eax, DWORD PTR [rbp-16]
    mov     edi, eax
    call    square
    add     eax, ebx
    mov     rbx, QWORD PTR [rbp-8]
    leave
    ret
```
-->
<p>By convention, a function should take its arguments in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> (and the rest in the stack if those weren&rsquo;t enough), put the return value into <code>rax</code>, and then return. Thus, <code>square</code>, being a simple one-argument function, can be implemented like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">square:</span>             <span class="c1">; x = edi, ret = eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>Each time we call it from <code>distance</code>, we just need to go through some trouble preserving its local variables:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>           <span class="c1">; x = rdi/edi, y = rsi/esi, ret = rax/eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>     <span class="c1">; eax = square(x)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>   <span class="c1">; save x^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">rdi</span><span class="p">,</span> <span class="nb">rsi</span>   <span class="c1">; move new x=y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>     <span class="c1">; eax = square(x=y)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rsi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">rdi</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>   <span class="c1">; x^2 + y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>There are a lot more nuances, but we won&rsquo;t go into detail here because this book is about performance, and the best way to deal with functions calls is actually to avoid making them in the first place.</p>
<span class='anchor' id="inlining"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/architecture/functions/#inlining">#</a>Inlining</h3><p>Moving data to and from the stack creates noticeable overhead for small functions like these. The reason you have to do this is that, in general, you don&rsquo;t know whether the callee is modifying the registers where you store your local variables. But when you have access to the code of <code>square</code>, you can solve this problem by stashing the data in registers that you know won&rsquo;t be modified.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">edi</span><span class="p">,</span> <span class="nb">esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">square</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>This is better, but we are still implicitly accessing stack memory: you need to push and pop the instruction pointer on each function call. In simple cases like this, we can <em>inline</em> function calls by stitching the callee&rsquo;s code into the caller and resolving conflicts over registers. In our example:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>       <span class="c1">; edi = x^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>       <span class="c1">; esi = y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>  <span class="nb">edi</span><span class="p">,</span> <span class="nb">esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>       <span class="c1">; there is no &#34;add eax, edi, esi&#34;, so we need a separate mov</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>This is fairly close to what optimizing compilers produce out of this snippet — only they use the <a href="../assembly">lea trick</a> to make the resulting machine code sequence a few bytes smaller:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">distance:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>       <span class="c1">; edi = x^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">esi</span><span class="p">,</span> <span class="nb">esi</span>       <span class="c1">; esi = y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">lea</span>  <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="o">+</span><span class="nb">rsi</span><span class="p">]</span> <span class="c1">; eax = x^2 + y^2</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>In situations like these, function inlining is clearly beneficial, and compilers mostly do it <a href="/hpc/compilation/situational">automatically</a>, but there are cases when it&rsquo;s not — and we will talk about them <a href="../layout">in a bit</a>.</p>
<span class='anchor' id="tail-call-elimination"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/architecture/functions/#tail-call-elimination">#</a>Tail Call Elimination</h3><p>Inlining is straightforward to do when the callee doesn&rsquo;t make any other function calls, or at least if these calls are not recursive. Let&rsquo;s move on to a more complex example. Consider this recursive computation of a factorial:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Equivalent assembly:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; n = edi, ret = eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">factorial:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">test</span> <span class="nb">edi</span><span class="p">,</span> <span class="nb">edi</span>   <span class="c1">; test if a value is zero</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jne</span>  <span class="nv">nonzero</span>    <span class="c1">; (the machine code of &#34;cmp rax, 0&#34; would be one byte longer)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>     <span class="c1">; return 1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span><span class="line"><span class="cl"><span class="nl">nonzero:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="nb">edi</span>        <span class="c1">; save n to use later in multiplication</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span>  <span class="nb">edi</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">call</span> <span class="nv">factorial</span>  <span class="c1">; call f(n - 1)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pop</span>  <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>If the function is recursive, it is still often possible to make it &ldquo;call-less&rdquo; by restructuring it. This is the case when the function is <em>tail recursive</em>, that is, it returns right after making a recursive call. Since no actions are required after the call, there is also no need for storing anything on the stack, and a recursive call can be safely replaced with a jump to the beginning — effectively turning the function into a loop.</p>
<p>To make our <code>factorial</code> function tail-recursive, we can pass a &ldquo;current product&rdquo; argument to it:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">p</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Then this function can be easily folded into a loop:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; assuming n &gt; 0</span>
</span></span><span class="line"><span class="cl"><span class="nl">factorial:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>  <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">imul</span> <span class="nb">eax</span><span class="p">,</span> <span class="nb">edi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span>  <span class="nb">edi</span><span class="p">,</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jne</span>  <span class="nv">loop</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ret</span>
</span></span></code></pre></div><p>The primary reason why recursion can be slow is that it needs to read and write data to the stack, while iterative and tail-recursive algorithms do not. This concept is very important in functional programming, where there are no loops and all you can use are functions. Without tail call elimination, functional programs would require way more time and memory to execute.</p>

      
    
  



        </article>
        <div class='nextprev'>
  
    
      
      

      
      
      
        
      
        
      
        
      
        
          
        
      
        
      
        
      

      
        <div class='left'>
        
          <a href='https://jyang772.github.io/hugo-page/hpc/architecture/loops/' id='prev-article'>← Loops and Conditionals</a>
        
        </div>
        <div class='right'>
        
          <a href='https://jyang772.github.io/hugo-page/hpc/architecture/indirect/' id='next-article'>Indirect Branching →</a>
        
        </div>
      
    
  
</div>

      </main>
      <footer>
  Copyright 2021–2022 Sergey Slotin
  <br>
   
</footer>

    </div>
  </body>
</html>
