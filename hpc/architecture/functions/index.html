<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WBN59M8Y5S")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(53961409,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/53961409 style=position:absolute;left:-9999px alt></div></noscript><meta charset=utf-8><link rel=stylesheet href=/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8+ZXdZy0="><link rel=stylesheet href=/syntax.css id=syntax-theme><link rel=stylesheet type=text/css href=https://tikzjax.com/v1/fonts.css><script src=https://tikzjax.com/v1/tikzjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js></script><script src=/hugo-page/scripts/lunr.stemmer.support.min.js></script><script src=/hugo-page/scripts/lunr.ru.min.js></script><script src=/hugo-page/scripts/lunr.multi.min.js></script><link rel=stylesheet id=theme><script>function toggleSidebar(){console.log("Toggling sidebar visibility");var e=document.getElementById("sidebar"),t=document.getElementById("wrapper");(e.classList.contains("sidebar-toggled")||window.getComputedStyle(e).display=="block")&&(e.classList.toggle("sidebar-hidden"),t.classList.toggle("sidebar-hidden")),e.classList.add("sidebar-toggled"),t.classList.add("sidebar-toggled")}function switchTheme(e){console.log("Changing theme:",e),document.getElementById("theme").href=e=="dark"?"/hugo-page/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css":"",document.getElementById("syntax-theme").href=e=="dark"?"/syntax-dark.css":"/syntax.css",localStorage.setItem("theme",e)}async function toggleSearch(){console.log("Toggling search");var e=document.getElementById("search");if(window.getComputedStyle(e).display=="none"?(e.style.display="block",window.scrollTo({top:0}),document.getElementById("search-bar").focus()):e.style.display="none",!index){console.log("Fetching index");const e=await fetch("/hugo-page/searchindex.json"),t=await e.json();index=lunr(function(){this.use(lunr.multiLanguage("en","ru")),this.field("title",{boost:5}),this.field("content",{boost:1}),t.forEach(function(e){this.add(e),articles.push(e)},this)}),console.log("Ready to search")}}var articles=[],index=void 0;function search(){var n,e=document.getElementById("search-bar").value,s=document.getElementById("search-results"),o=document.getElementById("search-count");if(e==""){s.innerHTML="",o.innerHTML="";return}n=index.search(e),o.innerHTML="Found <b>"+n.length+"</b> pages";let t="";for(const a in n){const i=articles[n[a].ref];t+='<li><a href="'+i.path+'">'+i.title+"</a> <p>";const s=i.content,o=80;if(s.includes(e)){const n=s.indexOf(e);n>o&&(t+="…"),t+=s.substring(n-o,n)+"<b>"+e+"</b>"+s.substring(n+e.length,n+e.length+o)}else t+=s.substring(0,o*2);t+="…</p></li>"}s.innerHTML=t}localStorage.getItem("theme")=="dark"&&switchTheme("dark"),window.addEventListener("load",function(){var e=document.getElementById("active-element");e&&e.scrollIntoView({block:"center"})}),window.addEventListener("scroll",function(){var e=document.getElementById("menu");window.scrollY<120?e.classList.remove("scrolled"):e.classList.add("scrolled")}),window.addEventListener("keydown",function(e){if(e.altKey)return;if(document.activeElement.tagName=="INPUT")return;e.key=="ArrowLeft"?document.getElementById("prev-article").click():e.key=="ArrowRight"&&document.getElementById("next-article").click()})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><title>Functions and Recursion - Algorithmica</title></head><body><nav id=sidebar><div class=title><a href=/>Algorithmica</a>
<span class=slash>/</span>
<a href=/hugo-page/hpc/ class=divisionAbbr>HPC</a></div><ul><li class=part>Performance Engineering</li><li><a href=/hugo-page/hpc/complexity/>Complexity Models</a></li><ol><li><a href=/hugo-page/hpc/complexity/hardware/>Modern Hardware</a></li><li><a href=/hugo-page/hpc/complexity/languages/>Programming Languages</a></li></ol><li><a href=/hugo-page/hpc/architecture/>Computer Architecture</a></li><ol><li><a href=/hugo-page/hpc/architecture/isa/>Instruction Set Architectures</a></li><li><a href=/hugo-page/hpc/architecture/assembly/>Assembly Language</a></li><li><a href=/hugo-page/hpc/architecture/loops/>Loops and Conditionals</a></li><li><a href=/hugo-page/hpc/architecture/functions/ id=active-element>Functions and Recursion</a></li><li><a href=/hugo-page/hpc/architecture/indirect/>Indirect Branching</a></li><li><a href=/hugo-page/hpc/architecture/layout/>Machine Code Layout</a></li></ol><li><a href=/hugo-page/hpc/pipelining/>Instruction-Level Parallelism</a></li><ol><li><a href=/hugo-page/hpc/pipelining/hazards/>Pipeline Hazards</a></li><li><a href=/hugo-page/hpc/pipelining/branching/>The Cost of Branching</a></li><li><a href=/hugo-page/hpc/pipelining/branchless/>Branchless Programming</a></li><li><a href=/hugo-page/hpc/pipelining/tables/>Instruction Tables</a></li><li><a href=/hugo-page/hpc/pipelining/throughput/>Throughput Computing</a></li></ol><li><a href=/hugo-page/hpc/compilation/>Compilation</a></li><ol><li><a href=/hugo-page/hpc/compilation/stages/>Stages of Compilation</a></li><li><a href=/hugo-page/hpc/compilation/flags/>Flags and Targets</a></li><li><a href=/hugo-page/hpc/compilation/situational/>Situational Optimizations</a></li><li><a href=/hugo-page/hpc/compilation/contracts/>Contract Programming</a></li><li><a href=/hugo-page/hpc/compilation/precalc/>Precomputation</a></li></ol><li><a href=/hugo-page/hpc/profiling/>Profiling</a></li><ol><li><a href=/hugo-page/hpc/profiling/instrumentation/>Instrumentation</a></li><li><a href=/hugo-page/hpc/profiling/events/>Statistical Profiling</a></li><li><a href=/hugo-page/hpc/profiling/simulation/>Program Simulation</a></li><li><a href=/hugo-page/hpc/profiling/mca/>Machine Code Analyzers</a></li><li><a href=/hugo-page/hpc/profiling/benchmarking/>Benchmarking</a></li><li><a href=/hugo-page/hpc/profiling/noise/>Getting Accurate Results</a></li></ol><li><a href=/hugo-page/hpc/arithmetic/>Arithmetic</a></li><ol><li><a href=/hugo-page/hpc/arithmetic/float/>Floating-Point Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/ieee-754/>IEEE 754 Floats</a></li><li><a href=/hugo-page/hpc/arithmetic/errors/>Rounding Errors</a></li><li><a href=/hugo-page/hpc/arithmetic/newton/>Newton's Method</a></li><li><a href=/hugo-page/hpc/arithmetic/rsqrt/>Fast Inverse Square Root</a></li><li><a href=/hugo-page/hpc/arithmetic/integer/>Integer Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/division/>Integer Division</a></li></ol><li><a href=/hugo-page/hpc/number-theory/>Number Theory</a></li><ol><li><a href=/hugo-page/hpc/number-theory/modular/>Modular Arithmetic</a></li><li><a href=/hugo-page/hpc/number-theory/exponentiation/>Binary Exponentiation</a></li><li><a href=/hugo-page/hpc/number-theory/euclid-extended/>Extended Euclidean Algorithm</a></li><li><a href=/hugo-page/hpc/number-theory/montgomery/>Montgomery Multiplication</a></li></ol><li><a href=/hugo-page/hpc/external-memory/>External Memory</a></li><ol><li><a href=/hugo-page/hpc/external-memory/hierarchy/>Memory Hierarchy</a></li><li><a href=/hugo-page/hpc/external-memory/virtual/>Virtual Memory</a></li><li><a href=/hugo-page/hpc/external-memory/model/>External Memory Model</a></li><li><a href=/hugo-page/hpc/external-memory/sorting/>External Sorting</a></li><li><a href=/hugo-page/hpc/external-memory/list-ranking/>List Ranking</a></li><li><a href=/hugo-page/hpc/external-memory/policies/>Eviction Policies</a></li><li><a href=/hugo-page/hpc/external-memory/oblivious/>Cache-Oblivious Algorithms</a></li><li><a href=/hugo-page/hpc/external-memory/locality/>Spatial and Temporal Locality</a></li></ol><li><a href=/hugo-page/hpc/cpu-cache/>RAM & CPU Caches</a></li><ol><li><a href=/hugo-page/hpc/cpu-cache/bandwidth/>Memory Bandwidth</a></li><li><a href=/hugo-page/hpc/cpu-cache/latency/>Memory Latency</a></li><li><a href=/hugo-page/hpc/cpu-cache/cache-lines/>Cache Lines</a></li><li><a href=/hugo-page/hpc/cpu-cache/sharing/>Memory Sharing</a></li><li><a href=/hugo-page/hpc/cpu-cache/mlp/>Memory-Level Parallelism</a></li><li><a href=/hugo-page/hpc/cpu-cache/prefetching/>Prefetching</a></li><li><a href=/hugo-page/hpc/cpu-cache/alignment/>Alignment and Packing</a></li><li><a href=/hugo-page/hpc/cpu-cache/pointers/>Pointer Alternatives</a></li><li><a href=/hugo-page/hpc/cpu-cache/associativity/>Cache Associativity</a></li><li><a href=/hugo-page/hpc/cpu-cache/paging/>Memory Paging</a></li><li><a href=/hugo-page/hpc/cpu-cache/aos-soa/>AoS and SoA</a></li></ol><li><a href=/hugo-page/hpc/simd/>SIMD Parallelism</a></li><ol><li><a href=/hugo-page/hpc/simd/intrinsics/>Intrinsics and Vector Types</a></li><li><a href=/hugo-page/hpc/simd/moving/>Moving Data</a></li><li><a href=/hugo-page/hpc/simd/reduction/>Reductions</a></li><li><a href=/hugo-page/hpc/simd/masking/>Masking and Blending</a></li><li><a href=/hugo-page/hpc/simd/shuffling/>In-Register Shuffles</a></li><li><a href=/hugo-page/hpc/simd/auto-vectorization/>Auto-Vectorization and SPMD</a></li></ol><li><a href=/hugo-page/hpc/algorithms/>Algorithms Case Studies</a></li><ol><li><a href=/hugo-page/hpc/algorithms/gcd/>Binary GCD</a></li><li><a href=/hugo-page/hpc/algorithms/factorization/>Integer Factorization</a></li><li><a href=/hugo-page/hpc/algorithms/argmin/>Argmin with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/prefix/>Prefix Sum with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/matmul/>Matrix Multiplication</a></li></ol><li><a href=/hugo-page/hpc/data-structures/>Data Structures Case Studies</a></li><ol><li><a href=/hugo-page/hpc/data-structures/binary-search/>Binary Search</a></li><li><a href=/hugo-page/hpc/data-structures/s-tree/>Static B-Trees</a></li><li><a href=/hugo-page/hpc/data-structures/b-tree/>Search Trees</a></li><li><a href=/hugo-page/hpc/data-structures/segment-trees/>Segment Trees</a></li></ol></ul></nav><div id=wrapper><menu id=menu><div class=left><a><img src=/icons/bars-solid.svg onclick=toggleSidebar() title='open table of contents'>
</a><a><img src=/icons/adjust-solid.svg style=position:relative;top:-1px onclick='switchTheme(localStorage.getItem("theme")=="dark"?"light":"dark")' title='dark theme'>
</a><a><img src=/icons/search-solid.svg onclick=toggleSearch() title=search></a></div><div class=title>Functions and Recursion</div><div class=right><a onclick=window.print()><img src=/icons/print-solid.svg title=print>
</a><a href=https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2farchitecture%2ffunctions.md><img src=/icons/edit-solid.svg title=edit style=width:18px;position:relative;right:-2px;top:-1px>
</a><a href=https://github.com/algorithmica-org/algorithmica/blob/master//hpc/architecture/functions.md class=github-main><img src=/icons/github-brands.svg title='view on github'></a></div></menu><main><div id=search><input id=search-bar type=search placeholder='Search this book…' oninput=search()><div id=search-count></div><div id=search-results></div></div><header><h1>Functions and Recursion</h1><div class=info></div></header><article><p>To &ldquo;call a function&rdquo; in assembly, you need to <a href=../loops>jump</a> to its beginning and then jump back. But then two important problems arise:</p><ol><li>What if the caller stores data in the same registers as the callee?</li><li>Where is &ldquo;back&rdquo;?</li></ol><p>Both of these concerns can be solved by having a dedicated location in memory where we can write all the information we need to return from the function before calling it. This location is called <em>the stack</em>.</p><span class=anchor id=the-stack></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/architecture/functions/#the-stack>#</a>The Stack</h3><p>The hardware stack works the same way software stacks do and is similarly implemented as just two pointers:</p><ul><li>The <em>base pointer</em> marks the start of the stack and is conventionally stored in <code>rbp</code>.</li><li>The <em>stack pointer</em> marks the last element of the stack and is conventionally stored in <code>rsp</code>.</li></ul><p>When you need to call a function, you push all your local variables onto the stack (which you can also do in other circumstances; e.g., when you run out of registers), push the current instruction pointer, and then jump to the beginning of the function. When exiting from a function, you look at the pointer stored on top of the stack, jump there, and then carefully read all the variables stored on the stack back into their registers.</p><p>You can implement all that with the usual memory operations and jumps, but because of how frequently it is used, there are 4 special instructions for doing this:</p><ul><li><code>push</code> writes data at the stack pointer and decrements it.</li><li><code>pop</code> reads data from the stack pointer and increments it.</li><li><code>call</code> puts the address of the following instruction on top of the stack and jumps to a label.</li><li><code>ret</code> reads the return address from the top of the stack and jumps to it.</li></ul><p>You would call them &ldquo;syntactic sugar&rdquo; if they weren&rsquo;t actual hardware instructions — they are just fused equivalents of these two-instruction snippets:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>; &#34;push rax&#34;</span>
</span></span><span class=line><span class=cl><span class=nf>sub</span> <span class=nb>rsp</span><span class=p>,</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=kt>QWORD</span> <span class=nv>PTR</span><span class=p>[</span><span class=nb>rsp</span><span class=p>],</span> <span class=nb>rax</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; &#34;pop rax&#34;</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span> <span class=nb>rax</span><span class=p>,</span> <span class=kt>QWORD</span> <span class=nv>PTR</span><span class=p>[</span><span class=nb>rsp</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>add</span> <span class=nb>rsp</span><span class=p>,</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; &#34;call func&#34;</span>
</span></span><span class=line><span class=cl><span class=nf>push</span> <span class=nv>rip</span> <span class=c1>; &lt;- instruction pointer (although accessing it like that is probably illegal)</span>
</span></span><span class=line><span class=cl><span class=nf>jmp</span> <span class=nv>func</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>; &#34;ret&#34;</span>
</span></span><span class=line><span class=cl><span class=nf>pop</span>  <span class=nb>rcx</span> <span class=c1>; &lt;- choose any unused register</span>
</span></span><span class=line><span class=cl><span class=nf>jmp</span> <span class=nb>rcx</span>
</span></span></code></pre></div><p>The memory region between <code>rbp</code> and <code>rsp</code> is called a <em>stack frame</em>, and this is where local variables of functions are typically stored. It is pre-allocated at the start of the program, and if you push more data on the stack than its capacity (8MB by default on Linux), you encounter a <em>stack overflow</em> error. Because modern operating systems don&rsquo;t actually give you memory pages until you read or write to their address space, you can freely specify a very large stack size, which acts more like a limit on how much stack memory can be used, and not a fixed amount every program has to use.</p><span class=anchor id=calling-conventions></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/architecture/functions/#calling-conventions>#</a>Calling Conventions</h3><p>The people who develop compilers and operating systems eventually came up with <a href=https://wiki.osdev.org/Calling_Conventions>conventions</a> on how to write and call functions. These conventions enable some important <a href=/hpc/compilation/stages/>software engineering marvels</a> such as splitting compilation into separate units, reusing already-compiled libraries, and even writing them in different programming languages.</p><p>Consider the following example in C:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>square</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>distance</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>square</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=o>+</span> <span class=nf>square</span><span class=p>(</span><span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>By convention, a function should take its arguments in <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> (and the rest in the stack if those weren&rsquo;t enough), put the return value into <code>rax</code>, and then return. Thus, <code>square</code>, being a simple one-argument function, can be implemented like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nl>square:</span>             <span class=c1>; x = edi, ret = eax</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>edi</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>Each time we call it from <code>distance</code>, we just need to go through some trouble preserving its local variables:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nl>distance:</span>           <span class=c1>; x = rdi/edi, y = rsi/esi, ret = rax/eax</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=nv>square</span>     <span class=c1>; eax = square(x)</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span>  <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span>  <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>ebx</span><span class=p>,</span> <span class=nb>eax</span>   <span class=c1>; save x^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>rdi</span><span class=p>,</span> <span class=nb>rsi</span>   <span class=c1>; move new x=y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=nv>square</span>     <span class=c1>; eax = square(x=y)</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span>  <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span>  <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nf>add</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>ebx</span>   <span class=c1>; x^2 + y^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>There are a lot more nuances, but we won&rsquo;t go into detail here because this book is about performance, and the best way to deal with functions calls is actually to avoid making them in the first place.</p><span class=anchor id=inlining></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/architecture/functions/#inlining>#</a>Inlining</h3><p>Moving data to and from the stack creates noticeable overhead for small functions like these. The reason you have to do this is that, in general, you don&rsquo;t know whether the callee is modifying the registers where you store your local variables. But when you have access to the code of <code>square</code>, you can solve this problem by stashing the data in registers that you know won&rsquo;t be modified.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nl>distance:</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=nv>square</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>ebx</span><span class=p>,</span> <span class=nb>eax</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>edi</span><span class=p>,</span> <span class=nb>esi</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=nv>square</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>ebx</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>This is better, but we are still implicitly accessing stack memory: you need to push and pop the instruction pointer on each function call. In simple cases like this, we can <em>inline</em> function calls by stitching the callee&rsquo;s code into the caller and resolving conflicts over registers. In our example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nl>distance:</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>edi</span><span class=p>,</span> <span class=nb>edi</span>       <span class=c1>; edi = x^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>esi</span><span class=p>,</span> <span class=nb>esi</span>       <span class=c1>; esi = y^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>add</span>  <span class=nb>edi</span><span class=p>,</span> <span class=nb>esi</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>       <span class=c1>; there is no &#34;add eax, edi, esi&#34;, so we need a separate mov</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>This is fairly close to what optimizing compilers produce out of this snippet — only they use the <a href=../assembly>lea trick</a> to make the resulting machine code sequence a few bytes smaller:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nl>distance:</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>edi</span><span class=p>,</span> <span class=nb>edi</span>       <span class=c1>; edi = x^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>esi</span><span class=p>,</span> <span class=nb>esi</span>       <span class=c1>; esi = y^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>lea</span>  <span class=nb>eax</span><span class=p>,</span> <span class=p>[</span><span class=nb>rdi</span><span class=o>+</span><span class=nb>rsi</span><span class=p>]</span> <span class=c1>; eax = x^2 + y^2</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>In situations like these, function inlining is clearly beneficial, and compilers mostly do it <a href=/hpc/compilation/situational>automatically</a>, but there are cases when it&rsquo;s not — and we will talk about them <a href=../layout>in a bit</a>.</p><span class=anchor id=tail-call-elimination></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/architecture/functions/#tail-call-elimination>#</a>Tail Call Elimination</h3><p>Inlining is straightforward to do when the callee doesn&rsquo;t make any other function calls, or at least if these calls are not recursive. Let&rsquo;s move on to a more complex example. Consider this recursive computation of a factorial:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>factorial</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span> <span class=o>*</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Equivalent assembly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>; n = edi, ret = eax</span>
</span></span><span class=line><span class=cl><span class=nl>factorial:</span>
</span></span><span class=line><span class=cl>    <span class=nf>test</span> <span class=nb>edi</span><span class=p>,</span> <span class=nb>edi</span>   <span class=c1>; test if a value is zero</span>
</span></span><span class=line><span class=cl>    <span class=nf>jne</span>  <span class=nv>nonzero</span>    <span class=c1>; (the machine code of &#34;cmp rax, 0&#34; would be one byte longer)</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=mi>1</span>     <span class=c1>; return 1</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span><span class=line><span class=cl><span class=nl>nonzero:</span>
</span></span><span class=line><span class=cl>    <span class=nf>push</span> <span class=nb>edi</span>        <span class=c1>; save n to use later in multiplication</span>
</span></span><span class=line><span class=cl>    <span class=nf>sub</span>  <span class=nb>edi</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nf>call</span> <span class=nv>factorial</span>  <span class=c1>; call f(n - 1)</span>
</span></span><span class=line><span class=cl>    <span class=nf>pop</span>  <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>If the function is recursive, it is still often possible to make it &ldquo;call-less&rdquo; by restructuring it. This is the case when the function is <em>tail recursive</em>, that is, it returns right after making a recursive call. Since no actions are required after the call, there is also no need for storing anything on the stack, and a recursive call can be safely replaced with a jump to the beginning — effectively turning the function into a loop.</p><p>To make our <code>factorial</code> function tail-recursive, we can pass a &ldquo;current product&rdquo; argument to it:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>factorial</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>factorial</span><span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>p</span> <span class=o>*</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Then this function can be easily folded into a loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>; assuming n &gt; 0</span>
</span></span><span class=line><span class=cl><span class=nl>factorial:</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nl>loop:</span>
</span></span><span class=line><span class=cl>    <span class=nf>imul</span> <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>sub</span>  <span class=nb>edi</span><span class=p>,</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nf>jne</span>  <span class=nv>loop</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>The primary reason why recursion can be slow is that it needs to read and write data to the stack, while iterative and tail-recursive algorithms do not. This concept is very important in functional programming, where there are no loops and all you can use are functions. Without tail call elimination, functional programs would require way more time and memory to execute.</p></article><div class=nextprev><div class=left><a href=http://jyang772.github.io/hugo-page/hpc/architecture/loops/ id=prev-article>← Loops and Conditionals</a></div><div class=right><a href=http://jyang772.github.io/hugo-page/hpc/architecture/indirect/ id=next-article>Indirect Branching →</a></div></div></main><footer>Copyright 2021–2022 Sergey Slotin<br></footer></div></body></html>