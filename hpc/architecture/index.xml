<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Architecture on Algorithmica</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/</link><description>Recent content in Computer Architecture on Algorithmica</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jyang772.github.io/hugo-page/hpc/architecture/index.xml" rel="self" type="application/rss+xml"/><item><title>Instruction Set Architectures</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/isa/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jyang772.github.io/hugo-page/hpc/architecture/isa/</guid><description>As software engineers, we absolutely love building and using abstractions.
Just imagine how much stuff happens when you load a URL. You type something on a keyboard; key presses are somehow detected by the OS and get sent to the browser; browser parses the URL and asks the OS to make a network request; then comes DNS, routing, TCP, HTTP, and all the other OSI layers; browser parses HTML; JavaScript works its magic; some representation of a page gets sent over to GPU for rendering; image frames get sent to the monitorâ€¦ and each of these steps probably involves doing dozens of more specific things in the process.</description></item><item><title>Assembly Language</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/assembly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jyang772.github.io/hugo-page/hpc/architecture/assembly/</guid><description>CPUs are controlled with machine language, which is just a stream of binary-encoded instructions that specify
the instruction number (called opcode), what its operands are (if there are any), and where to store the result (if one is produced). A much more human-friendly rendition of machine language, called assembly language, uses mnemonic codes to refer to machine code instructions and symbolic names to refer to registers and other storage locations.</description></item><item><title>Loops and Conditionals</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/loops/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jyang772.github.io/hugo-page/hpc/architecture/loops/</guid><description>Let&amp;rsquo;s consider a slightly more complex example:
loop: add edx, DWORD PTR [rax] add rax, 4 cmp rax, rcx jne loop It calculates the sum of a 32-bit integer array, just as a simple for loop would.
The &amp;ldquo;body&amp;rdquo; of the loop is add edx, DWORD PTR [rax]: this instruction loads data from the iterator rax and adds it to the accumulator edx. Next, we move the iterator 4 bytes forward with add rax, 4.</description></item><item><title>Functions and Recursion</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jyang772.github.io/hugo-page/hpc/architecture/functions/</guid><description>To &amp;ldquo;call a function&amp;rdquo; in assembly, you need to jump to its beginning and then jump back. But then two important problems arise:
What if the caller stores data in the same registers as the callee? Where is &amp;ldquo;back&amp;rdquo;? Both of these concerns can be solved by having a dedicated location in memory where we can write all the information we need to return from the function before calling it. This location is called the stack.</description></item><item><title>Indirect Branching</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/indirect/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jyang772.github.io/hugo-page/hpc/architecture/indirect/</guid><description>During assembly, all labels are converted to addresses (absolute or relative) and then encoded into jump instructions.
You can also jump by a non-constant value stored inside a register, which is called a computed jump:
jmp rax This has a few interesting applications related to dynamic languages and implementing more complex control flow.
#Multiway BranchIf you have already forgotten what a switch statement does, here is a little subroutine for calculating GPA in the American grading system:</description></item><item><title>Machine Code Layout</title><link>https://jyang772.github.io/hugo-page/hpc/architecture/layout/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jyang772.github.io/hugo-page/hpc/architecture/layout/</guid><description>Computer engineers like to mentally split the pipeline of a CPU into two parts: the front-end, where instructions are fetched from memory and decoded, and the back-end, where they are scheduled and finally executed. Typically, the performance is bottlenecked by the execution stage, and for this reason, most of our efforts in this book are going to be spent towards optimizing around the back-end.
But sometimes the reverse can happen when the front-end doesn&amp;rsquo;t feed instructions to the back-end fast enough to saturate it.</description></item></channel></rss>