<!doctype html>
<html lang='en-us'><head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WBN59M8Y5S');
</script>


<script type="text/javascript">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(53961409, "init", {
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<meta charset="utf-8">

  
  <link rel="stylesheet" href="/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css" integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8&#43;ZXdZy0=">
  <link rel="stylesheet" href="/syntax.css" id="syntax-theme">

  <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
  <script src="https://tikzjax.com/v1/tikzjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="/scripts/lunr.stemmer.support.min.js"></script>
  <script src="/scripts/lunr.ru.min.js"></script>
  <script src="/scripts/lunr.multi.min.js"></script>

  
  <link rel="stylesheet" id="theme">

  <script>
    function toggleSidebar() {
      console.log("Toggling sidebar visibility")
      var sidebar = document.getElementById('sidebar')
      var wrapper = document.getElementById('wrapper')
      if (sidebar.classList.contains('sidebar-toggled') || window.getComputedStyle(sidebar).display == 'block') { 
        sidebar.classList.toggle('sidebar-hidden')
        wrapper.classList.toggle('sidebar-hidden')
      }
      sidebar.classList.add('sidebar-toggled')
      wrapper.classList.add('sidebar-toggled')
    }

    function switchTheme(theme) {
      console.log("Changing theme:", theme)
      document.getElementById('theme').href = (theme == 'dark' ? "\/hugo-page\/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css" : "")
      document.getElementById('syntax-theme').href = (theme == 'dark' ? '/syntax-dark.css' : '/syntax.css')
      localStorage.setItem('theme', theme)
    }

    async function toggleSearch() {
      console.log("Toggling search")
      
      var searchDiv = document.getElementById('search')
      if (window.getComputedStyle(searchDiv).display == 'none') {
        searchDiv.style.display = 'block'
        window.scrollTo({ top: 0 });
        document.getElementById('search-bar').focus()
      } else {
        searchDiv.style.display = 'none'  
      }

      if (!index) {
        console.log("Fetching index")
        const response = await fetch('/searchindex.json')
        const pages = await response.json()
        index = lunr(function() {
          this.use(lunr.multiLanguage('en', 'ru'))
          this.field('title', {
            boost: 5
          })
          this.field('content', {
            boost: 1
          })
          pages.forEach(function(doc) {
            this.add(doc)
            articles.push(doc)
          }, this)
        })
        console.log("Ready to search")
      }
    }

    var articles = []
    var index = undefined

    function search() {
      var query = document.getElementById('search-bar').value
      var resultsDiv = document.getElementById('search-results')
      var countDiv = document.getElementById('search-count')
      
      if (query == '') {
        resultsDiv.innerHTML = ''
        countDiv.innerHTML = ''
        return
      }
      
      var results = index.search(query)

      countDiv.innerHTML = 'Found <b>' + results.length + '</b> pages'

      let resultList = ''

      for (const n in results) {
        const item = articles[results[n].ref]
        resultList += '<li><a href="' + item.path + '">' + item.title + '</a> <p>'
        const text = item.content

        const contextLimit = 80

        if (text.includes(query)) {
          const start = text.indexOf(query)
          if (start > contextLimit)
            resultList += '…'
          resultList += text.substring(start - contextLimit, start)
                      + '<b>' + query + '</b>' + text.substring(start + query.length, start + query.length + contextLimit)

        } else {
          resultList += text.substring(0, contextLimit * 2)
        }
        resultList += '…</p></li>'
      }

      resultsDiv.innerHTML = resultList
    }

    if (localStorage.getItem('theme') == 'dark') {
      switchTheme('dark')
    }

    window.addEventListener('load', function() {
      var el = document.getElementById("active-element")
      
      if (el) {
        el.scrollIntoView({block: "center"})
      }
      

    })

    window.addEventListener('scroll', function() {
      var menu = document.getElementById('menu')
      if (window.scrollY < 120) {
        
        menu.classList.remove('scrolled')
      } else {
        
        menu.classList.add('scrolled')
      }
    })

    window.addEventListener('keydown', function(e) {
      if (e.altKey) { return }
      if (document.activeElement.tagName == 'INPUT') { return }
      if (e.key == 'ArrowLeft') {
        document.getElementById('prev-article').click()
      } else if (e.key == 'ArrowRight') {
        document.getElementById('next-article').click()
      }
    })
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  })"></script>

  
  <title>Reductions - Algorithmica</title>
</head>
<body><nav id='sidebar' >
  
  
  <div class='title'>
    <a href='/'>Algorithmica</a>
    
      
        
        <span class='slash'>/</span>
        <a href='/hugo-page/hpc/' class='divisionAbbr'
           >
          HPC
        </a>
      
    
  </div>
  <ul>
    
      
        
          <li class='part'>Performance Engineering</li>
        
        <li class=' '><a href='/hugo-page/hpc/complexity/'
          
          >Complexity Models</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/complexity/hardware/'
                
                >Modern Hardware</a></li>
            
              <li ><a href='/hugo-page/hpc/complexity/languages/'
                
                >Programming Languages</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/architecture/'
          
          >Computer Architecture</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/architecture/isa/'
                
                >Instruction Set Architectures</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/assembly/'
                
                >Assembly Language</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/loops/'
                
                >Loops and Conditionals</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/functions/'
                
                >Functions and Recursion</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/indirect/'
                
                >Indirect Branching</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/layout/'
                
                >Machine Code Layout</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/pipelining/'
          
          >Instruction-Level Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/pipelining/hazards/'
                
                >Pipeline Hazards</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/branching/'
                
                >The Cost of Branching</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/branchless/'
                
                >Branchless Programming</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/tables/'
                
                >Instruction Tables</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/throughput/'
                
                >Throughput Computing</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/compilation/'
          
          >Compilation</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/compilation/stages/'
                
                >Stages of Compilation</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/flags/'
                
                >Flags and Targets</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/situational/'
                
                >Situational Optimizations</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/contracts/'
                
                >Contract Programming</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/precalc/'
                
                >Precomputation</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/profiling/'
          
          >Profiling</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/profiling/instrumentation/'
                
                >Instrumentation</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/events/'
                
                >Statistical Profiling</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/simulation/'
                
                >Program Simulation</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/mca/'
                
                >Machine Code Analyzers</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/benchmarking/'
                
                >Benchmarking</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/noise/'
                
                >Getting Accurate Results</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/arithmetic/'
          
          >Arithmetic</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/arithmetic/float/'
                
                >Floating-Point Numbers</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/ieee-754/'
                
                >IEEE 754 Floats</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/errors/'
                
                >Rounding Errors</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/newton/'
                
                >Newton&#39;s Method</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/rsqrt/'
                
                >Fast Inverse Square Root</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/integer/'
                
                >Integer Numbers</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/division/'
                
                >Integer Division</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/number-theory/'
          
          >Number Theory</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/number-theory/modular/'
                
                >Modular Arithmetic</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/exponentiation/'
                
                >Binary Exponentiation</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/euclid-extended/'
                
                >Extended Euclidean Algorithm</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/montgomery/'
                
                >Montgomery Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/external-memory/'
          
          >External Memory</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/external-memory/hierarchy/'
                
                >Memory Hierarchy</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/virtual/'
                
                >Virtual Memory</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/model/'
                
                >External Memory Model</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/sorting/'
                
                >External Sorting</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/list-ranking/'
                
                >List Ranking</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/policies/'
                
                >Eviction Policies</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/oblivious/'
                
                >Cache-Oblivious Algorithms</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/locality/'
                
                >Spatial and Temporal Locality</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/cpu-cache/'
          
          >RAM &amp; CPU Caches</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/bandwidth/'
                
                >Memory Bandwidth</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/latency/'
                
                >Memory Latency</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/cache-lines/'
                
                >Cache Lines</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/sharing/'
                
                >Memory Sharing</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/mlp/'
                
                >Memory-Level Parallelism</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/prefetching/'
                
                >Prefetching</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/alignment/'
                
                >Alignment and Packing</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/pointers/'
                
                >Pointer Alternatives</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/associativity/'
                
                >Cache Associativity</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/paging/'
                
                >Memory Paging</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/aos-soa/'
                
                >AoS and SoA</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/simd/'
          
          >SIMD Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/simd/intrinsics/'
                
                >Intrinsics and Vector Types</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/moving/'
                
                >Moving Data</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/reduction/'
                id='active-element'
                >Reductions</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/masking/'
                
                >Masking and Blending</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/shuffling/'
                
                >In-Register Shuffles</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/auto-vectorization/'
                
                >Auto-Vectorization and SPMD</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/algorithms/'
          
          >Algorithms Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/algorithms/gcd/'
                
                >Binary GCD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/factorization/'
                
                >Integer Factorization</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/argmin/'
                
                >Argmin with SIMD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/prefix/'
                
                >Prefix Sum with SIMD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/matmul/'
                
                >Matrix Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/data-structures/'
          
          >Data Structures Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/data-structures/binary-search/'
                
                >Binary Search</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/s-tree/'
                
                >Static B-Trees</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/b-tree/'
                
                >Search Trees</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/segment-trees/'
                
                >Segment Trees</a></li>
            
          </ol>
        
      
    
  </ul>
</nav>
<div id='wrapper' ><menu id='menu'>
  
  
  <div class='left'>
    <a>
      <img src='/icons/bars-solid.svg'
           onclick='toggleSidebar()'
           title='open table of contents'>
    </a>
    <a>
      <img src='/icons/adjust-solid.svg'
           style='position: relative; top: -1px'
           onclick='switchTheme(localStorage.getItem("theme") == "dark" ? "light" : "dark")'
           title='dark theme'>
    </a>
    <a>
      <img src='/icons/search-solid.svg'
           onclick='toggleSearch()'
           title='search'>
    </a>
  </div>
  <div class='title'>Reductions</div>
  <div class='right'>
    <a onClick='window.print()'>
      <img src='/icons/print-solid.svg' title='print'>
    </a>
    <a href='https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2fsimd%2freduction.md'>
      <img src='/icons/edit-solid.svg'
           title='edit'
           style='width: 18px; position: relative; right: -2px; top: -1px'>
    </a>
    <a href='https://github.com/algorithmica-org/algorithmica/blob/master//hpc/simd/reduction.md' class='github-main'>
      <img src='/icons/github-brands.svg' title='view on github'>
    </a>
  </div>
</menu>
<main>
        <div id="search">
    <input id="search-bar" type="search" placeholder='Search this book…' oninput="search()">
    <div id="search-count"></div>
    <div id="search-results">
    </div>
</div>
<header>
  
  <h1>Reductions</h1>
  
    <div class='info'></div>
  
</header>
<article>
  


  
    
    
      
        <p><em>Reduction</em> (also known as <em>folding</em> in functional programming) is the action of computing the value of some associative and commutative operation (i.e., $(a \circ b) \circ c = a \circ (b \circ c)$ and $a \circ b = b \circ a$) over a range of arbitrary elements.</p>
<p>The simplest example of reduction is calculating the sum an array:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>The naive approach is not so straightforward to vectorize, because the state of the loop (sum $s$ on the current prefix) depends on the previous iteration. The way to overcome this is to split a single scalar accumulator $s$ into 8 separate ones, so that $s_i$ would contain the sum of every 8th element of the original array, shifted by $i$:</p>

      
    
  

  
    $$
    
s_i = \sum_{j=0}^{n / 8} a_{8 \cdot j + i }

    $$
  

  
    
    
      
        <p>If we store these 8 accumulators in a single 256-bit vector, we can update them all at once by adding consecutive 8-element segments of the array. With <a href="../x86-simd">vector extensions</a>, this is straightforward:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum_simd</span><span class="p">(</span><span class="n">v8si</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//       ^ you can just cast a pointer normally, like with any other pointer type
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">v8si</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">// sum 8 accumulators into one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// add the remainder of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">res</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>You can use this approach for other reductions, such as for finding the minimum or the xor-sum of an array.</p>
<span class='anchor' id="instruction-level-parallelism"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/simd/reduction/#instruction-level-parallelism">#</a>Instruction-Level Parallelism</h3><p>Our implementation matches what the compiler produces automatically, but it is actually suboptimal: when we use just one accumulator, <a href="/hpc/pipelining/throughput">we have to wait</a> one cycle between the loop iterations for a vector addition to complete, while the <a href="/hpc/pipelining/tables/">throughput</a> of corresponding instruction is 2 on this microarchitecture.</p>
<p>If we again divide the array in $B \geq 2$ parts and use a <em>separate</em> accumulator for each, we can saturate the throughput of vector addition and increase the performance twofold:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">B</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// how many vector accumulators to use
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sum_simd</span><span class="p">(</span><span class="n">v8si</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">v8si</span> <span class="n">b</span><span class="p">[</span><span class="n">B</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">B</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">B</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sum all vector accumulators into one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">B</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// sum 8 scalar accumulators into one
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">     <span class="c1">// add the remainder of a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">B</span><span class="p">);</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>If you have more than 2 relevant execution ports, you can increase the <code>B</code> constant accordingly, but the $n$-fold performance increase will only apply to arrays that fit into L1 cache — <a href="/hpc/cpu-cache/bandwidth">memory bandwidth</a> will be the bottleneck for anything larger.</p>
<span class='anchor' id="horizontal-summation"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/simd/reduction/#horizontal-summation">#</a>Horizontal Summation</h3><p>The part where we sum up the 8 accumulators stored in a vector register into a single scalar to get the total sum is called &ldquo;horizontal summation.&rdquo;</p>
<p>Although extracting and adding every scalar one by one only takes a constant number of cycles, it can be computed slightly faster using a <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#techs=AVX,AVX2&amp;text=_mm256_hadd_epi32&amp;expand=2941">special instruction</a> that adds together pairs of adjacent elements in a register.</p>
<p><figure>
  <img src="../img/hsum.png">
  <figcaption>Horizontal summation in SSE/AVX. Note how the output is stored: the (a b a b) interleaving is common for reducing operations</figcaption>
</figure>
</p>
<p>Since it is a very specific operation, it can only be done with SIMD intrinsics — although the compiler probably emits roughly the same procedure for the scalar code anyway:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">hsum</span><span class="p">(</span><span class="n">__m256i</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kr">__m128i</span> <span class="n">l</span> <span class="o">=</span> <span class="n">_mm256_extracti128_si256</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kr">__m128i</span> <span class="n">h</span> <span class="o">=</span> <span class="n">_mm256_extracti128_si256</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="n">_mm_add_epi32</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">l</span> <span class="o">=</span> <span class="n">_mm_hadd_epi32</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">_mm_extract_epi32</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>There are <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#techs=AVX,AVX2&amp;ig_expand=3037,3009,5135,4870,4870,4872,4875,833,879,874,849,848,6715,4845&amp;text=horizontal">other similar instructions</a>, e.g., for integer multiplication or calculating absolute differences between adjacent elements (used in image processing).</p>
<p>There is also one specific instruction, <code>_mm_minpos_epu16</code>, that calculates the horizontal minimum and its index among eight 16-bit integers. This is the only horizontal reduction that works in one go: all others are computed in multiple steps.</p>

      
    
  



        </article>
        <div class='nextprev'>
  
    
      
      

      
      
      
        
      
        
      
        
          
        
      
        
      
        
      
        
      

      
        <div class='left'>
        
          <a href='https://jyang772.github.io/hugo-page/hpc/simd/moving/' id='prev-article'>← Moving Data</a>
        
        </div>
        <div class='right'>
        
          <a href='https://jyang772.github.io/hugo-page/hpc/simd/masking/' id='next-article'>Masking and Blending →</a>
        
        </div>
      
    
  
</div>

      </main>
      <footer>
  Copyright 2021–2022 Sergey Slotin
  <br>
   
</footer>

    </div>
  </body>
</html>
