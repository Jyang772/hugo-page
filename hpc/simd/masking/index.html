<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WBN59M8Y5S")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(53961409,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/53961409 style=position:absolute;left:-9999px alt></div></noscript><meta charset=utf-8><link rel=stylesheet href=/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8+ZXdZy0="><link rel=stylesheet href=/syntax.css id=syntax-theme><link rel=stylesheet type=text/css href=https://tikzjax.com/v1/fonts.css><script src=https://tikzjax.com/v1/tikzjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js></script><script src=/scripts/lunr.stemmer.support.min.js></script><script src=/scripts/lunr.ru.min.js></script><script src=/scripts/lunr.multi.min.js></script><link rel=stylesheet id=theme><script>function toggleSidebar(){console.log("Toggling sidebar visibility");var e=document.getElementById("sidebar"),t=document.getElementById("wrapper");(e.classList.contains("sidebar-toggled")||window.getComputedStyle(e).display=="block")&&(e.classList.toggle("sidebar-hidden"),t.classList.toggle("sidebar-hidden")),e.classList.add("sidebar-toggled"),t.classList.add("sidebar-toggled")}function switchTheme(e){console.log("Changing theme:",e),document.getElementById("theme").href=e=="dark"?"/hugo-page/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css":"",document.getElementById("syntax-theme").href=e=="dark"?"/syntax-dark.css":"/syntax.css",localStorage.setItem("theme",e)}async function toggleSearch(){console.log("Toggling search");var e=document.getElementById("search");if(window.getComputedStyle(e).display=="none"?(e.style.display="block",window.scrollTo({top:0}),document.getElementById("search-bar").focus()):e.style.display="none",!index){console.log("Fetching index");const e=await fetch("/hugo-page/searchindex.json"),t=await e.json();index=lunr(function(){this.use(lunr.multiLanguage("en","ru")),this.field("title",{boost:5}),this.field("content",{boost:1}),t.forEach(function(e){this.add(e),articles.push(e)},this)}),console.log("Ready to search")}}var articles=[],index=void 0;function search(){var n,e=document.getElementById("search-bar").value,s=document.getElementById("search-results"),o=document.getElementById("search-count");if(e==""){s.innerHTML="",o.innerHTML="";return}n=index.search(e),o.innerHTML="Found <b>"+n.length+"</b> pages";let t="";for(const a in n){const i=articles[n[a].ref];t+='<li><a href="'+i.path+'">'+i.title+"</a> <p>";const s=i.content,o=80;if(s.includes(e)){const n=s.indexOf(e);n>o&&(t+="…"),t+=s.substring(n-o,n)+"<b>"+e+"</b>"+s.substring(n+e.length,n+e.length+o)}else t+=s.substring(0,o*2);t+="…</p></li>"}s.innerHTML=t}localStorage.getItem("theme")=="dark"&&switchTheme("dark"),window.addEventListener("load",function(){var e=document.getElementById("active-element");e&&e.scrollIntoView({block:"center"})}),window.addEventListener("scroll",function(){var e=document.getElementById("menu");window.scrollY<120?e.classList.remove("scrolled"):e.classList.add("scrolled")}),window.addEventListener("keydown",function(e){if(e.altKey)return;if(document.activeElement.tagName=="INPUT")return;e.key=="ArrowLeft"?document.getElementById("prev-article").click():e.key=="ArrowRight"&&document.getElementById("next-article").click()})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><title>Masking and Blending - Algorithmica</title></head><body><nav id=sidebar><div class=title><a href=/>Algorithmica</a>
<span class=slash>/</span>
<a href=/hugo-page/hpc/ class=divisionAbbr>HPC</a></div><ul><li class=part>Performance Engineering</li><li><a href=/hugo-page/hpc/complexity/>Complexity Models</a></li><ol><li><a href=/hugo-page/hpc/complexity/hardware/>Modern Hardware</a></li><li><a href=/hugo-page/hpc/complexity/languages/>Programming Languages</a></li></ol><li><a href=/hugo-page/hpc/architecture/>Computer Architecture</a></li><ol><li><a href=/hugo-page/hpc/architecture/isa/>Instruction Set Architectures</a></li><li><a href=/hugo-page/hpc/architecture/assembly/>Assembly Language</a></li><li><a href=/hugo-page/hpc/architecture/loops/>Loops and Conditionals</a></li><li><a href=/hugo-page/hpc/architecture/functions/>Functions and Recursion</a></li><li><a href=/hugo-page/hpc/architecture/indirect/>Indirect Branching</a></li><li><a href=/hugo-page/hpc/architecture/layout/>Machine Code Layout</a></li></ol><li><a href=/hugo-page/hpc/pipelining/>Instruction-Level Parallelism</a></li><ol><li><a href=/hugo-page/hpc/pipelining/hazards/>Pipeline Hazards</a></li><li><a href=/hugo-page/hpc/pipelining/branching/>The Cost of Branching</a></li><li><a href=/hugo-page/hpc/pipelining/branchless/>Branchless Programming</a></li><li><a href=/hugo-page/hpc/pipelining/tables/>Instruction Tables</a></li><li><a href=/hugo-page/hpc/pipelining/throughput/>Throughput Computing</a></li></ol><li><a href=/hugo-page/hpc/compilation/>Compilation</a></li><ol><li><a href=/hugo-page/hpc/compilation/stages/>Stages of Compilation</a></li><li><a href=/hugo-page/hpc/compilation/flags/>Flags and Targets</a></li><li><a href=/hugo-page/hpc/compilation/situational/>Situational Optimizations</a></li><li><a href=/hugo-page/hpc/compilation/contracts/>Contract Programming</a></li><li><a href=/hugo-page/hpc/compilation/precalc/>Precomputation</a></li></ol><li><a href=/hugo-page/hpc/profiling/>Profiling</a></li><ol><li><a href=/hugo-page/hpc/profiling/instrumentation/>Instrumentation</a></li><li><a href=/hugo-page/hpc/profiling/events/>Statistical Profiling</a></li><li><a href=/hugo-page/hpc/profiling/simulation/>Program Simulation</a></li><li><a href=/hugo-page/hpc/profiling/mca/>Machine Code Analyzers</a></li><li><a href=/hugo-page/hpc/profiling/benchmarking/>Benchmarking</a></li><li><a href=/hugo-page/hpc/profiling/noise/>Getting Accurate Results</a></li></ol><li><a href=/hugo-page/hpc/arithmetic/>Arithmetic</a></li><ol><li><a href=/hugo-page/hpc/arithmetic/float/>Floating-Point Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/ieee-754/>IEEE 754 Floats</a></li><li><a href=/hugo-page/hpc/arithmetic/errors/>Rounding Errors</a></li><li><a href=/hugo-page/hpc/arithmetic/newton/>Newton's Method</a></li><li><a href=/hugo-page/hpc/arithmetic/rsqrt/>Fast Inverse Square Root</a></li><li><a href=/hugo-page/hpc/arithmetic/integer/>Integer Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/division/>Integer Division</a></li></ol><li><a href=/hugo-page/hpc/number-theory/>Number Theory</a></li><ol><li><a href=/hugo-page/hpc/number-theory/modular/>Modular Arithmetic</a></li><li><a href=/hugo-page/hpc/number-theory/exponentiation/>Binary Exponentiation</a></li><li><a href=/hugo-page/hpc/number-theory/euclid-extended/>Extended Euclidean Algorithm</a></li><li><a href=/hugo-page/hpc/number-theory/montgomery/>Montgomery Multiplication</a></li></ol><li><a href=/hugo-page/hpc/external-memory/>External Memory</a></li><ol><li><a href=/hugo-page/hpc/external-memory/hierarchy/>Memory Hierarchy</a></li><li><a href=/hugo-page/hpc/external-memory/virtual/>Virtual Memory</a></li><li><a href=/hugo-page/hpc/external-memory/model/>External Memory Model</a></li><li><a href=/hugo-page/hpc/external-memory/sorting/>External Sorting</a></li><li><a href=/hugo-page/hpc/external-memory/list-ranking/>List Ranking</a></li><li><a href=/hugo-page/hpc/external-memory/policies/>Eviction Policies</a></li><li><a href=/hugo-page/hpc/external-memory/oblivious/>Cache-Oblivious Algorithms</a></li><li><a href=/hugo-page/hpc/external-memory/locality/>Spatial and Temporal Locality</a></li></ol><li><a href=/hugo-page/hpc/cpu-cache/>RAM & CPU Caches</a></li><ol><li><a href=/hugo-page/hpc/cpu-cache/bandwidth/>Memory Bandwidth</a></li><li><a href=/hugo-page/hpc/cpu-cache/latency/>Memory Latency</a></li><li><a href=/hugo-page/hpc/cpu-cache/cache-lines/>Cache Lines</a></li><li><a href=/hugo-page/hpc/cpu-cache/sharing/>Memory Sharing</a></li><li><a href=/hugo-page/hpc/cpu-cache/mlp/>Memory-Level Parallelism</a></li><li><a href=/hugo-page/hpc/cpu-cache/prefetching/>Prefetching</a></li><li><a href=/hugo-page/hpc/cpu-cache/alignment/>Alignment and Packing</a></li><li><a href=/hugo-page/hpc/cpu-cache/pointers/>Pointer Alternatives</a></li><li><a href=/hugo-page/hpc/cpu-cache/associativity/>Cache Associativity</a></li><li><a href=/hugo-page/hpc/cpu-cache/paging/>Memory Paging</a></li><li><a href=/hugo-page/hpc/cpu-cache/aos-soa/>AoS and SoA</a></li></ol><li><a href=/hugo-page/hpc/simd/>SIMD Parallelism</a></li><ol><li><a href=/hugo-page/hpc/simd/intrinsics/>Intrinsics and Vector Types</a></li><li><a href=/hugo-page/hpc/simd/moving/>Moving Data</a></li><li><a href=/hugo-page/hpc/simd/reduction/>Reductions</a></li><li><a href=/hugo-page/hpc/simd/masking/ id=active-element>Masking and Blending</a></li><li><a href=/hugo-page/hpc/simd/shuffling/>In-Register Shuffles</a></li><li><a href=/hugo-page/hpc/simd/auto-vectorization/>Auto-Vectorization and SPMD</a></li></ol><li><a href=/hugo-page/hpc/algorithms/>Algorithms Case Studies</a></li><ol><li><a href=/hugo-page/hpc/algorithms/gcd/>Binary GCD</a></li><li><a href=/hugo-page/hpc/algorithms/factorization/>Integer Factorization</a></li><li><a href=/hugo-page/hpc/algorithms/argmin/>Argmin with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/prefix/>Prefix Sum with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/matmul/>Matrix Multiplication</a></li></ol><li><a href=/hugo-page/hpc/data-structures/>Data Structures Case Studies</a></li><ol><li><a href=/hugo-page/hpc/data-structures/binary-search/>Binary Search</a></li><li><a href=/hugo-page/hpc/data-structures/s-tree/>Static B-Trees</a></li><li><a href=/hugo-page/hpc/data-structures/b-tree/>Search Trees</a></li><li><a href=/hugo-page/hpc/data-structures/segment-trees/>Segment Trees</a></li></ol></ul></nav><div id=wrapper><menu id=menu><div class=left><a><img src=/icons/bars-solid.svg onclick=toggleSidebar() title='open table of contents'>
</a><a><img src=/icons/adjust-solid.svg style=position:relative;top:-1px onclick='switchTheme(localStorage.getItem("theme")=="dark"?"light":"dark")' title='dark theme'>
</a><a><img src=/icons/search-solid.svg onclick=toggleSearch() title=search></a></div><div class=title>Masking and Blending</div><div class=right><a onclick=window.print()><img src=/icons/print-solid.svg title=print>
</a><a href=https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2fsimd%2fmasking.md><img src=/icons/edit-solid.svg title=edit style=width:18px;position:relative;right:-2px;top:-1px>
</a><a href=https://github.com/algorithmica-org/algorithmica/blob/master//hpc/simd/masking.md class=github-main><img src=/icons/github-brands.svg title='view on github'></a></div></menu><main><div id=search><input id=search-bar type=search placeholder='Search this book…' oninput=search()><div id=search-count></div><div id=search-results></div></div><header><h1>Masking and Blending</h1><div class=info></div></header><article><p>One of the bigger challenges of SIMD programming is that its options for control flow are very limited — because the operations you apply to a vector are the same for all its elements.</p><p>This makes the problems that are usually trivially resolved with an <code>if</code> or any other type of branching much harder. With SIMD, they have to be dealt with by the means of various <a href=/hpc/pipelining/branchless>branchless programming</a> techniques, which aren&rsquo;t always that straightforward to apply.</p><span class=anchor id=masking></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/simd/masking/#masking>#</a>Masking</h3><p>The main way to make a computation branchless is through <em>predication</em> — computing the results of both branches and then using either some arithmetic trick or a special &ldquo;conditional move&rdquo; instruction:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>rand</span><span class=p>()</span> <span class=o>%</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>s</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// branch:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>50</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>+=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// no branch:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>+=</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>50</span><span class=p>)</span> <span class=o>*</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// also no branch:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>+=</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>50</span> <span class=o>?</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><p>To vectorize this loop, we are going to need two new instructions:</p><ul><li><code>_mm256_cmpgt_epi32</code>, which compares the integers in two vectors and produces a mask of all ones if the first element is more than the second and a mask of full zeros otherwise.</li><li><code>_mm256_blendv_epi8</code>, which blends (combines) the values of two vectors based on the provided mask.</li></ul><p>By masking and blending the elements of a vector so that only the selected subset of them is affected by computation, we can perform predication in a manner similar to the conditional move:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>c</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=mi>49</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>z</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>_mm256_cmpgt_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_blendv_epi8</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>z</span><span class=p>,</span> <span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>(Minor details such as <a href=../reduction>horizontal summation and accounting for the remainder of the array</a> are omitted for brevity.)</p><p>This is how predication is usually done in SIMD, but it isn&rsquo;t always the most optimal approach. We can use the fact that one of the blended values is zero, and use bitwise <code>and</code> with the mask instead of blending:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>c</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=mi>50</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>_mm256_cmpgt_epi32</span><span class=p>(</span><span class=n>c</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_and_si256</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This loop performs slightly faster because on this particular CPU, the vector <code>and</code> takes one cycle less than <code>blend</code>.</p><p>Several other instructions support masks as inputs, most notably:</p><ul><li>The <code>_mm256_blend_epi32</code> intrinsic is a <code>blend</code> that takes an 8-bit integer mask instead of a vector (which is why it doesn&rsquo;t have <code>v</code> at the end).</li><li>The <code>_mm256_maskload_epi32</code> and <code>_mm256_maskstore_epi32</code> intrinsics that load/store a SIMD block from memory and <code>and</code> it with a mask in one go.</li></ul><p>We can also use predication with built-in vector types:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vec</span> <span class=o>*</span><span class=n>v</span> <span class=o>=</span> <span class=p>(</span><span class=n>vec</span><span class=o>*</span><span class=p>)</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vec</span> <span class=n>s</span> <span class=o>=</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span> <span class=o>/</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span> <span class=o>+=</span> <span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=mi>50</span> <span class=o>?</span> <span class=n>v</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>:</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><p>All these versions work at around 13 GFLOPS as this example is so simple that the compiler can vectorize the loop all by itself. Let&rsquo;s move on to more complex examples that can&rsquo;t be auto-vectorized.</p><span class=anchor id=searching></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/simd/masking/#searching>#</a>Searching</h3><p>In the next example, we need to find a specific value in an array and return its position (aka <code>std::find</code>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To benchmark the <code>find</code> function, we fill the array with numbers from $0$ to $(N - 1)$ and then repeatedly search for a random element:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=n>K</span><span class=p>;</span> <span class=n>t</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>checksum</span> <span class=o>^=</span> <span class=n>find</span><span class=p>(</span><span class=n>rand</span><span class=p>()</span> <span class=o>%</span> <span class=n>N</span><span class=p>);</span>
</span></span></code></pre></div><p>The scalar version gives ~4 GFLOPS of performance. This number includes the elements we haven&rsquo;t had to process, so divide this number by two in your head (the expected fraction of the elements we have to check).</p><p>To vectorize it, we need to compare a vector of its elements with the searched value for equality, producing a mask, and then somehow check if this mask is zero. If it isn&rsquo;t, the needed element is somewhere within this block of 8.</p><p>To check if the mask is zero, we can use the <code>_mm256_movemask_ps</code> intrinsic, which takes the first bit of each 32-bit element in a vector and produces an 8-bit integer mask out of them. We can then check if this mask is non-zero — and if it is, also immediately get the index with the <code>ctz</code> instruction:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>_mm256_movemask_ps</span><span class=p>((</span><span class=n>__m256</span><span class=p>)</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>mask</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>__builtin_ctz</span><span class=p>(</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This version gives ~20 GFLOPS or about 5 times faster than the scalar one. It only uses 3 instructions in the hot loop:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>vpcmpeqd</span>  <span class=nv>ymm0</span><span class=p>,</span> <span class=nv>ymm1</span><span class=p>,</span> <span class=nv>YMMWORD</span> <span class=nv>PTR</span> <span class=nv>a</span><span class=p>[</span><span class=mi>0</span><span class=o>+</span><span class=nb>rdx</span><span class=o>*</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>vmovmskps</span> <span class=nb>eax</span><span class=p>,</span> <span class=nv>ymm0</span>
</span></span><span class=line><span class=cl><span class=nf>test</span>      <span class=nb>eax</span><span class=p>,</span> <span class=nb>eax</span>
</span></span><span class=line><span class=cl><span class=nf>je</span>        <span class=nv>loop</span>
</span></span></code></pre></div><p>Checking if a vector is zero is a common operation, and there is an operation similar to <code>test</code> in SIMD that we can use:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>_mm256_testz_si256</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>m</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>_mm256_movemask_ps</span><span class=p>((</span><span class=n>__m256</span><span class=p>)</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>__builtin_ctz</span><span class=p>(</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We are still using <code>movemask</code> to do <code>ctz</code> later, but the hot loop is now one instruction shorter:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>vpcmpeqd</span> <span class=nv>ymm0</span><span class=p>,</span> <span class=nv>ymm1</span><span class=p>,</span> <span class=nv>YMMWORD</span> <span class=nv>PTR</span> <span class=nv>a</span><span class=p>[</span><span class=mi>0</span><span class=o>+</span><span class=nb>rdx</span><span class=o>*</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>vptest</span>   <span class=nv>ymm0</span><span class=p>,</span> <span class=nv>ymm0</span>
</span></span><span class=line><span class=cl><span class=nf>je</span>       <span class=nv>loop</span>
</span></span></code></pre></div><p>This doesn&rsquo;t improve performance much because both both <code>vptest</code> and <code>vmovmskps</code> have a throughput of one and will bottleneck the computation regardless of anything else we do in the loop.</p><p>To work around this limitation, we can iterate in blocks of 16 elements and combine the results of independent comparisons of two 256-bit AVX2 registers using a bitwise <code>or</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>16</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y1</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y2</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m1</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m2</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_or_si256</span><span class=p>(</span><span class=n>m1</span><span class=p>,</span> <span class=n>m2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>_mm256_testz_si256</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>m</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>_mm256_movemask_ps</span><span class=p>((</span><span class=n>__m256</span><span class=p>)</span> <span class=n>m2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                     <span class=o>+</span>  <span class=n>_mm256_movemask_ps</span><span class=p>((</span><span class=n>__m256</span><span class=p>)</span> <span class=n>m1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>__builtin_ctz</span><span class=p>(</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With this obstacle removed, the performance now peaks at ~34 GFLOPS. But why not 40? Shouldn&rsquo;t it be twice as fast?</p><p>Here is how one iteration of the loop looks in assembly:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>vpcmpeqd</span> <span class=nv>ymm2</span><span class=p>,</span> <span class=nv>ymm1</span><span class=p>,</span> <span class=nv>YMMWORD</span> <span class=nv>PTR</span> <span class=nv>a</span><span class=p>[</span><span class=mi>0</span><span class=o>+</span><span class=nb>rdx</span><span class=o>*</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>vpcmpeqd</span> <span class=nv>ymm3</span><span class=p>,</span> <span class=nv>ymm1</span><span class=p>,</span> <span class=nv>YMMWORD</span> <span class=nv>PTR</span> <span class=nv>a</span><span class=p>[</span><span class=mi>32</span><span class=o>+</span><span class=nb>rdx</span><span class=o>*</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nf>vpor</span>     <span class=nv>ymm0</span><span class=p>,</span> <span class=nv>ymm3</span><span class=p>,</span> <span class=nv>ymm2</span>
</span></span><span class=line><span class=cl><span class=nf>vptest</span>   <span class=nv>ymm0</span><span class=p>,</span> <span class=nv>ymm0</span>
</span></span><span class=line><span class=cl><span class=nf>je</span>       <span class=nv>loop</span>
</span></span></code></pre></div><p>Every iteration, we need to execute 5 instructions. While the throughputs of all relevant execution ports allow to do that in one cycle on average, we can&rsquo;t do that because the decode width of this particular CPU (Zen 2) is 4. Therefore, the performance is limited by ⅘ of what it could have been.</p><p>To mitigate this, we can once again double the number of SIMD blocks we process on each iteration:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>unsigned</span> <span class=nf>get_mask</span><span class=p>(</span><span class=n>reg</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_mm256_movemask_ps</span><span class=p>((</span><span class=n>__m256</span><span class=p>)</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>reg</span> <span class=nf>cmp</span><span class=p>(</span><span class=n>reg</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>y</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=n>p</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>find</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m1</span> <span class=o>=</span> <span class=n>cmp</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m2</span> <span class=o>=</span> <span class=n>cmp</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m3</span> <span class=o>=</span> <span class=n>cmp</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>16</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m4</span> <span class=o>=</span> <span class=n>cmp</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>24</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m12</span> <span class=o>=</span> <span class=n>_mm256_or_si256</span><span class=p>(</span><span class=n>m1</span><span class=p>,</span> <span class=n>m2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m34</span> <span class=o>=</span> <span class=n>_mm256_or_si256</span><span class=p>(</span><span class=n>m3</span><span class=p>,</span> <span class=n>m4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_or_si256</span><span class=p>(</span><span class=n>m12</span><span class=p>,</span> <span class=n>m34</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>_mm256_testz_si256</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>m</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>unsigned</span> <span class=n>mask</span> <span class=o>=</span> <span class=p>(</span><span class=n>get_mask</span><span class=p>(</span><span class=n>m4</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>24</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                          <span class=o>+</span> <span class=p>(</span><span class=n>get_mask</span><span class=p>(</span><span class=n>m3</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                          <span class=o>+</span> <span class=p>(</span><span class=n>get_mask</span><span class=p>(</span><span class=n>m2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                          <span class=o>+</span>  <span class=n>get_mask</span><span class=p>(</span><span class=n>m1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>__builtin_ctz</span><span class=p>(</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It now shows the throughput of 43 GFLOPS — or about 10x faster than the original scalar implementation.</p><p>Extending it to 64 values per cycle doesn&rsquo;t help: small arrays suffer from the overhead of all these additional <code>movemask</code>-s when we hit the condition, and larger arrays are bottlenecked by <a href=/hpc/cpu-cache/bandwidth>memory bandwidth</a> anyway.</p><span class=anchor id=counting-values></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/simd/masking/#counting-values>#</a>Counting Values</h3><p>As the final exercise, let&rsquo;s find the count of a value in an array instead of just its first occurrence:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>count</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>+=</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To vectorize it, we just need to convert the comparison mask to either one or zero per element and calculate the sum:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>ones</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>count</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_and_si256</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>ones</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>hsum</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Both implementations yield ~15 GFLOPS: the compiler can vectorize the first one all by itself.</p><p>But a trick that the compiler can&rsquo;t find is to notice that the mask of all ones is <a href=/hpc/arithmetic/integer>minus one</a> when reinterpreted as an integer. So we can skip the and-the-lowest-bit part and use the mask itself, and then just negate the final result:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>count</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=n>hsum</span><span class=p>(</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This doesn&rsquo;t improve the performance in this particular architecture because the throughput is actually bottlenecked by updating <code>s</code>: there is a dependency on the previous iteration, so the loop can&rsquo;t proceed faster than one iteration per CPU cycle. We can make use of <a href=../reduction#instruction-level-parallelism>instruction-level parallelism</a> if we split the accumulator in two:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>count</span><span class=p>(</span><span class=kt>int</span> <span class=n>needle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>needle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>s1</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>s2</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>16</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y1</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>y2</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>8</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m1</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m2</span> <span class=o>=</span> <span class=n>_mm256_cmpeq_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>s1</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=n>m1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>s2</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s2</span><span class=p>,</span> <span class=n>m2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>s1</span> <span class=o>=</span> <span class=n>_mm256_add_epi32</span><span class=p>(</span><span class=n>s1</span><span class=p>,</span> <span class=n>s2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=n>hsum</span><span class=p>(</span><span class=n>s1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It now gives ~22 GFLOPS of performance, which is as high as it can get.</p><p>When adapting this code for shorter data types, keep in mind that the accumulator may overflow. To work around this, add another accumulator of larger size and regularly stop the loop to add the values in the local accumulator to it and then reset the local accumulator. For example, for 8-bit integers, this means creating another inner loop that does $\lfloor \frac{256-1}{8} \rfloor = 15$ iterations.</p></article><div class=nextprev><div class=left><a href=http://jyang772.github.io/hugo-page/hpc/simd/reduction/ id=prev-article>← Reductions</a></div><div class=right><a href=http://jyang772.github.io/hugo-page/hpc/simd/shuffling/ id=next-article>In-Register Shuffles →</a></div></div></main><footer>Copyright 2021–2022 Sergey Slotin<br></footer></div></body></html>