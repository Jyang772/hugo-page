<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Compilation on Algorithmica</title>
    <link>https://jyang772.github.io/hugo-page/hpc/compilation/</link>
    <description>Recent content in Compilation on Algorithmica</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://jyang772.github.io/hugo-page/hpc/compilation/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Stages of Compilation</title>
      <link>https://jyang772.github.io/hugo-page/hpc/compilation/stages/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jyang772.github.io/hugo-page/hpc/compilation/stages/</guid>
      <description>Before jumping straight to compiler optimizations, which is what most of this chapter is about, let&amp;rsquo;s briefly recap the &amp;ldquo;big picture&amp;rdquo; first. Skipping the boring parts, there are 4 stages of turning C programs into executables:&#xA;Preprocessing expands macros, pulls included source from header files, and strips off comments from source code: gcc -E source.c (outputs preprocessed source to stdout) Compiling parses the source, checks for syntax errors, converts it into an intermediate representation, performs optimizations, and finally translates it into assembly language: gcc -S file.</description>
    </item>
    <item>
      <title>Flags and Targets</title>
      <link>https://jyang772.github.io/hugo-page/hpc/compilation/flags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jyang772.github.io/hugo-page/hpc/compilation/flags/</guid>
      <description>The first step of getting high performance from the compiler is to ask for it, which is done with over a hundred different compiler options, attributes, and pragmas.&#xA;#Optimization LevelsThere are 4 and a half main levels of optimization for speed in GCC:&#xA;-O0 is the default one that does no optimizations (although, in a sense, it does optimize: for compilation time). -O1 (also aliased as -O) does a few &amp;ldquo;low-hanging fruit&amp;rdquo; optimizations, almost not affecting the compilation time.</description>
    </item>
    <item>
      <title>Situational Optimizations</title>
      <link>https://jyang772.github.io/hugo-page/hpc/compilation/situational/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jyang772.github.io/hugo-page/hpc/compilation/situational/</guid>
      <description>Most compiler optimizations enabled by -O2 and -O3 are guaranteed to either improve or at least not seriously hurt performance. Those that aren&amp;rsquo;t included in -O3 are either not strictly standard-compliant, or highly circumstantial and require some additional input from the programmer to help decide whether using them is beneficial.&#xA;Let&amp;rsquo;s discuss the most frequently used ones that we&amp;rsquo;ve also previously covered in this book.&#xA;#Loop UnrollingLoop unrolling is disabled by default, unless the loop takes a small constant number of iterations known at compile time â€” in which case it will be replaced with a completely jump-free, repeated sequence of instructions.</description>
    </item>
    <item>
      <title>Contract Programming</title>
      <link>https://jyang772.github.io/hugo-page/hpc/compilation/contracts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jyang772.github.io/hugo-page/hpc/compilation/contracts/</guid>
      <description>In &amp;ldquo;safe&amp;rdquo; languages like Java and Rust, you normally have well-defined behavior for every possible operation and every possible input. There are some things that are under-defined, like the order of keys in a hash table or the growth factor of an std::vector, but these are usually some minor details that are left up to implementation for potential performance gains in the future.&#xA;In contrast, C and C++ take the concept of undefined behavior to another level.</description>
    </item>
    <item>
      <title>Precomputation</title>
      <link>https://jyang772.github.io/hugo-page/hpc/compilation/precalc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://jyang772.github.io/hugo-page/hpc/compilation/precalc/</guid>
      <description>When compilers can infer that a certain variable does not depend on any user-provided data, they can compute its value during compile time and turn it into a constant by embedding it into the generated machine code.&#xA;This optimization helps performance a lot, but it is not a part of the C++ standard, so compilers don&amp;rsquo;t have to do that. When a compile-time computation is either hard to implement or time-intensive, a compiler may pass on that opportunity.</description>
    </item>
  </channel>
</rss>
