<!doctype html>
<html lang='en-us'><head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WBN59M8Y5S');
</script>


<script type="text/javascript">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(53961409, "init", {
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<meta charset="utf-8">

  
  <link rel="stylesheet" href="/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css" integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8&#43;ZXdZy0=">
  <link rel="stylesheet" href="/syntax.css" id="syntax-theme">

  <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
  <script src="https://tikzjax.com/v1/tikzjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="/scripts/lunr.stemmer.support.min.js"></script>
  <script src="/scripts/lunr.ru.min.js"></script>
  <script src="/scripts/lunr.multi.min.js"></script>

  
  <link rel="stylesheet" id="theme">

  <script>
    function toggleSidebar() {
      console.log("Toggling sidebar visibility")
      var sidebar = document.getElementById('sidebar')
      var wrapper = document.getElementById('wrapper')
      if (sidebar.classList.contains('sidebar-toggled') || window.getComputedStyle(sidebar).display == 'block') { 
        sidebar.classList.toggle('sidebar-hidden')
        wrapper.classList.toggle('sidebar-hidden')
      }
      sidebar.classList.add('sidebar-toggled')
      wrapper.classList.add('sidebar-toggled')
    }

    function switchTheme(theme) {
      console.log("Changing theme:", theme)
      document.getElementById('theme').href = (theme == 'dark' ? "\/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css" : "")
      document.getElementById('syntax-theme').href = (theme == 'dark' ? '/syntax-dark.css' : '/syntax.css')
      localStorage.setItem('theme', theme)
    }

    async function toggleSearch() {
      console.log("Toggling search")
      
      var searchDiv = document.getElementById('search')
      if (window.getComputedStyle(searchDiv).display == 'none') {
        searchDiv.style.display = 'block'
        window.scrollTo({ top: 0 });
        document.getElementById('search-bar').focus()
      } else {
        searchDiv.style.display = 'none'  
      }

      if (!index) {
        console.log("Fetching index")
        const response = await fetch('/searchindex.json')
        const pages = await response.json()
        index = lunr(function() {
          this.use(lunr.multiLanguage('en', 'ru'))
          this.field('title', {
            boost: 5
          })
          this.field('content', {
            boost: 1
          })
          pages.forEach(function(doc) {
            this.add(doc)
            articles.push(doc)
          }, this)
        })
        console.log("Ready to search")
      }
    }

    var articles = []
    var index = undefined

    function search() {
      var query = document.getElementById('search-bar').value
      var resultsDiv = document.getElementById('search-results')
      var countDiv = document.getElementById('search-count')
      
      if (query == '') {
        resultsDiv.innerHTML = ''
        countDiv.innerHTML = ''
        return
      }
      
      var results = index.search(query)

      countDiv.innerHTML = 'Found <b>' + results.length + '</b> pages'

      let resultList = ''

      for (const n in results) {
        const item = articles[results[n].ref]
        resultList += '<li><a href="' + item.path + '">' + item.title + '</a> <p>'
        const text = item.content

        const contextLimit = 80

        if (text.includes(query)) {
          const start = text.indexOf(query)
          if (start > contextLimit)
            resultList += '…'
          resultList += text.substring(start - contextLimit, start)
                      + '<b>' + query + '</b>' + text.substring(start + query.length, start + query.length + contextLimit)

        } else {
          resultList += text.substring(0, contextLimit * 2)
        }
        resultList += '…</p></li>'
      }

      resultsDiv.innerHTML = resultList
    }

    if (localStorage.getItem('theme') == 'dark') {
      switchTheme('dark')
    }

    window.addEventListener('load', function() {
      var el = document.getElementById("active-element")
      
      if (el) {
        el.scrollIntoView({block: "center"})
      }
      

    })

    window.addEventListener('scroll', function() {
      var menu = document.getElementById('menu')
      if (window.scrollY < 120) {
        
        menu.classList.remove('scrolled')
      } else {
        
        menu.classList.add('scrolled')
      }
    })

    window.addEventListener('keydown', function(e) {
      if (e.altKey) { return }
      if (document.activeElement.tagName == 'INPUT') { return }
      if (e.key == 'ArrowLeft') {
        document.getElementById('prev-article').click()
      } else if (e.key == 'ArrowRight') {
        document.getElementById('next-article').click()
      }
    })
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  })"></script>

  
  <title>Branchless Programming - Algorithmica</title>
</head>
<body><nav id='sidebar' >
  
  
  <div class='title'>
    <a href='/'>Algorithmica</a>
    
      
        
        <span class='slash'>/</span>
        <a href='/hpc/' class='divisionAbbr'
           >
          HPC
        </a>
      
    
  </div>
  <ul>
    
      
        
          <li class='part'>Performance Engineering</li>
        
        <li class=' '><a href='/hpc/complexity/'
          
          >Complexity Models</a></li>
        
          <ol>
            
              <li ><a href='/hpc/complexity/hardware/'
                
                >Modern Hardware</a></li>
            
              <li ><a href='/hpc/complexity/languages/'
                
                >Programming Languages</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/architecture/'
          
          >Computer Architecture</a></li>
        
          <ol>
            
              <li ><a href='/hpc/architecture/isa/'
                
                >Instruction Set Architectures</a></li>
            
              <li ><a href='/hpc/architecture/assembly/'
                
                >Assembly Language</a></li>
            
              <li ><a href='/hpc/architecture/loops/'
                
                >Loops and Conditionals</a></li>
            
              <li ><a href='/hpc/architecture/functions/'
                
                >Functions and Recursion</a></li>
            
              <li ><a href='/hpc/architecture/indirect/'
                
                >Indirect Branching</a></li>
            
              <li ><a href='/hpc/architecture/layout/'
                
                >Machine Code Layout</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/pipelining/'
          
          >Instruction-Level Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hpc/pipelining/hazards/'
                
                >Pipeline Hazards</a></li>
            
              <li ><a href='/hpc/pipelining/branching/'
                
                >The Cost of Branching</a></li>
            
              <li ><a href='/hpc/pipelining/branchless/'
                id='active-element'
                >Branchless Programming</a></li>
            
              <li ><a href='/hpc/pipelining/tables/'
                
                >Instruction Tables</a></li>
            
              <li ><a href='/hpc/pipelining/throughput/'
                
                >Throughput Computing</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/compilation/'
          
          >Compilation</a></li>
        
          <ol>
            
              <li ><a href='/hpc/compilation/stages/'
                
                >Stages of Compilation</a></li>
            
              <li ><a href='/hpc/compilation/flags/'
                
                >Flags and Targets</a></li>
            
              <li ><a href='/hpc/compilation/situational/'
                
                >Situational Optimizations</a></li>
            
              <li ><a href='/hpc/compilation/contracts/'
                
                >Contract Programming</a></li>
            
              <li ><a href='/hpc/compilation/precalc/'
                
                >Precomputation</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/profiling/'
          
          >Profiling</a></li>
        
          <ol>
            
              <li ><a href='/hpc/profiling/instrumentation/'
                
                >Instrumentation</a></li>
            
              <li ><a href='/hpc/profiling/events/'
                
                >Statistical Profiling</a></li>
            
              <li ><a href='/hpc/profiling/simulation/'
                
                >Program Simulation</a></li>
            
              <li ><a href='/hpc/profiling/mca/'
                
                >Machine Code Analyzers</a></li>
            
              <li ><a href='/hpc/profiling/benchmarking/'
                
                >Benchmarking</a></li>
            
              <li ><a href='/hpc/profiling/noise/'
                
                >Getting Accurate Results</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/arithmetic/'
          
          >Arithmetic</a></li>
        
          <ol>
            
              <li ><a href='/hpc/arithmetic/float/'
                
                >Floating-Point Numbers</a></li>
            
              <li ><a href='/hpc/arithmetic/ieee-754/'
                
                >IEEE 754 Floats</a></li>
            
              <li ><a href='/hpc/arithmetic/errors/'
                
                >Rounding Errors</a></li>
            
              <li ><a href='/hpc/arithmetic/newton/'
                
                >Newton&#39;s Method</a></li>
            
              <li ><a href='/hpc/arithmetic/rsqrt/'
                
                >Fast Inverse Square Root</a></li>
            
              <li ><a href='/hpc/arithmetic/integer/'
                
                >Integer Numbers</a></li>
            
              <li ><a href='/hpc/arithmetic/division/'
                
                >Integer Division</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/number-theory/'
          
          >Number Theory</a></li>
        
          <ol>
            
              <li ><a href='/hpc/number-theory/modular/'
                
                >Modular Arithmetic</a></li>
            
              <li ><a href='/hpc/number-theory/exponentiation/'
                
                >Binary Exponentiation</a></li>
            
              <li ><a href='/hpc/number-theory/euclid-extended/'
                
                >Extended Euclidean Algorithm</a></li>
            
              <li ><a href='/hpc/number-theory/montgomery/'
                
                >Montgomery Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/external-memory/'
          
          >External Memory</a></li>
        
          <ol>
            
              <li ><a href='/hpc/external-memory/hierarchy/'
                
                >Memory Hierarchy</a></li>
            
              <li ><a href='/hpc/external-memory/virtual/'
                
                >Virtual Memory</a></li>
            
              <li ><a href='/hpc/external-memory/model/'
                
                >External Memory Model</a></li>
            
              <li ><a href='/hpc/external-memory/sorting/'
                
                >External Sorting</a></li>
            
              <li ><a href='/hpc/external-memory/list-ranking/'
                
                >List Ranking</a></li>
            
              <li ><a href='/hpc/external-memory/policies/'
                
                >Eviction Policies</a></li>
            
              <li ><a href='/hpc/external-memory/oblivious/'
                
                >Cache-Oblivious Algorithms</a></li>
            
              <li ><a href='/hpc/external-memory/locality/'
                
                >Spatial and Temporal Locality</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/cpu-cache/'
          
          >RAM &amp; CPU Caches</a></li>
        
          <ol>
            
              <li ><a href='/hpc/cpu-cache/bandwidth/'
                
                >Memory Bandwidth</a></li>
            
              <li ><a href='/hpc/cpu-cache/latency/'
                
                >Memory Latency</a></li>
            
              <li ><a href='/hpc/cpu-cache/cache-lines/'
                
                >Cache Lines</a></li>
            
              <li ><a href='/hpc/cpu-cache/sharing/'
                
                >Memory Sharing</a></li>
            
              <li ><a href='/hpc/cpu-cache/mlp/'
                
                >Memory-Level Parallelism</a></li>
            
              <li ><a href='/hpc/cpu-cache/prefetching/'
                
                >Prefetching</a></li>
            
              <li ><a href='/hpc/cpu-cache/alignment/'
                
                >Alignment and Packing</a></li>
            
              <li ><a href='/hpc/cpu-cache/pointers/'
                
                >Pointer Alternatives</a></li>
            
              <li ><a href='/hpc/cpu-cache/associativity/'
                
                >Cache Associativity</a></li>
            
              <li ><a href='/hpc/cpu-cache/paging/'
                
                >Memory Paging</a></li>
            
              <li ><a href='/hpc/cpu-cache/aos-soa/'
                
                >AoS and SoA</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/simd/'
          
          >SIMD Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hpc/simd/intrinsics/'
                
                >Intrinsics and Vector Types</a></li>
            
              <li ><a href='/hpc/simd/moving/'
                
                >Moving Data</a></li>
            
              <li ><a href='/hpc/simd/reduction/'
                
                >Reductions</a></li>
            
              <li ><a href='/hpc/simd/masking/'
                
                >Masking and Blending</a></li>
            
              <li ><a href='/hpc/simd/shuffling/'
                
                >In-Register Shuffles</a></li>
            
              <li ><a href='/hpc/simd/auto-vectorization/'
                
                >Auto-Vectorization and SPMD</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/algorithms/'
          
          >Algorithms Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hpc/algorithms/gcd/'
                
                >Binary GCD</a></li>
            
              <li ><a href='/hpc/algorithms/factorization/'
                
                >Integer Factorization</a></li>
            
              <li ><a href='/hpc/algorithms/argmin/'
                
                >Argmin with SIMD</a></li>
            
              <li ><a href='/hpc/algorithms/prefix/'
                
                >Prefix Sum with SIMD</a></li>
            
              <li ><a href='/hpc/algorithms/matmul/'
                
                >Matrix Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/data-structures/'
          
          >Data Structures Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hpc/data-structures/binary-search/'
                
                >Binary Search</a></li>
            
              <li ><a href='/hpc/data-structures/s-tree/'
                
                >Static B-Trees</a></li>
            
              <li ><a href='/hpc/data-structures/b-tree/'
                
                >Search Trees</a></li>
            
              <li ><a href='/hpc/data-structures/segment-trees/'
                
                >Segment Trees</a></li>
            
          </ol>
        
      
    
  </ul>
</nav>
<div id='wrapper' ><menu id='menu'>
  
  
  <div class='left'>
    <a>
      <img src='/icons/bars-solid.svg'
           onclick='toggleSidebar()'
           title='open table of contents'>
    </a>
    <a>
      <img src='/icons/adjust-solid.svg'
           style='position: relative; top: -1px'
           onclick='switchTheme(localStorage.getItem("theme") == "dark" ? "light" : "dark")'
           title='dark theme'>
    </a>
    <a>
      <img src='/icons/search-solid.svg'
           onclick='toggleSearch()'
           title='search'>
    </a>
  </div>
  <div class='title'>Branchless Programming</div>
  <div class='right'>
    <a onClick='window.print()'>
      <img src='/icons/print-solid.svg' title='print'>
    </a>
    <a href='https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2fpipelining%2fbranchless.md'>
      <img src='/icons/edit-solid.svg'
           title='edit'
           style='width: 18px; position: relative; right: -2px; top: -1px'>
    </a>
    <a href='https://github.com/algorithmica-org/algorithmica/blob/master//hpc/pipelining/branchless.md' class='github-main'>
      <img src='/icons/github-brands.svg' title='view on github'>
    </a>
  </div>
</menu>
<main>
        <div id="search">
    <input id="search-bar" type="search" placeholder='Search this book…' oninput="search()">
    <div id="search-count"></div>
    <div id="search-results">
    </div>
</div>
<header>
  
  <h1>Branchless Programming</h1>
  
    <div class='info'></div>
  
</header>
<article>
  


  
    
    
      
        <p>As we established in <a href="../branching">the previous section</a>, branches that can&rsquo;t be effectively predicted by the CPU are expensive as they may cause a long pipeline stall to fetch new instructions after a branch mispredict. In this section, we discuss the means of removing branches in the first place.</p>
<span class='anchor' id="predication"></span>
<h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/pipelining/branchless/#predication">#</a>Predication</h3><p>We are going to continue the same case study we&rsquo;ve started before — we create an array of random numbers and sum up all its elements below 50:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="mi">100</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span></code></pre></div><p>Our goal is to eliminate the branch caused by the <code>if</code> statement. We can try to get rid of it like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span></code></pre></div><p>The loop now takes ~7 cycles per element instead of the original ~14. Also, the performance remains constant if we change <code>50</code> to some other threshold, so it doesn&rsquo;t depend on the branch probability.</p>
<p>But wait… shouldn&rsquo;t there still be a branch? How does <code>(a[i] &lt; 50)</code> map to assembly?</p>
<p>There are no Boolean types in assembly, nor any instructions that yield either one or zero based on the result of the comparison, but we can compute it indirectly like this: <code>(a[i] - 50) &gt;&gt; 31</code>. This trick relies on the <a href="/hpc/arithmetic/integer">binary representation of integers</a>, specifically on the fact that if the expression <code>a[i] - 50</code> is negative (implying <code>a[i] &lt; 50</code>), then the highest bit of the result will be set to one, which we can then extract using a right-shift.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>   <span class="c1">; t = x</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">50</span>    <span class="c1">; t -= 50</span>
</span></span><span class="line"><span class="cl"><span class="nf">sar</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">31</span>    <span class="c1">; t &gt;&gt;= 31</span>
</span></span><span class="line"><span class="cl"><span class="nf">imul</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>   <span class="c1">; x *= t</span>
</span></span></code></pre></div><p>Another, more complicated way to implement this whole sequence is to convert this sign bit into a mask and then use bitwise <code>and</code> instead of multiplication: <code>((a[i] - 50) &gt;&gt; 31 - 1) &amp; a[i]</code>. This makes the whole sequence one cycle faster, considering that, unlike other instructions, <code>imul</code> takes 3 cycles:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="nb">eax</span>   <span class="c1">; t = x</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">50</span>    <span class="c1">; t -= 50</span>
</span></span><span class="line"><span class="cl"><span class="nf">sar</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">31</span>    <span class="c1">; t &gt;&gt;= 31</span>
</span></span><span class="line"><span class="cl"><span class="c1">; imul  eax, ebx ; x *= t</span>
</span></span><span class="line"><span class="cl"><span class="nf">sub</span>  <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>     <span class="c1">; t -= 1 (causing underflow if t = 0)</span>
</span></span><span class="line"><span class="cl"><span class="nf">and</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>   <span class="c1">; x &amp;= t</span>
</span></span></code></pre></div><p>Note that this optimization is not technically correct from the compiler&rsquo;s perspective: for the 50 lowest representable integers — those in the $[-2^{31}, - 2^{31} + 49]$ range — the result will be wrong due to underflow. We know that all numbers are all between 0 and 100, and this won&rsquo;t happen, but the compiler doesn&rsquo;t.</p>
<p>But the compiler actually elects to do something different. Instead of going with this arithmetic trick, it used a special <code>cmov</code> (&ldquo;conditional move&rdquo;) instruction that assigns a value based on a condition (which is computed and checked using the flags register, the same way as for jumps):</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="mi">0</span>      <span class="c1">; cmov doesn&#39;t support immediate values, so we need a zero register</span>
</span></span><span class="line"><span class="cl"><span class="nf">cmp</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl"><span class="nf">cmovge</span>  <span class="nb">eax</span><span class="p">,</span> <span class="nb">ebx</span>    <span class="c1">; eax = (eax &gt;= 50 ? eax : ebx=0)</span>
</span></span></code></pre></div><p>So the code above is actually closer to using a ternary operator like this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">?</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</span></span></code></pre></div><p>Both variants are optimized by the compiler and produce the following assembly:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="nb">eax</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="nb">ecx</span><span class="p">,</span> <span class="o">-</span><span class="mi">4000000</span>
</span></span><span class="line"><span class="cl"><span class="nl">loop:</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span>     <span class="nb">esi</span><span class="p">,</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rdx</span> <span class="o">+</span> <span class="nv">a</span> <span class="o">+</span> <span class="mi">4000000</span><span class="p">]</span>  <span class="c1">; load a[i]</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cmp</span>     <span class="nb">esi</span><span class="p">,</span> <span class="mi">50</span>
</span></span><span class="line"><span class="cl">    <span class="nf">cmovge</span>  <span class="nb">esi</span><span class="p">,</span> <span class="nb">eax</span>                            <span class="c1">; esi = (esi &gt;= 50 ? esi : eax=0)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>     <span class="kt">dword</span> <span class="nv">ptr</span> <span class="p">[</span><span class="nb">rsp</span> <span class="o">+</span> <span class="mi">12</span><span class="p">],</span> <span class="nb">esi</span>           <span class="c1">; s += esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span>     <span class="nb">rdx</span><span class="p">,</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">jnz</span>     <span class="nv">loop</span>                                <span class="c1">; &#34;iterate while rdx is not zero&#34;</span>
</span></span></code></pre></div><p>This general technique is called <em>predication</em>, and it is roughly equivalent to this algebraic trick:</p>

      
    
  

  
    $$
    
x = c \cdot a + (1 - c) \cdot b

    $$
  

  
    
    
      
        <p>This way you can eliminate branching, but this comes at the cost of evaluating <em>both</em> branches and the <code>cmov</code> itself. Because evaluating the &ldquo;&gt;=&rdquo; branch costs nothing, the performance is exactly equal to <a href="../branching/#branch-prediction">the &ldquo;always yes&rdquo; case</a> in the branchy version.</p>
<span class='anchor' id="when-predication-is-beneficial"></span>
<h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/pipelining/branchless/#when-predication-is-beneficial">#</a>When Predication Is Beneficial</h3><p>Using predication eliminates <a href="../hazards">a control hazard</a> but introduces a data hazard. There is still a pipeline stall, but it is a cheaper one: you only need to wait for <code>cmov</code> to be resolved and not flush the entire pipeline in case of a mispredict.</p>
<p>However, there are many situations when it is more efficient to leave branchy code as it is. This is the case when the cost of computing <em>both</em> branches instead of just <em>one</em> outweighs the penalty for the potential branch mispredictions.</p>
<p>In our example, the branchy code wins when the branch can be predicted with a probability of more than ~75%.</p>
<p><figure>
  <img src="../img/branchy-vs-branchless.svg">
  <figcaption></figcaption>
</figure>
</p>
<p>This 75% threshold is commonly used by the compilers as a heuristic for determining whether to use the <code>cmov</code> or not. Unfortunately, this probability is usually unknown at the compile time, so it needs to be provided in one of several ways:</p>
<ul>
<li>We can use <a href="/hpc/compilation/situational/#profile-guided-optimization">profile-guided optimization</a> which will decide for itself whether to use predication or not.</li>
<li>We can use <a href="../branching#hinting-likeliness-of-branches">likeliness attributes</a> and <a href="/hpc/compilation/situational">compiler-specific intrinsics</a> to hint at the likeliness of branches: <code>__builtin_expect_with_probability</code> in GCC and <code>__builtin_unpredictable</code> in Clang.</li>
<li>We can rewrite branchy code using the ternary operator or various arithmetic tricks, which acts as sort of an implicit contract between programmers and compilers: if the programmer wrote the code this way, then it was probably meant to be branchless.</li>
</ul>
<p>The &ldquo;right way&rdquo; is to use branching hints, but unfortunately, the support for them is lacking. Right now <a href="https://bugs.llvm.org/show_bug.cgi?id=40027">these hints seem to be lost</a> by the time the compiler back-end decides whether a <code>cmov</code> is more beneficial. There is <a href="https://discourse.llvm.org/t/rfc-cmov-vs-branch-optimization/6040">some progress</a> towards making it possible, but currently, there is no good way of forcing the compiler to generate branch-free code, so sometimes the best hope is to just write a small snippet in assembly.</p>
<!--

Because this is very architecture-specific.

in the absence of branch likeliness hints

While any program that uses a ternary operator is equivalent to a program that uses an `if` statement

The codes seem equivalent. My guess is that the compiler doesn't know that `s + a[i]` does not cause integer overflow.

(The compiler can't optimize it because it's technically [not allowed to](/hpc/compilation/contracts): despite `y - x` being valid, `x - y` could over/underflow, causing undefined behavior. Although fully correct, I guess the compiler just doesn't date executing it.)

Branchless computing tricks like this one are especially important in all sorts of parallel algorithms.

The `cmov` variant doesn't care about probabilities of branches. It only wins if the branch probability if 75% chance, which usually is the heuristic threshold set in compilers.

This is a legal optimization, but I guess an implicit contract has evolved between application programmers and compiler engineers that if you write a ternary operator, then you kind of telling that it is likely going to be an unpredictable branch.

The general technique is called *branchless* or *branch-free* programming. Predication is the main tool of it, but there are more complicated ways.

-->
<!--

Let's do a few more examples as an exercise.

```c++
int max(int a, int b) {
    return (a > b) * a + (a <= b) * b;
}
```

```c++
int max(int a, int b) {
    return (a > b ? a : b);
}
```


```c++
int abs(int a, int b) {
    return max(diff, -diff);
}
```

```c++
int abs(int a, int b) {
    int diff = a - b;
    return (diff < 0 ? -diff : diff);
}
```

```c++
int abs(int a) {
    return (a > 0 ? a : -a);
}
```

```c++
int abs(int a) {
    int mask = a >> 31;
    a ^= mask;
    a -= mask;
    return a;
}
```

-->
<span class='anchor' id="larger-examples"></span>
<h3><a class="anchor-link" href="https://en.algorithmica.org/hpc/pipelining/branchless/#larger-examples">#</a>Larger Examples</h3><p><strong>Strings.</strong> Oversimplifying things, an <code>std::string</code> is comprised of a pointer to a null-terminated <code>char</code> array (also known as a &ldquo;C-string&rdquo;) allocated somewhere on the heap and one integer containing the string size.</p>
<p>A common value for a string is the empty string — which is also its default value. You also need to handle them somehow, and the idiomatic approach is to assign <code>nullptr</code> as the pointer and <code>0</code> as the string size, and then check if the pointer is null or if the size is zero at the beginning of every procedure involving strings.</p>
<p>However, this requires a separate branch, which is costly (unless the majority of strings are either empty or non-empty). To remove the check and thus also the branch, we can allocate a &ldquo;zero C-string,&rdquo; which is just a zero byte allocated somewhere, and then simply point all empty strings there. Now all string operations with empty strings have to read this useless zero byte, but this is still much cheaper than a branch misprediction.</p>
<p><strong>Binary search.</strong> The standard binary search <a href="/hpc/data-structures/binary-search">can be implemented</a> without branches, and on small arrays (that fit into cache) it works ~4x faster than the branchy <code>std::lower_bound</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="o">*</span><span class="n">base</span> <span class="o">=</span> <span class="n">t</span><span class="p">,</span> <span class="n">len</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">half</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">base</span> <span class="o">+=</span> <span class="p">(</span><span class="n">base</span><span class="p">[</span><span class="n">half</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">half</span><span class="p">;</span> <span class="c1">// will be replaced with a &#34;cmov&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">len</span> <span class="o">-=</span> <span class="n">half</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">*</span><span class="n">base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Other than being more complex, it has another slight drawback in that it potentially does more comparisons (constant $\lceil \log_2 n \rceil$ instead of either $\lfloor \log_2 n \rfloor$ or $\lceil \log_2 n \rceil$) and can&rsquo;t speculate on future memory reads (which acts as prefetching, so it loses on very large arrays).</p>
<p>In general, data structures are made branchless by implicitly or explicitly <em>padding</em> them so that their operations take a constant number of iterations. Refer to <a href="/hpc/data-structures/binary-search">the article</a> for more complex examples.</p>
<!--

The only downside of the branchless implementation is that it potentially does more memory reads: 

There are typically two ways to achieve this:

And in general, data structures can be "padded" to be made constant size or height.

That there are no substantial reasons why compilers can't do this on their own, but unfortunately this is just how it is right now.

-->
<p><strong>Data-parallel programming.</strong> Branchless programming is very important for <a href="/hpc/simd">SIMD</a> applications because they don&rsquo;t have branching in the first place.</p>
<p>In our array sum example, removing the <code>volatile</code> type qualifier from the accumulator allows the compiler to <a href="/hpc/simd/auto-vectorization">vectorize</a> the loop:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="cm">/* volatile */</span> <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">50</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="n">s</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span></code></pre></div><p>It now works in ~0.3 per element, which is mainly <a href="/hpc/cpu-cache/bandwidth">bottlenecked by the memory</a>.</p>
<p>The compiler is usually able to vectorize any loop that doesn&rsquo;t have branches or dependencies between the iterations — and some specific small deviations from that, such as <a href="/hpc/simd/reduction">reductions</a> or simple loops that contain just one if-without-else. Vectorization of anything more complex is a very nontrivial problem, which may involve various techniques such as <a href="/hpc/simd/masking">masking</a> and <a href="/hpc/simd/shuffling">in-register permutations</a>.</p>
<!--

**Binary exponentiation.** However, when it is constant

When we can iterate in small batches, [autovectorization](/hpc/simd/autovectorization) speeds it up 13x.

-->

      
    
  



        </article>
        <div class='nextprev'>
  
    
      
      

      
      
      
        
      
        
      
        
          
        
      
        
      
        
      

      
        <div class='left'>
        
          <a href='https://en.algorithmica.org/hpc/pipelining/branching/' id='prev-article'>← The Cost of Branching</a>
        
        </div>
        <div class='right'>
        
          <a href='https://en.algorithmica.org/hpc/pipelining/tables/' id='next-article'>Instruction Tables →</a>
        
        </div>
      
    
  
</div>

      </main>
      <footer>
  Copyright 2021–2022 Sergey Slotin
  <br>
   
</footer>

    </div>
  </body>
</html>
