<!doctype html>
<html lang='en-us'><head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WBN59M8Y5S');
</script>


<script type="text/javascript">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(53961409, "init", {
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<meta charset="utf-8">

  
  <link rel="stylesheet" href="/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css" integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8&#43;ZXdZy0=">
  <link rel="stylesheet" href="/syntax.css" id="syntax-theme">

  <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
  <script src="https://tikzjax.com/v1/tikzjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="/scripts/lunr.stemmer.support.min.js"></script>
  <script src="/scripts/lunr.ru.min.js"></script>
  <script src="/scripts/lunr.multi.min.js"></script>

  
  <link rel="stylesheet" id="theme">

  <script>
    function toggleSidebar() {
      console.log("Toggling sidebar visibility")
      var sidebar = document.getElementById('sidebar')
      var wrapper = document.getElementById('wrapper')
      if (sidebar.classList.contains('sidebar-toggled') || window.getComputedStyle(sidebar).display == 'block') { 
        sidebar.classList.toggle('sidebar-hidden')
        wrapper.classList.toggle('sidebar-hidden')
      }
      sidebar.classList.add('sidebar-toggled')
      wrapper.classList.add('sidebar-toggled')
    }

    function switchTheme(theme) {
      console.log("Changing theme:", theme)
      document.getElementById('theme').href = (theme == 'dark' ? "\/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css" : "")
      document.getElementById('syntax-theme').href = (theme == 'dark' ? '/syntax-dark.css' : '/syntax.css')
      localStorage.setItem('theme', theme)
    }

    async function toggleSearch() {
      console.log("Toggling search")
      
      var searchDiv = document.getElementById('search')
      if (window.getComputedStyle(searchDiv).display == 'none') {
        searchDiv.style.display = 'block'
        window.scrollTo({ top: 0 });
        document.getElementById('search-bar').focus()
      } else {
        searchDiv.style.display = 'none'  
      }

      if (!index) {
        console.log("Fetching index")
        const response = await fetch('/searchindex.json')
        const pages = await response.json()
        index = lunr(function() {
          this.use(lunr.multiLanguage('en', 'ru'))
          this.field('title', {
            boost: 5
          })
          this.field('content', {
            boost: 1
          })
          pages.forEach(function(doc) {
            this.add(doc)
            articles.push(doc)
          }, this)
        })
        console.log("Ready to search")
      }
    }

    var articles = []
    var index = undefined

    function search() {
      var query = document.getElementById('search-bar').value
      var resultsDiv = document.getElementById('search-results')
      var countDiv = document.getElementById('search-count')
      
      if (query == '') {
        resultsDiv.innerHTML = ''
        countDiv.innerHTML = ''
        return
      }
      
      var results = index.search(query)

      countDiv.innerHTML = 'Found <b>' + results.length + '</b> pages'

      let resultList = ''

      for (const n in results) {
        const item = articles[results[n].ref]
        resultList += '<li><a href="' + item.path + '">' + item.title + '</a> <p>'
        const text = item.content

        const contextLimit = 80

        if (text.includes(query)) {
          const start = text.indexOf(query)
          if (start > contextLimit)
            resultList += '…'
          resultList += text.substring(start - contextLimit, start)
                      + '<b>' + query + '</b>' + text.substring(start + query.length, start + query.length + contextLimit)

        } else {
          resultList += text.substring(0, contextLimit * 2)
        }
        resultList += '…</p></li>'
      }

      resultsDiv.innerHTML = resultList
    }

    if (localStorage.getItem('theme') == 'dark') {
      switchTheme('dark')
    }

    window.addEventListener('load', function() {
      var el = document.getElementById("active-element")
      
      if (el) {
        el.scrollIntoView({block: "center"})
      }
      

    })

    window.addEventListener('scroll', function() {
      var menu = document.getElementById('menu')
      if (window.scrollY < 120) {
        
        menu.classList.remove('scrolled')
      } else {
        
        menu.classList.add('scrolled')
      }
    })

    window.addEventListener('keydown', function(e) {
      if (e.altKey) { return }
      if (document.activeElement.tagName == 'INPUT') { return }
      if (e.key == 'ArrowLeft') {
        document.getElementById('prev-article').click()
      } else if (e.key == 'ArrowRight') {
        document.getElementById('next-article').click()
      }
    })
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  })"></script>

  
  <title>Complexity Models - Algorithmica</title>
</head>
<body><nav id='sidebar' >
  
  
  <div class='title'>
    <a href='/'>Algorithmica</a>
    
      
        
        <span class='slash'>/</span>
        <a href='/hpc/' class='divisionAbbr'
           >
          HPC
        </a>
      
    
  </div>
  <ul>
    
      
        
          <li class='part'>Performance Engineering</li>
        
        <li class=' '><a href='/hpc/complexity/'
          id='active-element'
          >Complexity Models</a></li>
        
          <ol>
            
              <li ><a href='/hpc/complexity/hardware/'
                
                >Modern Hardware</a></li>
            
              <li ><a href='/hpc/complexity/languages/'
                
                >Programming Languages</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/architecture/'
          
          >Computer Architecture</a></li>
        
          <ol>
            
              <li ><a href='/hpc/architecture/isa/'
                
                >Instruction Set Architectures</a></li>
            
              <li ><a href='/hpc/architecture/assembly/'
                
                >Assembly Language</a></li>
            
              <li ><a href='/hpc/architecture/loops/'
                
                >Loops and Conditionals</a></li>
            
              <li ><a href='/hpc/architecture/functions/'
                
                >Functions and Recursion</a></li>
            
              <li ><a href='/hpc/architecture/indirect/'
                
                >Indirect Branching</a></li>
            
              <li ><a href='/hpc/architecture/layout/'
                
                >Machine Code Layout</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/pipelining/'
          
          >Instruction-Level Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hpc/pipelining/hazards/'
                
                >Pipeline Hazards</a></li>
            
              <li ><a href='/hpc/pipelining/branching/'
                
                >The Cost of Branching</a></li>
            
              <li ><a href='/hpc/pipelining/branchless/'
                
                >Branchless Programming</a></li>
            
              <li ><a href='/hpc/pipelining/tables/'
                
                >Instruction Tables</a></li>
            
              <li ><a href='/hpc/pipelining/throughput/'
                
                >Throughput Computing</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/compilation/'
          
          >Compilation</a></li>
        
          <ol>
            
              <li ><a href='/hpc/compilation/stages/'
                
                >Stages of Compilation</a></li>
            
              <li ><a href='/hpc/compilation/flags/'
                
                >Flags and Targets</a></li>
            
              <li ><a href='/hpc/compilation/situational/'
                
                >Situational Optimizations</a></li>
            
              <li ><a href='/hpc/compilation/contracts/'
                
                >Contract Programming</a></li>
            
              <li ><a href='/hpc/compilation/precalc/'
                
                >Precomputation</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/profiling/'
          
          >Profiling</a></li>
        
          <ol>
            
              <li ><a href='/hpc/profiling/instrumentation/'
                
                >Instrumentation</a></li>
            
              <li ><a href='/hpc/profiling/events/'
                
                >Statistical Profiling</a></li>
            
              <li ><a href='/hpc/profiling/simulation/'
                
                >Program Simulation</a></li>
            
              <li ><a href='/hpc/profiling/mca/'
                
                >Machine Code Analyzers</a></li>
            
              <li ><a href='/hpc/profiling/benchmarking/'
                
                >Benchmarking</a></li>
            
              <li ><a href='/hpc/profiling/noise/'
                
                >Getting Accurate Results</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/arithmetic/'
          
          >Arithmetic</a></li>
        
          <ol>
            
              <li ><a href='/hpc/arithmetic/float/'
                
                >Floating-Point Numbers</a></li>
            
              <li ><a href='/hpc/arithmetic/ieee-754/'
                
                >IEEE 754 Floats</a></li>
            
              <li ><a href='/hpc/arithmetic/errors/'
                
                >Rounding Errors</a></li>
            
              <li ><a href='/hpc/arithmetic/newton/'
                
                >Newton&#39;s Method</a></li>
            
              <li ><a href='/hpc/arithmetic/rsqrt/'
                
                >Fast Inverse Square Root</a></li>
            
              <li ><a href='/hpc/arithmetic/integer/'
                
                >Integer Numbers</a></li>
            
              <li ><a href='/hpc/arithmetic/division/'
                
                >Integer Division</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/number-theory/'
          
          >Number Theory</a></li>
        
          <ol>
            
              <li ><a href='/hpc/number-theory/modular/'
                
                >Modular Arithmetic</a></li>
            
              <li ><a href='/hpc/number-theory/exponentiation/'
                
                >Binary Exponentiation</a></li>
            
              <li ><a href='/hpc/number-theory/euclid-extended/'
                
                >Extended Euclidean Algorithm</a></li>
            
              <li ><a href='/hpc/number-theory/montgomery/'
                
                >Montgomery Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/external-memory/'
          
          >External Memory</a></li>
        
          <ol>
            
              <li ><a href='/hpc/external-memory/hierarchy/'
                
                >Memory Hierarchy</a></li>
            
              <li ><a href='/hpc/external-memory/virtual/'
                
                >Virtual Memory</a></li>
            
              <li ><a href='/hpc/external-memory/model/'
                
                >External Memory Model</a></li>
            
              <li ><a href='/hpc/external-memory/sorting/'
                
                >External Sorting</a></li>
            
              <li ><a href='/hpc/external-memory/list-ranking/'
                
                >List Ranking</a></li>
            
              <li ><a href='/hpc/external-memory/policies/'
                
                >Eviction Policies</a></li>
            
              <li ><a href='/hpc/external-memory/oblivious/'
                
                >Cache-Oblivious Algorithms</a></li>
            
              <li ><a href='/hpc/external-memory/locality/'
                
                >Spatial and Temporal Locality</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/cpu-cache/'
          
          >RAM &amp; CPU Caches</a></li>
        
          <ol>
            
              <li ><a href='/hpc/cpu-cache/bandwidth/'
                
                >Memory Bandwidth</a></li>
            
              <li ><a href='/hpc/cpu-cache/latency/'
                
                >Memory Latency</a></li>
            
              <li ><a href='/hpc/cpu-cache/cache-lines/'
                
                >Cache Lines</a></li>
            
              <li ><a href='/hpc/cpu-cache/sharing/'
                
                >Memory Sharing</a></li>
            
              <li ><a href='/hpc/cpu-cache/mlp/'
                
                >Memory-Level Parallelism</a></li>
            
              <li ><a href='/hpc/cpu-cache/prefetching/'
                
                >Prefetching</a></li>
            
              <li ><a href='/hpc/cpu-cache/alignment/'
                
                >Alignment and Packing</a></li>
            
              <li ><a href='/hpc/cpu-cache/pointers/'
                
                >Pointer Alternatives</a></li>
            
              <li ><a href='/hpc/cpu-cache/associativity/'
                
                >Cache Associativity</a></li>
            
              <li ><a href='/hpc/cpu-cache/paging/'
                
                >Memory Paging</a></li>
            
              <li ><a href='/hpc/cpu-cache/aos-soa/'
                
                >AoS and SoA</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/simd/'
          
          >SIMD Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hpc/simd/intrinsics/'
                
                >Intrinsics and Vector Types</a></li>
            
              <li ><a href='/hpc/simd/moving/'
                
                >Moving Data</a></li>
            
              <li ><a href='/hpc/simd/reduction/'
                
                >Reductions</a></li>
            
              <li ><a href='/hpc/simd/masking/'
                
                >Masking and Blending</a></li>
            
              <li ><a href='/hpc/simd/shuffling/'
                
                >In-Register Shuffles</a></li>
            
              <li ><a href='/hpc/simd/auto-vectorization/'
                
                >Auto-Vectorization and SPMD</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/algorithms/'
          
          >Algorithms Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hpc/algorithms/gcd/'
                
                >Binary GCD</a></li>
            
              <li ><a href='/hpc/algorithms/factorization/'
                
                >Integer Factorization</a></li>
            
              <li ><a href='/hpc/algorithms/argmin/'
                
                >Argmin with SIMD</a></li>
            
              <li ><a href='/hpc/algorithms/prefix/'
                
                >Prefix Sum with SIMD</a></li>
            
              <li ><a href='/hpc/algorithms/matmul/'
                
                >Matrix Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hpc/data-structures/'
          
          >Data Structures Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hpc/data-structures/binary-search/'
                
                >Binary Search</a></li>
            
              <li ><a href='/hpc/data-structures/s-tree/'
                
                >Static B-Trees</a></li>
            
              <li ><a href='/hpc/data-structures/b-tree/'
                
                >Search Trees</a></li>
            
              <li ><a href='/hpc/data-structures/segment-trees/'
                
                >Segment Trees</a></li>
            
          </ol>
        
      
    
  </ul>
</nav>
<div id='wrapper' ><menu id='menu'>
  
  
  <div class='left'>
    <a>
      <img src='/icons/bars-solid.svg'
           onclick='toggleSidebar()'
           title='open table of contents'>
    </a>
    <a>
      <img src='/icons/adjust-solid.svg'
           style='position: relative; top: -1px'
           onclick='switchTheme(localStorage.getItem("theme") == "dark" ? "light" : "dark")'
           title='dark theme'>
    </a>
    <a>
      <img src='/icons/search-solid.svg'
           onclick='toggleSearch()'
           title='search'>
    </a>
  </div>
  <div class='title'>Complexity Models</div>
  <div class='right'>
    <a onClick='window.print()'>
      <img src='/icons/print-solid.svg' title='print'>
    </a>
    <a href='https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2fcomplexity%2f_index.md'>
      <img src='/icons/edit-solid.svg'
           title='edit'
           style='width: 18px; position: relative; right: -2px; top: -1px'>
    </a>
    <a href='https://github.com/algorithmica-org/algorithmica/blob/master//hpc/complexity/_index.md' class='github-main'>
      <img src='/icons/github-brands.svg' title='view on github'>
    </a>
  </div>
</menu>
<main>
        <div id="search">
    <input id="search-bar" type="search" placeholder='Search this book…' oninput="search()">
    <div id="search-count"></div>
    <div id="search-results">
    </div>
</div>
<header>
  
  <h1>Complexity Models</h1>
  
    <div class='info'></div>
  
</header>
<article>
  
    
  
  


  
    
    
      
        <p>If you ever opened a computer science textbook, it probably introduced <em>computational complexity</em> somewhere in the very beginning. Simply put, it is the total count of <em>elementary operations</em> (additions, multiplications, reads, writes…) that are executed during a computation, optionally weighted by their <em>costs</em>.</p>
<p>Complexity is an old concept. It was <a href="http://www.cs.albany.edu/~res/comp_complexity_ams_1965.pdf">systematically formulated</a> in the early 1960s, and since then it has been universally used as the cost function for designing algorithms. The reason this model was so quickly adopted is that it was a good approximation of how computers worked at the time.</p>
<h3>Classical Complexity Theory</h3><p>The &ldquo;elementary operations&rdquo; of a CPU are called <em>instructions</em>, and their &ldquo;costs&rdquo; are called <em>latencies</em>. Instructions are stored in <em>memory</em> and executed one by one by the processor, which has some internal <em>state</em> stored in a number of <em>registers</em>. One of these registers is the <em>instruction pointer</em>, which indicates the address of the next instruction to read and execute. Each instruction changes the state of the processor in a certain way (including moving the instruction pointer), possibly modifies the main memory, and takes a different number of <em>CPU cycles</em> to complete before the next one can be started.</p>
<p>To estimate the real running time of a program, you need to sum all latencies for its executed instructions and divide it by the <em>clock frequency</em>, that is, the number of cycles a particular CPU does per second.</p>
<p><figure>
  <img src="img/cpu.png">
  <figcaption></figcaption>
</figure>
</p>
<p>The clock frequency is a volatile and often unknown variable that depends on the CPU model, operating system settings, current microchip temperature, power usage of other components, and quite a few other things. In contrast, instruction latencies are static and even somewhat consistent across different CPUs when expressed in clock cycles, so counting them instead is much more useful for analytical purposes.</p>
<p>For example, the by-definition matrix multiplication algorithm requires the total of $n^2 \cdot (n + n - 1)$ arithmetic operations: specifically, $n^3$ multiplications and $n^2 \cdot (n - 1)$ additions. If we look up the latencies for these instructions (in special documents called <em>instruction tables</em>, like <a href="https://www.agner.org/optimize/instruction_tables.pdf">this one</a>), we can find that, e.g., multiplication takes 3 cycles, while addition takes 1, so we need a total of $3 \cdot n^3 + n^2 \cdot (n - 1) = 4 \cdot n^3 - n^2$ clock cycles for the entire computation (bluntly ignoring everything else that needs to be done to &ldquo;feed&rdquo; these instructions with the right data).</p>
<p>Similar to how the sum of instruction latencies can be used as a clock-independent proxy for total execution time, computational complexity can be used to quantify the intrinsic time requirements of an abstract algorithm, without relying on the choice of a specific computer.</p>
<h3>Asymptotic Complexity</h3><p>The idea to express execution time as a function of input size seems obvious now, but it wasn&rsquo;t so in the 1960s. Back then, <a href="https://en.wikipedia.org/wiki/CDC_1604">typical computers</a> cost millions of dollars, were so large that they required a separate room, and had clock rates measured in kilohertz. They were used for practical tasks at hand, like predicting the weather, sending rockets into space, or figuring out how far a Soviet nuclear missile can fly from the coast of Cuba — all of which are finite-length problems. Engineers of that era were mainly concerned with how to multiply $3 \times 3$ matrices rather than $n \times n$ ones.</p>
<p>What caused the shift was the acquired confidence among computer scientists that computers will continue to become faster — and indeed they have. Over time, people stopped counting execution time, then stopped counting cycles, and then even stopped counting operations exactly, replacing it with an <em>estimate</em> that, on sufficiently large inputs, is only off by no more than a constant factor. With <em>asymptotic complexity</em>, verbose &ldquo;$4 \cdot n^3 - n^2$ operations&rdquo; turns into plain &ldquo;$\Theta(n^3)$,&rdquo; hiding the initial costs of individual operations in the &ldquo;Big O,&rdquo; along with all the other intricacies of the hardware.</p>
<p><figure>
  <img src="img/complexity.jpg">
  <figcaption></figcaption>
</figure>
</p>
<p>The reason we use asymptotic complexity is that it provides simplicity while still being just precise enough to yield useful results about relative algorithm performance on large datasets. Under the promise that computers will eventually become fast enough to handle any <em>sufficiently large</em> input in a reasonable amount of time, asymptotically faster algorithms will always be faster in real-time too, regardless of the hidden constant.</p>
<p>But this promise turned out to be not true — at least not in terms of clock speeds and instruction latencies — and in this chapter, we will try to explain why and how to deal with it.</p>

      
    
  



        </article>
        <div class='nextprev'>
  
    
      
      

      
      
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      
        
      

      
        <div class='left'>
        
        </div>
        <div class='right'>
        
          <a href='https://en.algorithmica.org/hpc/complexity/hardware/' id='next-article'>Modern Hardware →</a><br>
        
        
          <a href='https://en.algorithmica.org/hpc/architecture/'>../Computer Architecture →</a>
        
        </div>
      
    
  
</div>

      </main>
      <footer>
  Copyright 2021–2022 Sergey Slotin
  <br>
   
</footer>

    </div>
  </body>
</html>
