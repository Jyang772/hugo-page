<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WBN59M8Y5S")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(53961409,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/53961409 style=position:absolute;left:-9999px alt></div></noscript><meta charset=utf-8><link rel=stylesheet href=/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8+ZXdZy0="><link rel=stylesheet href=/syntax.css id=syntax-theme><link rel=stylesheet type=text/css href=https://tikzjax.com/v1/fonts.css><script src=https://tikzjax.com/v1/tikzjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js></script><script src=/scripts/lunr.stemmer.support.min.js></script><script src=/scripts/lunr.ru.min.js></script><script src=/scripts/lunr.multi.min.js></script><link rel=stylesheet id=theme><script>function toggleSidebar(){console.log("Toggling sidebar visibility");var e=document.getElementById("sidebar"),t=document.getElementById("wrapper");(e.classList.contains("sidebar-toggled")||window.getComputedStyle(e).display=="block")&&(e.classList.toggle("sidebar-hidden"),t.classList.toggle("sidebar-hidden")),e.classList.add("sidebar-toggled"),t.classList.add("sidebar-toggled")}function switchTheme(e){console.log("Changing theme:",e),document.getElementById("theme").href=e=="dark"?"/hugo-page/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css":"",document.getElementById("syntax-theme").href=e=="dark"?"/syntax-dark.css":"/syntax.css",localStorage.setItem("theme",e)}async function toggleSearch(){console.log("Toggling search");var e=document.getElementById("search");if(window.getComputedStyle(e).display=="none"?(e.style.display="block",window.scrollTo({top:0}),document.getElementById("search-bar").focus()):e.style.display="none",!index){console.log("Fetching index");const e=await fetch("/hugo-page/searchindex.json"),t=await e.json();index=lunr(function(){this.use(lunr.multiLanguage("en","ru")),this.field("title",{boost:5}),this.field("content",{boost:1}),t.forEach(function(e){this.add(e),articles.push(e)},this)}),console.log("Ready to search")}}var articles=[],index=void 0;function search(){var n,e=document.getElementById("search-bar").value,s=document.getElementById("search-results"),o=document.getElementById("search-count");if(e==""){s.innerHTML="",o.innerHTML="";return}n=index.search(e),o.innerHTML="Found <b>"+n.length+"</b> pages";let t="";for(const a in n){const i=articles[n[a].ref];t+='<li><a href="'+i.path+'">'+i.title+"</a> <p>";const s=i.content,o=80;if(s.includes(e)){const n=s.indexOf(e);n>o&&(t+="…"),t+=s.substring(n-o,n)+"<b>"+e+"</b>"+s.substring(n+e.length,n+e.length+o)}else t+=s.substring(0,o*2);t+="…</p></li>"}s.innerHTML=t}localStorage.getItem("theme")=="dark"&&switchTheme("dark"),window.addEventListener("load",function(){var e=document.getElementById("active-element");e&&e.scrollIntoView({block:"center"})}),window.addEventListener("scroll",function(){var e=document.getElementById("menu");window.scrollY<120?e.classList.remove("scrolled"):e.classList.add("scrolled")}),window.addEventListener("keydown",function(e){if(e.altKey)return;if(document.activeElement.tagName=="INPUT")return;e.key=="ArrowLeft"?document.getElementById("prev-article").click():e.key=="ArrowRight"&&document.getElementById("next-article").click()})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><title>Integer Division - Algorithmica</title></head><body><nav id=sidebar><div class=title><a href=/>Algorithmica</a>
<span class=slash>/</span>
<a href=/hugo-page/hpc/ class=divisionAbbr>HPC</a></div><ul><li class=part>Performance Engineering</li><li><a href=/hugo-page/hpc/complexity/>Complexity Models</a></li><ol><li><a href=/hugo-page/hpc/complexity/hardware/>Modern Hardware</a></li><li><a href=/hugo-page/hpc/complexity/languages/>Programming Languages</a></li></ol><li><a href=/hugo-page/hpc/architecture/>Computer Architecture</a></li><ol><li><a href=/hugo-page/hpc/architecture/isa/>Instruction Set Architectures</a></li><li><a href=/hugo-page/hpc/architecture/assembly/>Assembly Language</a></li><li><a href=/hugo-page/hpc/architecture/loops/>Loops and Conditionals</a></li><li><a href=/hugo-page/hpc/architecture/functions/>Functions and Recursion</a></li><li><a href=/hugo-page/hpc/architecture/indirect/>Indirect Branching</a></li><li><a href=/hugo-page/hpc/architecture/layout/>Machine Code Layout</a></li></ol><li><a href=/hugo-page/hpc/pipelining/>Instruction-Level Parallelism</a></li><ol><li><a href=/hugo-page/hpc/pipelining/hazards/>Pipeline Hazards</a></li><li><a href=/hugo-page/hpc/pipelining/branching/>The Cost of Branching</a></li><li><a href=/hugo-page/hpc/pipelining/branchless/>Branchless Programming</a></li><li><a href=/hugo-page/hpc/pipelining/tables/>Instruction Tables</a></li><li><a href=/hugo-page/hpc/pipelining/throughput/>Throughput Computing</a></li></ol><li><a href=/hugo-page/hpc/compilation/>Compilation</a></li><ol><li><a href=/hugo-page/hpc/compilation/stages/>Stages of Compilation</a></li><li><a href=/hugo-page/hpc/compilation/flags/>Flags and Targets</a></li><li><a href=/hugo-page/hpc/compilation/situational/>Situational Optimizations</a></li><li><a href=/hugo-page/hpc/compilation/contracts/>Contract Programming</a></li><li><a href=/hugo-page/hpc/compilation/precalc/>Precomputation</a></li></ol><li><a href=/hugo-page/hpc/profiling/>Profiling</a></li><ol><li><a href=/hugo-page/hpc/profiling/instrumentation/>Instrumentation</a></li><li><a href=/hugo-page/hpc/profiling/events/>Statistical Profiling</a></li><li><a href=/hugo-page/hpc/profiling/simulation/>Program Simulation</a></li><li><a href=/hugo-page/hpc/profiling/mca/>Machine Code Analyzers</a></li><li><a href=/hugo-page/hpc/profiling/benchmarking/>Benchmarking</a></li><li><a href=/hugo-page/hpc/profiling/noise/>Getting Accurate Results</a></li></ol><li><a href=/hugo-page/hpc/arithmetic/>Arithmetic</a></li><ol><li><a href=/hugo-page/hpc/arithmetic/float/>Floating-Point Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/ieee-754/>IEEE 754 Floats</a></li><li><a href=/hugo-page/hpc/arithmetic/errors/>Rounding Errors</a></li><li><a href=/hugo-page/hpc/arithmetic/newton/>Newton's Method</a></li><li><a href=/hugo-page/hpc/arithmetic/rsqrt/>Fast Inverse Square Root</a></li><li><a href=/hugo-page/hpc/arithmetic/integer/>Integer Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/division/ id=active-element>Integer Division</a></li></ol><li><a href=/hugo-page/hpc/number-theory/>Number Theory</a></li><ol><li><a href=/hugo-page/hpc/number-theory/modular/>Modular Arithmetic</a></li><li><a href=/hugo-page/hpc/number-theory/exponentiation/>Binary Exponentiation</a></li><li><a href=/hugo-page/hpc/number-theory/euclid-extended/>Extended Euclidean Algorithm</a></li><li><a href=/hugo-page/hpc/number-theory/montgomery/>Montgomery Multiplication</a></li></ol><li><a href=/hugo-page/hpc/external-memory/>External Memory</a></li><ol><li><a href=/hugo-page/hpc/external-memory/hierarchy/>Memory Hierarchy</a></li><li><a href=/hugo-page/hpc/external-memory/virtual/>Virtual Memory</a></li><li><a href=/hugo-page/hpc/external-memory/model/>External Memory Model</a></li><li><a href=/hugo-page/hpc/external-memory/sorting/>External Sorting</a></li><li><a href=/hugo-page/hpc/external-memory/list-ranking/>List Ranking</a></li><li><a href=/hugo-page/hpc/external-memory/policies/>Eviction Policies</a></li><li><a href=/hugo-page/hpc/external-memory/oblivious/>Cache-Oblivious Algorithms</a></li><li><a href=/hugo-page/hpc/external-memory/locality/>Spatial and Temporal Locality</a></li></ol><li><a href=/hugo-page/hpc/cpu-cache/>RAM & CPU Caches</a></li><ol><li><a href=/hugo-page/hpc/cpu-cache/bandwidth/>Memory Bandwidth</a></li><li><a href=/hugo-page/hpc/cpu-cache/latency/>Memory Latency</a></li><li><a href=/hugo-page/hpc/cpu-cache/cache-lines/>Cache Lines</a></li><li><a href=/hugo-page/hpc/cpu-cache/sharing/>Memory Sharing</a></li><li><a href=/hugo-page/hpc/cpu-cache/mlp/>Memory-Level Parallelism</a></li><li><a href=/hugo-page/hpc/cpu-cache/prefetching/>Prefetching</a></li><li><a href=/hugo-page/hpc/cpu-cache/alignment/>Alignment and Packing</a></li><li><a href=/hugo-page/hpc/cpu-cache/pointers/>Pointer Alternatives</a></li><li><a href=/hugo-page/hpc/cpu-cache/associativity/>Cache Associativity</a></li><li><a href=/hugo-page/hpc/cpu-cache/paging/>Memory Paging</a></li><li><a href=/hugo-page/hpc/cpu-cache/aos-soa/>AoS and SoA</a></li></ol><li><a href=/hugo-page/hpc/simd/>SIMD Parallelism</a></li><ol><li><a href=/hugo-page/hpc/simd/intrinsics/>Intrinsics and Vector Types</a></li><li><a href=/hugo-page/hpc/simd/moving/>Moving Data</a></li><li><a href=/hugo-page/hpc/simd/reduction/>Reductions</a></li><li><a href=/hugo-page/hpc/simd/masking/>Masking and Blending</a></li><li><a href=/hugo-page/hpc/simd/shuffling/>In-Register Shuffles</a></li><li><a href=/hugo-page/hpc/simd/auto-vectorization/>Auto-Vectorization and SPMD</a></li></ol><li><a href=/hugo-page/hpc/algorithms/>Algorithms Case Studies</a></li><ol><li><a href=/hugo-page/hpc/algorithms/gcd/>Binary GCD</a></li><li><a href=/hugo-page/hpc/algorithms/factorization/>Integer Factorization</a></li><li><a href=/hugo-page/hpc/algorithms/argmin/>Argmin with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/prefix/>Prefix Sum with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/matmul/>Matrix Multiplication</a></li></ol><li><a href=/hugo-page/hpc/data-structures/>Data Structures Case Studies</a></li><ol><li><a href=/hugo-page/hpc/data-structures/binary-search/>Binary Search</a></li><li><a href=/hugo-page/hpc/data-structures/s-tree/>Static B-Trees</a></li><li><a href=/hugo-page/hpc/data-structures/b-tree/>Search Trees</a></li><li><a href=/hugo-page/hpc/data-structures/segment-trees/>Segment Trees</a></li></ol></ul></nav><div id=wrapper><menu id=menu><div class=left><a><img src=/icons/bars-solid.svg onclick=toggleSidebar() title='open table of contents'>
</a><a><img src=/icons/adjust-solid.svg style=position:relative;top:-1px onclick='switchTheme(localStorage.getItem("theme")=="dark"?"light":"dark")' title='dark theme'>
</a><a><img src=/icons/search-solid.svg onclick=toggleSearch() title=search></a></div><div class=title>Integer Division</div><div class=right><a onclick=window.print()><img src=/icons/print-solid.svg title=print>
</a><a href=https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2farithmetic%2fdivision.md><img src=/icons/edit-solid.svg title=edit style=width:18px;position:relative;right:-2px;top:-1px>
</a><a href=https://github.com/algorithmica-org/algorithmica/blob/master//hpc/arithmetic/division.md class=github-main><img src=/icons/github-brands.svg title='view on github'></a></div></menu><main><div id=search><input id=search-bar type=search placeholder='Search this book…' oninput=search()><div id=search-count></div><div id=search-results></div></div><header><h1>Integer Division</h1><div class=info></div></header><article><p>Compared to other arithmetic operations, division works very poorly on x86 and computers in general. Both floating-point and integer division is notoriously hard to implement in hardware. The circuitry takes a lot of space in the ALU, the computation has a lot of stages, and as the result, <code>div</code> and its siblings routinely take 10-20 cycles to complete, with latency being slightly less on smaller data type sizes.</p><span class=anchor id=division-and-modulo-in-x86></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/arithmetic/division/#division-and-modulo-in-x86>#</a>Division and Modulo in x86</h3><p>Since nobody wants to duplicate all this mess for a separate modulo operation, the <code>div</code> instruction serves both purposes. To perform a 32-bit integer division, you need to put the dividend <em>specifically</em> in the <code>eax</code> register and call <code>div</code> with the divisor as its sole operand. After this, the quotient will be stored in <code>eax</code> and the remainder will be stored in <code>edx</code>.</p><p>The only caveat is that the dividend actually needs to be stored in <em>two</em> registers, <code>eax</code> and <code>edx</code>: this mechanism enables 64-by-32 or even 128-by-64 division, similar to how <a href=../integer>128-bit multiplication</a> works. When performing the usual 32-by-32 signed division, we need to sign-extend <code>eax</code> to 64 bits and store its higher part in <code>edx</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>div</span><span class=p>(</span><span class=nv>int</span><span class=p>,</span> <span class=nv>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>cdq</span>
</span></span><span class=line><span class=cl>    <span class=nf>idiv</span> <span class=nb>esi</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>For unsigned division, you can just set <code>edx</code> to zero so that it doesn&rsquo;t interfere:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>div</span><span class=p>(</span><span class=nv>unsigned</span><span class=p>,</span> <span class=nv>unsigned</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span>  <span class=nb>edx</span><span class=p>,</span> <span class=nb>edx</span>
</span></span><span class=line><span class=cl>    <span class=nf>div</span>  <span class=nb>esi</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>An in both cases, in addition to the quotient in <code>eax</code>, you can also access the remainder as <code>edx</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>mod</span><span class=p>(</span><span class=nv>unsigned</span><span class=p>,</span> <span class=nv>unsigned</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>edi</span>
</span></span><span class=line><span class=cl>    <span class=nf>xor</span>  <span class=nb>edx</span><span class=p>,</span> <span class=nb>edx</span> 
</span></span><span class=line><span class=cl>    <span class=nf>div</span>  <span class=nb>esi</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>eax</span><span class=p>,</span> <span class=nb>edx</span>
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>You can also divide 128-bit integer (stored in <code>rdx:rax</code>) by a 64-bit integer:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=nf>div</span><span class=p>(</span><span class=nv>u128</span><span class=p>,</span> <span class=nv>u64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1>; a = rdi + rsi, b = rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>rcx</span><span class=p>,</span> <span class=nb>rdx</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>rax</span><span class=p>,</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl>    <span class=nf>mov</span>  <span class=nb>rdx</span><span class=p>,</span> <span class=nb>rsi</span>
</span></span><span class=line><span class=cl>    <span class=nf>div</span>  <span class=nb>edx</span> 
</span></span><span class=line><span class=cl>    <span class=nf>ret</span>
</span></span></code></pre></div><p>The high part of the dividend should be less than the divisor, otherwise an overflow occurs. Because of this constraint, it is <a href=https://danlark.org/2020/06/14/128-bit-division/>hard</a> to get compilers to produce this code by themselves: if you divide a <a href=../integer>128-bit integer type</a> by a 64-bit integer, the compiler will bubble-wrap it with additional checks which may actually be unnecessary.</p><span class=anchor id=division-by-constants></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/arithmetic/division/#division-by-constants>#</a>Division by Constants</h3><p>Integer division is painfully slow, even when fully implemented in hardware, but it can be avoided in certain cases if the divisor is constant. A well-known example is the division by a power of two, which can be replaced by a one-cycle binary shift: the <a href=/hpc/algorithms/gcd>binary GCD algorithm</a> is a delightful showcase of this technique.</p><p>In the general case, there are several clever tricks that replace division with multiplication at the cost of a bit of precomputation. All these tricks are based on the following idea. Consider the task of dividing one floating-point number $x$ by another floating-point number $y$, when $y$ is known in advance. What we can do is to calculate a constant</p>$$
d \approx y^{-1}
$$
and then, during runtime, we will calculate
$$
x / y = x \cdot y^{-1} \approx x \cdot d
$$<p>The result of $\frac{1}{y}$ will be at most $\epsilon$ off, and the multiplication $x \cdot d$ will only add another $\epsilon$ and therefore will be at most $2 \epsilon + \epsilon^2 = O(\epsilon)$ off, which is tolerable for the floating-point case.</p><span class=anchor id=barrett-reduction></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/arithmetic/division/#barrett-reduction>#</a>Barrett Reduction</h3><p>How to generalize this trick for integers? Calculating <code>int d = 1 / y</code> doesn&rsquo;t seem to work, because it will just be zero. The best thing we can do is to express it as</p>$$
d = \frac{m}{2^s}
$$
and then find a &ldquo;magic&rdquo; number $m$ and a binary shift $s$ such that <code>x / y == (x * m) >> s</code> for all <code>x</code> within range.
$$
\lfloor x / y \rfloor
= \lfloor x \cdot y^{-1} \rfloor
= \lfloor x \cdot d \rfloor
= \lfloor x \cdot \frac{m}{2^s} \rfloor
$$<p>It can be shown that such a pair always exists, and compilers actually perform an optimization like that by themselves. Every time they encounter a division by a constant, they replace it with a multiplication and a binary shift. Here is the generated assembly for dividing an <code>unsigned long long</code> by $(10^9 + 7)$:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-nasm data-lang=nasm><span class=line><span class=cl><span class=c1>;  input (rdi): x</span>
</span></span><span class=line><span class=cl><span class=c1>; output (rax): x mod (m=1e9+7)</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>    <span class=nb>rax</span><span class=p>,</span> <span class=nb>rdi</span>
</span></span><span class=line><span class=cl><span class=nf>movabs</span> <span class=nb>rdx</span><span class=p>,</span> <span class=o>-</span><span class=mi>8543223828751151131</span>  <span class=c1>; load magic constant into a register</span>
</span></span><span class=line><span class=cl><span class=nf>mul</span>    <span class=nb>rdx</span>                        <span class=c1>; perform multiplication</span>
</span></span><span class=line><span class=cl><span class=nf>mov</span>    <span class=nb>rax</span><span class=p>,</span> <span class=nb>rdx</span>
</span></span><span class=line><span class=cl><span class=nf>shr</span>    <span class=nb>rax</span><span class=p>,</span> <span class=mi>29</span>                    <span class=c1>; binary shift of the result</span>
</span></span></code></pre></div><p>This technique is called <em>Barrett reduction</em>, and it&rsquo;s called &ldquo;reduction&rdquo; because it is mostly used for modulo operations, which can be replaced with a single division, multiplication and subtraction by the virtue of this formula:</p>$$
r = x - \lfloor x / y \rfloor \cdot y
$$<p>This method requires some precomputation, including performing one actual division. Therefore, this is only beneficial when you perform not just one but a few divisions, all with the same constant divisor.</p><span class=anchor id=why-it-works></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/arithmetic/division/#why-it-works>#</a>Why It Works</h3><p>It is not very clear why such $m$ and $s$ always exist, let alone how to find them. But given a fixed $s$, intuition tells us that $m$ should be as close to $2^s/y$ as possible for $2^s$ to cancel out. So there are two natural choices: $\lfloor 2^s/y \rfloor$ and $\lceil 2^s/y \rceil$. The first one doesn&rsquo;t work, because if you substitute</p>$$
\Bigl \lfloor \frac{x \cdot \lfloor 2^s/y \rfloor}{2^s} \Bigr \rfloor
$$
then for any integer $\frac{x}{y}$ where $y$ is not even, the result will be strictly less than the truth. This only leaves the other case, $m = \lceil 2^s/y \rceil$. Now, let&rsquo;s try to derive the lower and upper bounds for the result of the computation:
$$
\lfloor x / y \rfloor
= \Bigl \lfloor \frac{x \cdot m}{2^s} \Bigr \rfloor
= \Bigl \lfloor \frac{x \cdot \lceil 2^s /y \rceil}{2^s} \Bigr \rfloor
$$
Let&rsquo;s start with the bounds for $m$:
$$
2^s / y
\le
\lceil 2^s / y \rceil
<
2^s / y + 1
$$
And now for the whole expression:
$$
x / y - 1
<
\Bigl \lfloor \frac{x \cdot \lceil 2^s /y \rceil}{2^s} \Bigr \rfloor
<
x / y + x / 2^s
$$<p>We can see that the result falls somewhere in a range of size $(1 + \frac{x}{2^s})$, and if this range always has exactly one integer for all possible $x / y$, then the algorithm is guaranteed to give the right answer. Turns out, we can always set $s$ to be high enough to achieve it.</p><p>What will be the worst case here? How to pick $x$ and $y$ so that the $(x/y - 1, x/y + x / 2^s)$ range contains two integers? We can see that integer ratios don&rsquo;t work because the left border is not included, and assuming $x/2^s &lt; 1$, only $x/y$ itself will be in the range. The worst case is actually the $x/y$ that comes closest to $1$ without exceeding it. For $n$-bit integers, that is the second-largest possible integer divided by the first-largest:</p>$$
\begin{aligned}
x = 2^n - 2
\\ y = 2^n - 1
\end{aligned}
$$<p>In this case, the lower bound will be $(\frac{2^n-2}{2^n-1} - 1)$ and the upper bound will be $(\frac{2^n-2}{2^n-1} + \frac{2^n-2}{2^s})$. The left border is as close to a whole number as possible, and the size of the whole range is the second largest possible. And here is the punchline: if $s \ge n$, then the only integer contained in this range is $1$, and so the algorithm will always return it.</p><span class=anchor id=lemire-reduction></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/arithmetic/division/#lemire-reduction>#</a>Lemire Reduction</h3><p>Barrett reduction is a bit complicated, and also generates a length instruction sequence for modulo because it is computed indirectly. There is a new (<a href=https://arxiv.org/pdf/1902.01961.pdf>2019</a>) method, which is simpler and actually faster for modulo in some cases. It doesn&rsquo;t have a conventional name yet, but I am going to refer to it as <a href=https://lemire.me/blog/>Lemire</a> reduction.</p><p>Here is the main idea. Consider the floating-point representation of some integer fraction:</p>$$
\frac{179}{6} = 11101.1101010101\ldots = 29\tfrac{5}{6} \approx 29.83
$$<p>How can we &ldquo;dissect&rdquo; it to get the parts we need?</p><ul><li>To get the integer part (29), we can just floor or truncate it before the dot.</li><li>To get the fractional part (⅚), we can just take what is after the dots.</li><li>To get the remainder (5), we can multiply the fractional part by the divisor.</li></ul><p>Now, for 32-bit integers, we can set $s = 64$ and look at the computation that we do in the multiply-and-shift scheme:</p>$$
\lfloor x / y \rfloor
= \Bigl \lfloor \frac{x \cdot m}{2^s} \Bigr \rfloor
= \Bigl \lfloor \frac{x \cdot \lceil 2^s /y \rceil}{2^s} \Bigr \rfloor
$$<p>What we really do here is we multiply $x$ by a floating-point constant ($x \cdot m$) and then truncate the result $(\lfloor \frac{\cdot}{2^s} \rfloor)$.</p><p>What if we took not the highest bits but the lowest? This would correspond to the fractional part — and if we multiply it back by $y$ and truncate the result, this will be exactly the remainder:</p>$$
r = \Bigl \lfloor \frac{ (x \cdot \lceil 2^s /y \rceil \bmod 2^s) \cdot y }{2^s} \Bigr \rfloor
$$<p>This works perfectly because what we do here can be interpreted as just three chained floating-point multiplications with the total relative error of $O(\epsilon)$. Since $\epsilon = O(\frac{1}{2^s})$ and $s = 2n$, the error will always be less than one, and hence the result will be exact.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint64_t</span> <span class=n>m</span> <span class=o>=</span> <span class=kt>uint64_t</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>/</span> <span class=n>y</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// ceil(2^64 / y)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>mod</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>uint64_t</span> <span class=n>lowbits</span> <span class=o>=</span> <span class=n>m</span> <span class=o>*</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>((</span><span class=n>__uint128_t</span><span class=p>)</span> <span class=n>lowbits</span> <span class=o>*</span> <span class=n>y</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>uint32_t</span> <span class=nf>div</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>((</span><span class=n>__uint128_t</span><span class=p>)</span> <span class=n>m</span> <span class=o>*</span> <span class=n>x</span><span class=p>)</span> <span class=o>&gt;&gt;</span> <span class=mi>64</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can also check divisibility of $x$ by $y$ with just one multiplication using the fact that the remainder of division is zero if and only if the fractional part (the lower 64 bits of $m \cdot x$) does not exceed $m$ (otherwise, it would become a nonzero number when multiplied back by $y$ and right-shifted by 64).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=nf>is_divisible</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>m</span> <span class=o>*</span> <span class=n>x</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The only downside of this method is that it needs integer types four times the original size to perform the multiplication, while other reduction methods can work with just the double.</p><p>There is also a way to compute 64x64 modulo by carefully manipulating the halves of intermediate results; the implementation is left as an exercise to the reader.</p><span class=anchor id=further-reading></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/arithmetic/division/#further-reading>#</a>Further Reading</h3><p>Check out <a href=https://github.com/ridiculousfish/libdivide>libdivide</a> and <a href=https://gmplib.org/>GMP</a> for more general implementations of optimized integer division.</p><p>It is also worth reading <a href=https://www.amazon.com/Hackers-Delight-2nd-Henry-Warren/dp/0321842685>Hacker&rsquo;s Delight</a>, which has a whole chapter dedicated to integer division.</p></article><div class=nextprev><div class=left><a href=http://jyang772.github.io/hugo-page/hpc/arithmetic/integer/ id=prev-article>← Integer Numbers</a></div><div class=right><a href=http://jyang772.github.io/hugo-page/hpc/number-theory/ id=next-article>../Number Theory →</a></div></div></main><footer>Copyright 2021–2022 Sergey Slotin<br></footer></div></body></html>