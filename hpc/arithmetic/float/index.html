<!doctype html>
<html lang='en-us'><head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WBN59M8Y5S');
</script>


<script type="text/javascript">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(53961409, "init", {
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<meta charset="utf-8">

  
  <link rel="stylesheet" href="/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css" integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8&#43;ZXdZy0=">
  <link rel="stylesheet" href="/syntax.css" id="syntax-theme">

  <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
  <script src="https://tikzjax.com/v1/tikzjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="/scripts/lunr.stemmer.support.min.js"></script>
  <script src="/scripts/lunr.ru.min.js"></script>
  <script src="/scripts/lunr.multi.min.js"></script>

  
  <link rel="stylesheet" id="theme">

  <script>
    function toggleSidebar() {
      console.log("Toggling sidebar visibility")
      var sidebar = document.getElementById('sidebar')
      var wrapper = document.getElementById('wrapper')
      if (sidebar.classList.contains('sidebar-toggled') || window.getComputedStyle(sidebar).display == 'block') { 
        sidebar.classList.toggle('sidebar-hidden')
        wrapper.classList.toggle('sidebar-hidden')
      }
      sidebar.classList.add('sidebar-toggled')
      wrapper.classList.add('sidebar-toggled')
    }

    function switchTheme(theme) {
      console.log("Changing theme:", theme)
      document.getElementById('theme').href = (theme == 'dark' ? "\/hugo-page\/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css" : "")
      document.getElementById('syntax-theme').href = (theme == 'dark' ? '/syntax-dark.css' : '/syntax.css')
      localStorage.setItem('theme', theme)
    }

    async function toggleSearch() {
      console.log("Toggling search")
      
      var searchDiv = document.getElementById('search')
      if (window.getComputedStyle(searchDiv).display == 'none') {
        searchDiv.style.display = 'block'
        window.scrollTo({ top: 0 });
        document.getElementById('search-bar').focus()
      } else {
        searchDiv.style.display = 'none'  
      }

      if (!index) {
        console.log("Fetching index")
        const response = await fetch('/searchindex.json')
        const pages = await response.json()
        index = lunr(function() {
          this.use(lunr.multiLanguage('en', 'ru'))
          this.field('title', {
            boost: 5
          })
          this.field('content', {
            boost: 1
          })
          pages.forEach(function(doc) {
            this.add(doc)
            articles.push(doc)
          }, this)
        })
        console.log("Ready to search")
      }
    }

    var articles = []
    var index = undefined

    function search() {
      var query = document.getElementById('search-bar').value
      var resultsDiv = document.getElementById('search-results')
      var countDiv = document.getElementById('search-count')
      
      if (query == '') {
        resultsDiv.innerHTML = ''
        countDiv.innerHTML = ''
        return
      }
      
      var results = index.search(query)

      countDiv.innerHTML = 'Found <b>' + results.length + '</b> pages'

      let resultList = ''

      for (const n in results) {
        const item = articles[results[n].ref]
        resultList += '<li><a href="' + item.path + '">' + item.title + '</a> <p>'
        const text = item.content

        const contextLimit = 80

        if (text.includes(query)) {
          const start = text.indexOf(query)
          if (start > contextLimit)
            resultList += '…'
          resultList += text.substring(start - contextLimit, start)
                      + '<b>' + query + '</b>' + text.substring(start + query.length, start + query.length + contextLimit)

        } else {
          resultList += text.substring(0, contextLimit * 2)
        }
        resultList += '…</p></li>'
      }

      resultsDiv.innerHTML = resultList
    }

    if (localStorage.getItem('theme') == 'dark') {
      switchTheme('dark')
    }

    window.addEventListener('load', function() {
      var el = document.getElementById("active-element")
      
      if (el) {
        el.scrollIntoView({block: "center"})
      }
      

    })

    window.addEventListener('scroll', function() {
      var menu = document.getElementById('menu')
      if (window.scrollY < 120) {
        
        menu.classList.remove('scrolled')
      } else {
        
        menu.classList.add('scrolled')
      }
    })

    window.addEventListener('keydown', function(e) {
      if (e.altKey) { return }
      if (document.activeElement.tagName == 'INPUT') { return }
      if (e.key == 'ArrowLeft') {
        document.getElementById('prev-article').click()
      } else if (e.key == 'ArrowRight') {
        document.getElementById('next-article').click()
      }
    })
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  })"></script>

  
  <title>Floating-Point Numbers - Algorithmica</title>
</head>
<body><nav id='sidebar' >
  
  
  <div class='title'>
    <a href='/'>Algorithmica</a>
    
      
        
        <span class='slash'>/</span>
        <a href='/hugo-page/hpc/' class='divisionAbbr'
           >
          HPC
        </a>
      
    
  </div>
  <ul>
    
      
        
          <li class='part'>Performance Engineering</li>
        
        <li class=' '><a href='/hugo-page/hpc/complexity/'
          
          >Complexity Models</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/complexity/hardware/'
                
                >Modern Hardware</a></li>
            
              <li ><a href='/hugo-page/hpc/complexity/languages/'
                
                >Programming Languages</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/architecture/'
          
          >Computer Architecture</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/architecture/isa/'
                
                >Instruction Set Architectures</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/assembly/'
                
                >Assembly Language</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/loops/'
                
                >Loops and Conditionals</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/functions/'
                
                >Functions and Recursion</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/indirect/'
                
                >Indirect Branching</a></li>
            
              <li ><a href='/hugo-page/hpc/architecture/layout/'
                
                >Machine Code Layout</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/pipelining/'
          
          >Instruction-Level Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/pipelining/hazards/'
                
                >Pipeline Hazards</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/branching/'
                
                >The Cost of Branching</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/branchless/'
                
                >Branchless Programming</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/tables/'
                
                >Instruction Tables</a></li>
            
              <li ><a href='/hugo-page/hpc/pipelining/throughput/'
                
                >Throughput Computing</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/compilation/'
          
          >Compilation</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/compilation/stages/'
                
                >Stages of Compilation</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/flags/'
                
                >Flags and Targets</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/situational/'
                
                >Situational Optimizations</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/contracts/'
                
                >Contract Programming</a></li>
            
              <li ><a href='/hugo-page/hpc/compilation/precalc/'
                
                >Precomputation</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/profiling/'
          
          >Profiling</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/profiling/instrumentation/'
                
                >Instrumentation</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/events/'
                
                >Statistical Profiling</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/simulation/'
                
                >Program Simulation</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/mca/'
                
                >Machine Code Analyzers</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/benchmarking/'
                
                >Benchmarking</a></li>
            
              <li ><a href='/hugo-page/hpc/profiling/noise/'
                
                >Getting Accurate Results</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/arithmetic/'
          
          >Arithmetic</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/arithmetic/float/'
                id='active-element'
                >Floating-Point Numbers</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/ieee-754/'
                
                >IEEE 754 Floats</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/errors/'
                
                >Rounding Errors</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/newton/'
                
                >Newton&#39;s Method</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/rsqrt/'
                
                >Fast Inverse Square Root</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/integer/'
                
                >Integer Numbers</a></li>
            
              <li ><a href='/hugo-page/hpc/arithmetic/division/'
                
                >Integer Division</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/number-theory/'
          
          >Number Theory</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/number-theory/modular/'
                
                >Modular Arithmetic</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/exponentiation/'
                
                >Binary Exponentiation</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/euclid-extended/'
                
                >Extended Euclidean Algorithm</a></li>
            
              <li ><a href='/hugo-page/hpc/number-theory/montgomery/'
                
                >Montgomery Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/external-memory/'
          
          >External Memory</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/external-memory/hierarchy/'
                
                >Memory Hierarchy</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/virtual/'
                
                >Virtual Memory</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/model/'
                
                >External Memory Model</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/sorting/'
                
                >External Sorting</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/list-ranking/'
                
                >List Ranking</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/policies/'
                
                >Eviction Policies</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/oblivious/'
                
                >Cache-Oblivious Algorithms</a></li>
            
              <li ><a href='/hugo-page/hpc/external-memory/locality/'
                
                >Spatial and Temporal Locality</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/cpu-cache/'
          
          >RAM &amp; CPU Caches</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/bandwidth/'
                
                >Memory Bandwidth</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/latency/'
                
                >Memory Latency</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/cache-lines/'
                
                >Cache Lines</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/sharing/'
                
                >Memory Sharing</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/mlp/'
                
                >Memory-Level Parallelism</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/prefetching/'
                
                >Prefetching</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/alignment/'
                
                >Alignment and Packing</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/pointers/'
                
                >Pointer Alternatives</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/associativity/'
                
                >Cache Associativity</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/paging/'
                
                >Memory Paging</a></li>
            
              <li ><a href='/hugo-page/hpc/cpu-cache/aos-soa/'
                
                >AoS and SoA</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/simd/'
          
          >SIMD Parallelism</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/simd/intrinsics/'
                
                >Intrinsics and Vector Types</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/moving/'
                
                >Moving Data</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/reduction/'
                
                >Reductions</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/masking/'
                
                >Masking and Blending</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/shuffling/'
                
                >In-Register Shuffles</a></li>
            
              <li ><a href='/hugo-page/hpc/simd/auto-vectorization/'
                
                >Auto-Vectorization and SPMD</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/algorithms/'
          
          >Algorithms Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/algorithms/gcd/'
                
                >Binary GCD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/factorization/'
                
                >Integer Factorization</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/argmin/'
                
                >Argmin with SIMD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/prefix/'
                
                >Prefix Sum with SIMD</a></li>
            
              <li ><a href='/hugo-page/hpc/algorithms/matmul/'
                
                >Matrix Multiplication</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/hugo-page/hpc/data-structures/'
          
          >Data Structures Case Studies</a></li>
        
          <ol>
            
              <li ><a href='/hugo-page/hpc/data-structures/binary-search/'
                
                >Binary Search</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/s-tree/'
                
                >Static B-Trees</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/b-tree/'
                
                >Search Trees</a></li>
            
              <li ><a href='/hugo-page/hpc/data-structures/segment-trees/'
                
                >Segment Trees</a></li>
            
          </ol>
        
      
    
  </ul>
</nav>
<div id='wrapper' ><menu id='menu'>
  
  
  <div class='left'>
    <a>
      <img src='/icons/bars-solid.svg'
           onclick='toggleSidebar()'
           title='open table of contents'>
    </a>
    <a>
      <img src='/icons/adjust-solid.svg'
           style='position: relative; top: -1px'
           onclick='switchTheme(localStorage.getItem("theme") == "dark" ? "light" : "dark")'
           title='dark theme'>
    </a>
    <a>
      <img src='/icons/search-solid.svg'
           onclick='toggleSearch()'
           title='search'>
    </a>
  </div>
  <div class='title'>Floating-Point Numbers</div>
  <div class='right'>
    <a onClick='window.print()'>
      <img src='/icons/print-solid.svg' title='print'>
    </a>
    <a href='https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2farithmetic%2ffloat.md'>
      <img src='/icons/edit-solid.svg'
           title='edit'
           style='width: 18px; position: relative; right: -2px; top: -1px'>
    </a>
    <a href='https://github.com/algorithmica-org/algorithmica/blob/master//hpc/arithmetic/float.md' class='github-main'>
      <img src='/icons/github-brands.svg' title='view on github'>
    </a>
  </div>
</menu>
<main>
        <div id="search">
    <input id="search-bar" type="search" placeholder='Search this book…' oninput="search()">
    <div id="search-count"></div>
    <div id="search-results">
    </div>
</div>
<header>
  
  <h1>Floating-Point Numbers</h1>
  
    <div class='info'></div>
  
</header>
<article>
  


  
    
    
      
        <p>The users of floating-point arithmetic deserve one of these IQ bell curve memes — because this is how the relationship between it and most people typically proceeds:</p>
<ul>
<li>Beginner programmers use it everywhere as if it was some magic unlimited-precision data type.</li>
<li>Then they discover that <code>0.1 + 0.2 != 0.3</code> or some other quirk like that, freak out, start thinking that some random error term is added to every computation, and for many years avoid any real data types completely.</li>
<li>Then they finally man up, read the specification of how IEEE-754 floats work and start using them appropriately.</li>
</ul>
<p>Unfortunately, too many people are still at stage 2, breeding various misconceptions about floating-point arithmetic — thinking that it is fundamentally imprecise and unstable, and slower than integer arithmetic.</p>
<p><figure>
  <img src="../img/iq.svg">
  <figcaption></figcaption>
</figure>
</p>
<p>But these are all just myths. Floating-point arithmetic is often <em>faster</em> than integer arithmetic because of specialized instructions, and real number representations are thoroughly standardized and follow simple and deterministic rules in terms of rounding, allowing you to manage computational errors reliably.</p>
<p>In fact, it is so reliable that some high-level programming languages, most notably JavaScript, don&rsquo;t have integers at all. In JavaScript, there is only one <code>number</code> type, which is internally stored as a 64-bit <code>double</code>, and due to the way floating-point arithmetic works, all integer numbers between $-2^{53}$ and $2^{53}$ and results of computations involving them can be stored exactly, so from a programmer&rsquo;s perspective, there is little practical need for a separate integer type.</p>
<p>One notable exception is when you need to perform bitwise operations with numbers, which <em>floating-point units</em> (the coprocessors responsible for operations on floating-point numbers) typically don&rsquo;t support. In this case, they need to be converted to integers, which is so frequently used in JavaScript-enabled browsers that arm <a href="https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/armv8-a-architecture-2016-additions">added a special &ldquo;FJCVTZS&rdquo; instruction</a> that stands for &ldquo;Floating-point Javascript Convert to Signed fixed-point, rounding toward Zero&rdquo; and does what it says it does — converts real to integer the exact same way as JavaScript — which is an interesting example of the software-hardware feedback loop in action.</p>
<p>But unless you are a JavaScript developer who uses real types exclusively to emulate integer arithmetic, you probably need a more in-depth guide about floating-point arithmetic, so we are going to start with a broader subject.</p>
<span class='anchor' id="real-number-representations"></span>
<h2><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/arithmetic/float/#real-number-representations">#</a>Real Number Representations</h2><p>If you need to deal with real (non-integer) numbers, you have several options with varying applicability. Before jumping straight to floating-point numbers, which is what most of this article is about, we want to discuss the available alternatives and the motivation behind them — after all, people who avoid floating-point arithmetic do have a point.</p>
<span class='anchor' id="symbolic-expressions"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/arithmetic/float/#symbolic-expressions">#</a>Symbolic Expressions</h3><p>The first and the most cumbersome approach is to store not the resulting values themselves but the algebraic expressions that produce them.</p>
<p>Here is a simple example. In some applications, such as computational geometry, apart from adding, subtracting and multiplying numbers, you also need to divide without rounding, producing a rational number, which can be exactly represented with a ratio of two integers:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">r</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">};</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">r</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">};</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">r</span> <span class="k">operator</span><span class="o">/</span><span class="p">(</span><span class="n">r</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">};</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="n">r</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// ...and so on, you get the idea
</span></span></span></code></pre></div><p>This ratio can be made irreducible, which would even make this representation unique:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">r</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">r</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">x</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">x</span> <span class="o">/=</span> <span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">y</span> <span class="o">/=</span> <span class="n">g</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>This is how <em>computer algebra</em> systems such as WolframAlpha and SageMath work: they operate solely on symbolic expressions and avoid evaluating anything as real values.</p>
<p>With this method, you get absolute precision, and it works well when you have a limited scope such as only supporting rational numbers. But this comes at a large computational cost because in general, you would need to somehow store the whole history of operations that led to the result and take it into account each time you perform a new operation — which quickly becomes unfeasible as the history grows.</p>
<span class='anchor' id="fixed-point-numbers"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/arithmetic/float/#fixed-point-numbers">#</a>Fixed-Point Numbers</h3><p>Another approach is to stick to integers, but treat them as if they were multiplied by a fixed constant. This is essentially the same as changing units of measurement for more up-to-scale ones.</p>
<p>Because some values can&rsquo;t be represented exactly, this makes computations imprecise: you need to round the results to nearest representable value.</p>
<p>This approach is commonly used in financial software, where you <em>really</em> need a straightforward way to manage rounding errors so that the final numbers add up. For example, NASDAQ uses $\frac{1}{10000}$-th of a dollar as its base unit in its stock listings, meaning that you get the precision of exactly 4 digits after comma in all transactions.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">money</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint</span> <span class="n">v</span><span class="p">;</span> <span class="c1">// 1/10000th of a dollar
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="n">money</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">&#34;${0}.{1:04d}&#34;</span><span class="p">,</span> <span class="n">v</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">v</span> <span class="o">%</span> <span class="mi">10000</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">money</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">money</span> <span class="n">x</span><span class="p">,</span> <span class="n">money</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="p">.</span><span class="n">v</span> <span class="o">*</span> <span class="n">y</span><span class="p">.</span><span class="n">v</span> <span class="o">/</span> <span class="mi">10000</span><span class="p">};</span> <span class="p">}</span>
</span></span></code></pre></div><p>Apart from introducing rounding errors, a bigger problem is that they become useless when the scaling constant is misplaced. If the numbers you are working with are too large, then the internal integer value will overflow, and if the numbers are too small, they will be just rounded down to zero. Interestingly, the former case once <a href="https://www.wsj.com/articles/berkshire-hathaways-stock-price-is-too-much-for-computers-11620168548">became an issue</a> on NASDAQ when the Berkshire Hathaway stock price approached $\frac{2^{32} - 1}{10000}$ = $429,496.7295 and could no longer fit in an unsigned 32-bit integer.</p>
<p>This problem makes fixed-point arithmetic fundamentally unsuitable for applications where you need to use both small and large numbers, for example, evaluating certain physics equations:</p>

      
    
  

  
    $$
    
E = m c^2

    $$
  

  
    
    
      
        <p>In this particular one, $m$ is typically of the same order of magnitude as the mass of a proton ($1.67 \cdot 10^{-27}$ kg) and $c$ is the speed of light ($3 \cdot 10^9$ m/s).</p>
<span class='anchor' id="floating-point-numbers"></span>
<h3><a class="anchor-link" href="https://jyang772.github.io/hugo-page/hpc/arithmetic/float/#floating-point-numbers">#</a>Floating-Point Numbers</h3><p>In most numerical applications, we are mainly concerned with the relative error. We want the result of our computations to differ from the truth by no more than, say, $0.01\%$, and we don&rsquo;t really care what that $0.01\%$ equates to in absolute units.</p>
<p>Floating-point numbers solve this by storing a certain number of the most significant digits and the order of magnitude of the number. More precisely, they are represented with an integer (called <em>significand</em> or <em>mantissa</em>) and scaled using an exponent of some fixed base — most commonly, 2 or 10. For example:</p>

      
    
  

  
    $$
    
1.2345 =
\underbrace{12345}_\text{mantissa}
\times {\underbrace{10}_\text{base}\!\!\!\!}
      ^{\overbrace{-4}^\text{exponent}}

    $$
  

  
    
    
      
        <p>Computers operate on fixed-length binary words, so when designing a floating-point format for hardware, you&rsquo;d want a fixed-length binary format where some bits are dedicated for the mantissa (for more precision) and some for the exponent (for more range).</p>
<p>This handmade float implementation hopefully conveys the idea:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// DIY floating-point number
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">struct</span> <span class="nc">fp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// mantissa
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// exponent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>This way we can represent numbers in the form $\pm \; m \times 2^e$ where both $m$ and $e$ are bounded <em>and possibly negative</em> integers — which would correspond to negative or small numbers respectively. The distribution of these numbers is very much non-uniform: there are roughly as many numbers in the $[0, 1)$ range as in the $[1, +\infty)$ range.</p>
<p>Note that these representations are not unique for some numbers. For example, number $1$ can be represented as</p>

      
    
  

  
    $$
    
1 \times 2^0 = 2 \times 2^{-1} = 256 \times 2^{-8}

    $$
  

  
    
    
      
        <p>and in 28 other ways that don&rsquo;t overflow the mantissa.</p>
<p>This can be problematic for some applications, such as comparisons or hashing. To fix this, we can <em>normalize</em> these representations using a certain convention. In decimal, the <a href="https://en.wikipedia.org/wiki/Scientific_notation">standard form</a> is to always put the comma after the first digit (<code>6.022e23</code>), and for binary, we can do the same:</p>

      
    
  

  
    $$
    
42 = 10101_2 = 1.0101_2 \times 2^5

    $$
  

  
    
    
      
        Notice that, following this rule, the first bit is always 1. It is redundant to store it explicitly, so we will just pretend that it&rsquo;s there and only store the other bits, which correspond to some rational number in the $[0, 1)$ range. The set of representable numbers is now roughly
      
    
  

  
    $$
    
\{ \pm \; (1 + m) \cdot 2^e \; | \; m = \frac{x}{2^{32}}, \; x \in [0, 2^{32}) \}

    $$
  

  
    
    
      
        <p>Since $m$ is now a nonnegative value, we will now make it unsigned integer, and instead add a separate Boolean field for the sign of the number:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">fp</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">bool</span> <span class="n">s</span><span class="p">;</span>     <span class="c1">// sign: &#34;0&#34; for &#34;+&#34;, &#34;1&#34; for &#34;-&#34; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="n">m</span><span class="p">;</span> <span class="c1">// mantissa
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">e</span><span class="p">;</span>      <span class="c1">// exponent
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">};</span>
</span></span></code></pre></div><p>Now, let&rsquo;s try to implement some arithmetic operation — for example, multiplication — using our handmade floats. Using the new formula, the result should be:</p>

      
    
  

  
    $$
    
\begin{aligned}
c  &= a \cdot b
\\ &= (s_a \cdot (1 + m_a) \cdot 2^{e_a}) \cdot (s_b \cdot (1 + m_b) \cdot 2^{e_b})
\\ &= s_a \cdot s_b \cdot (1 + m_a) \cdot (1 + m_b) \cdot 2^{e_a} \cdot 2^{e_b} 
\\ &= \underbrace{s_a \cdot s_b}_{s_c} \cdot (1 + \underbrace{m_a + m_b + m_a \cdot m_b}_{m_c}) \cdot 2^{\overbrace{e_a + e_b}^{e_c}}
\end{aligned}

    $$
  

  
    
    
      
        <p>The groupings now seem straightforward to calculate, but there are two nuances:</p>
<ul>
<li>The new mantissa is now in the $[0, 3)$ range. We need to check if it is larger than $1$ and normalize the representation, applying the following formula: $1 + m = (1 + 1) + (m - 1) = (1 + \frac{m - 1}{2}) \cdot 2$.</li>
<li>The resulting number can be (and very likely is) not representable exactly due to the lack of precision. We need twice as many bits to account for the $m_a \cdot m_b$ term, and the best we can do here is to round it to the nearest representable number.</li>
</ul>
<p>Since we need some extra bits to properly handle the mantissa overflow issue, we will reserve one bit from $m$ thus limiting it to $[0,2^{31})$ range.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="n">fp</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="n">fp</span> <span class="n">a</span><span class="p">,</span> <span class="n">fp</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">fp</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span> <span class="o">^</span> <span class="n">b</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="p">.</span><span class="n">e</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">e</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="kt">uint64_t</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">b</span><span class="p">.</span><span class="n">m</span><span class="p">;</span> <span class="c1">// casting to wider types
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint64_t</span> <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// 62- or 63-bit intermediate result
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">62</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// checking for overflow
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">m</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">62</span><span class="p">);</span> <span class="c1">// m -= 1;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">c</span><span class="p">.</span><span class="n">e</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">);</span> <span class="c1">// &#34;rounding&#34; by adding 0.5 to a value that will be floored next
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">c</span><span class="p">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Many applications that require higher levels of precision use software floating-point arithmetic in a similar fashion. But of course, you don&rsquo;t want to execute a sequence of 10 or so instructions that this code compiles to each time you want to multiply two real numbers, so on modern CPUs, floating-point arithmetic is implemented in hardware — usually as separate coprocessors due to its complexity.</p>
<p>The <em>floating-point unit</em> of x86 (often referred to as x87) has separate registers and its own tiny instruction set that supports memory operations, basic arithmetic, trigonometry, and some common operations such as logarithm, exponent, and square root. To make these operations properly work together, some additional details of floating-point number representation need to be clarified — which we will do in <a href="../ieee-754">the next section</a>.</p>

      
    
  



        </article>
        <div class='nextprev'>
  
    
      
      

      
      
      
        
          
        
      
        
      
        
      
        
      
        
      
        
      
        
      

      
        <div class='left'>
        
          <a href='https://jyang772.github.io/hugo-page/hpc/arithmetic/' id='prev-article'>← ../Arithmetic</a>
        
        </div>
        <div class='right'>
        
          <a href='https://jyang772.github.io/hugo-page/hpc/arithmetic/ieee-754/' id='next-article'>IEEE 754 Floats →</a>
        
        </div>
      
    
  
</div>

      </main>
      <footer>
  Copyright 2021–2022 Sergey Slotin
  <br>
   
</footer>

    </div>
  </body>
</html>
