<!doctype html><html lang=en-us><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WBN59M8Y5S")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(53961409,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/53961409 style=position:absolute;left:-9999px alt></div></noscript><meta charset=utf-8><link rel=stylesheet href=/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8+ZXdZy0="><link rel=stylesheet href=/syntax.css id=syntax-theme><link rel=stylesheet type=text/css href=https://tikzjax.com/v1/fonts.css><script src=https://tikzjax.com/v1/tikzjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js></script><script src=/scripts/lunr.stemmer.support.min.js></script><script src=/scripts/lunr.ru.min.js></script><script src=/scripts/lunr.multi.min.js></script><link rel=stylesheet id=theme><script>function toggleSidebar(){console.log("Toggling sidebar visibility");var e=document.getElementById("sidebar"),t=document.getElementById("wrapper");(e.classList.contains("sidebar-toggled")||window.getComputedStyle(e).display=="block")&&(e.classList.toggle("sidebar-hidden"),t.classList.toggle("sidebar-hidden")),e.classList.add("sidebar-toggled"),t.classList.add("sidebar-toggled")}function switchTheme(e){console.log("Changing theme:",e),document.getElementById("theme").href=e=="dark"?"/hugo-page/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css":"",document.getElementById("syntax-theme").href=e=="dark"?"/syntax-dark.css":"/syntax.css",localStorage.setItem("theme",e)}async function toggleSearch(){console.log("Toggling search");var e=document.getElementById("search");if(window.getComputedStyle(e).display=="none"?(e.style.display="block",window.scrollTo({top:0}),document.getElementById("search-bar").focus()):e.style.display="none",!index){console.log("Fetching index");const e=await fetch("/searchindex.json"),t=await e.json();index=lunr(function(){this.use(lunr.multiLanguage("en","ru")),this.field("title",{boost:5}),this.field("content",{boost:1}),t.forEach(function(e){this.add(e),articles.push(e)},this)}),console.log("Ready to search")}}var articles=[],index=void 0;function search(){var n,e=document.getElementById("search-bar").value,s=document.getElementById("search-results"),o=document.getElementById("search-count");if(e==""){s.innerHTML="",o.innerHTML="";return}n=index.search(e),o.innerHTML="Found <b>"+n.length+"</b> pages";let t="";for(const a in n){const i=articles[n[a].ref];t+='<li><a href="'+i.path+'">'+i.title+"</a> <p>";const s=i.content,o=80;if(s.includes(e)){const n=s.indexOf(e);n>o&&(t+="…"),t+=s.substring(n-o,n)+"<b>"+e+"</b>"+s.substring(n+e.length,n+e.length+o)}else t+=s.substring(0,o*2);t+="…</p></li>"}s.innerHTML=t}localStorage.getItem("theme")=="dark"&&switchTheme("dark"),window.addEventListener("load",function(){var e=document.getElementById("active-element");e&&e.scrollIntoView({block:"center"})}),window.addEventListener("scroll",function(){var e=document.getElementById("menu");window.scrollY<120?e.classList.remove("scrolled"):e.classList.add("scrolled")}),window.addEventListener("keydown",function(e){if(e.altKey)return;if(document.activeElement.tagName=="INPUT")return;e.key=="ArrowLeft"?document.getElementById("prev-article").click():e.key=="ArrowRight"&&document.getElementById("next-article").click()})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><title>In-Register Shuffles - Algorithmica</title></head><body><nav id=sidebar><div class=title><a href=/>Algorithmica</a>
<span class=slash>/</span>
<a href=/hugo-page/hpc/ class=divisionAbbr>HPC</a></div><ul><li class=part>Performance Engineering</li><li><a href=/hugo-page/hpc/complexity/>Complexity Models</a></li><ol><li><a href=/hugo-page/hpc/complexity/hardware/>Modern Hardware</a></li><li><a href=/hugo-page/hpc/complexity/languages/>Programming Languages</a></li></ol><li><a href=/hugo-page/hpc/architecture/>Computer Architecture</a></li><ol><li><a href=/hugo-page/hpc/architecture/isa/>Instruction Set Architectures</a></li><li><a href=/hugo-page/hpc/architecture/assembly/>Assembly Language</a></li><li><a href=/hugo-page/hpc/architecture/loops/>Loops and Conditionals</a></li><li><a href=/hugo-page/hpc/architecture/functions/>Functions and Recursion</a></li><li><a href=/hugo-page/hpc/architecture/indirect/>Indirect Branching</a></li><li><a href=/hugo-page/hpc/architecture/layout/>Machine Code Layout</a></li></ol><li><a href=/hugo-page/hpc/pipelining/>Instruction-Level Parallelism</a></li><ol><li><a href=/hugo-page/hpc/pipelining/hazards/>Pipeline Hazards</a></li><li><a href=/hugo-page/hpc/pipelining/branching/>The Cost of Branching</a></li><li><a href=/hugo-page/hpc/pipelining/branchless/>Branchless Programming</a></li><li><a href=/hugo-page/hpc/pipelining/tables/>Instruction Tables</a></li><li><a href=/hugo-page/hpc/pipelining/throughput/>Throughput Computing</a></li></ol><li><a href=/hugo-page/hpc/compilation/>Compilation</a></li><ol><li><a href=/hugo-page/hpc/compilation/stages/>Stages of Compilation</a></li><li><a href=/hugo-page/hpc/compilation/flags/>Flags and Targets</a></li><li><a href=/hugo-page/hpc/compilation/situational/>Situational Optimizations</a></li><li><a href=/hugo-page/hpc/compilation/contracts/>Contract Programming</a></li><li><a href=/hugo-page/hpc/compilation/precalc/>Precomputation</a></li></ol><li><a href=/hugo-page/hpc/profiling/>Profiling</a></li><ol><li><a href=/hugo-page/hpc/profiling/instrumentation/>Instrumentation</a></li><li><a href=/hugo-page/hpc/profiling/events/>Statistical Profiling</a></li><li><a href=/hugo-page/hpc/profiling/simulation/>Program Simulation</a></li><li><a href=/hugo-page/hpc/profiling/mca/>Machine Code Analyzers</a></li><li><a href=/hugo-page/hpc/profiling/benchmarking/>Benchmarking</a></li><li><a href=/hugo-page/hpc/profiling/noise/>Getting Accurate Results</a></li></ol><li><a href=/hugo-page/hpc/arithmetic/>Arithmetic</a></li><ol><li><a href=/hugo-page/hpc/arithmetic/float/>Floating-Point Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/ieee-754/>IEEE 754 Floats</a></li><li><a href=/hugo-page/hpc/arithmetic/errors/>Rounding Errors</a></li><li><a href=/hugo-page/hpc/arithmetic/newton/>Newton's Method</a></li><li><a href=/hugo-page/hpc/arithmetic/rsqrt/>Fast Inverse Square Root</a></li><li><a href=/hugo-page/hpc/arithmetic/integer/>Integer Numbers</a></li><li><a href=/hugo-page/hpc/arithmetic/division/>Integer Division</a></li></ol><li><a href=/hugo-page/hpc/number-theory/>Number Theory</a></li><ol><li><a href=/hugo-page/hpc/number-theory/modular/>Modular Arithmetic</a></li><li><a href=/hugo-page/hpc/number-theory/exponentiation/>Binary Exponentiation</a></li><li><a href=/hugo-page/hpc/number-theory/euclid-extended/>Extended Euclidean Algorithm</a></li><li><a href=/hugo-page/hpc/number-theory/montgomery/>Montgomery Multiplication</a></li></ol><li><a href=/hugo-page/hpc/external-memory/>External Memory</a></li><ol><li><a href=/hugo-page/hpc/external-memory/hierarchy/>Memory Hierarchy</a></li><li><a href=/hugo-page/hpc/external-memory/virtual/>Virtual Memory</a></li><li><a href=/hugo-page/hpc/external-memory/model/>External Memory Model</a></li><li><a href=/hugo-page/hpc/external-memory/sorting/>External Sorting</a></li><li><a href=/hugo-page/hpc/external-memory/list-ranking/>List Ranking</a></li><li><a href=/hugo-page/hpc/external-memory/policies/>Eviction Policies</a></li><li><a href=/hugo-page/hpc/external-memory/oblivious/>Cache-Oblivious Algorithms</a></li><li><a href=/hugo-page/hpc/external-memory/locality/>Spatial and Temporal Locality</a></li></ol><li><a href=/hugo-page/hpc/cpu-cache/>RAM & CPU Caches</a></li><ol><li><a href=/hugo-page/hpc/cpu-cache/bandwidth/>Memory Bandwidth</a></li><li><a href=/hugo-page/hpc/cpu-cache/latency/>Memory Latency</a></li><li><a href=/hugo-page/hpc/cpu-cache/cache-lines/>Cache Lines</a></li><li><a href=/hugo-page/hpc/cpu-cache/sharing/>Memory Sharing</a></li><li><a href=/hugo-page/hpc/cpu-cache/mlp/>Memory-Level Parallelism</a></li><li><a href=/hugo-page/hpc/cpu-cache/prefetching/>Prefetching</a></li><li><a href=/hugo-page/hpc/cpu-cache/alignment/>Alignment and Packing</a></li><li><a href=/hugo-page/hpc/cpu-cache/pointers/>Pointer Alternatives</a></li><li><a href=/hugo-page/hpc/cpu-cache/associativity/>Cache Associativity</a></li><li><a href=/hugo-page/hpc/cpu-cache/paging/>Memory Paging</a></li><li><a href=/hugo-page/hpc/cpu-cache/aos-soa/>AoS and SoA</a></li></ol><li><a href=/hugo-page/hpc/simd/>SIMD Parallelism</a></li><ol><li><a href=/hugo-page/hpc/simd/intrinsics/>Intrinsics and Vector Types</a></li><li><a href=/hugo-page/hpc/simd/moving/>Moving Data</a></li><li><a href=/hugo-page/hpc/simd/reduction/>Reductions</a></li><li><a href=/hugo-page/hpc/simd/masking/>Masking and Blending</a></li><li><a href=/hugo-page/hpc/simd/shuffling/ id=active-element>In-Register Shuffles</a></li><li><a href=/hugo-page/hpc/simd/auto-vectorization/>Auto-Vectorization and SPMD</a></li></ol><li><a href=/hugo-page/hpc/algorithms/>Algorithms Case Studies</a></li><ol><li><a href=/hugo-page/hpc/algorithms/gcd/>Binary GCD</a></li><li><a href=/hugo-page/hpc/algorithms/factorization/>Integer Factorization</a></li><li><a href=/hugo-page/hpc/algorithms/argmin/>Argmin with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/prefix/>Prefix Sum with SIMD</a></li><li><a href=/hugo-page/hpc/algorithms/matmul/>Matrix Multiplication</a></li></ol><li><a href=/hugo-page/hpc/data-structures/>Data Structures Case Studies</a></li><ol><li><a href=/hugo-page/hpc/data-structures/binary-search/>Binary Search</a></li><li><a href=/hugo-page/hpc/data-structures/s-tree/>Static B-Trees</a></li><li><a href=/hugo-page/hpc/data-structures/b-tree/>Search Trees</a></li><li><a href=/hugo-page/hpc/data-structures/segment-trees/>Segment Trees</a></li></ol></ul></nav><div id=wrapper><menu id=menu><div class=left><a><img src=/icons/bars-solid.svg onclick=toggleSidebar() title='open table of contents'>
</a><a><img src=/icons/adjust-solid.svg style=position:relative;top:-1px onclick='switchTheme(localStorage.getItem("theme")=="dark"?"light":"dark")' title='dark theme'>
</a><a><img src=/icons/search-solid.svg onclick=toggleSearch() title=search></a></div><div class=title>In-Register Shuffles</div><div class=right><a onclick=window.print()><img src=/icons/print-solid.svg title=print>
</a><a href=https://prose.io/#algorithmica-org/algorithmica/edit/master//hpc%2fsimd%2fshuffling.md><img src=/icons/edit-solid.svg title=edit style=width:18px;position:relative;right:-2px;top:-1px>
</a><a href=https://github.com/algorithmica-org/algorithmica/blob/master//hpc/simd/shuffling.md class=github-main><img src=/icons/github-brands.svg title='view on github'></a></div></menu><main><div id=search><input id=search-bar type=search placeholder='Search this book…' oninput=search()><div id=search-count></div><div id=search-results></div></div><header><h1>In-Register Shuffles</h1><div class=info></div></header><article><p><a href=../masking>Masking</a> lets you apply operations to only a subset of vector elements. It is a very effective and frequently used data manipulation technique, but in many cases, you need to perform more advanced operations that involve permuting values inside a vector register instead of just blending them with other vectors.</p><p>The problem is that adding a separate element-shuffling instruction for each possible use case in hardware is unfeasible. What we can do though is to add just one general permutation instruction that takes the indices of a permutation and produces these indices using precomputed lookup tables.</p><p>This general idea is perhaps too abstract, so let&rsquo;s jump straight to the examples.</p><span class=anchor id=shuffles-and-popcount></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/simd/shuffling/#shuffles-and-popcount>#</a>Shuffles and Popcount</h3><p><em>Population count</em>, also known as the <em>Hamming weight</em>, is the count of <code>1</code> bits in a binary string.</p><p>It is a frequently used operation, so there is a separate instruction on x86 that computes the population count of a word:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>N</span> <span class=o>=</span> <span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>12</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>popcnt</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>+=</span> <span class=n>__builtin_popcount</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It also supports 64-bit integers, improving the total throughput twofold:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>popcnt_ll</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=kt>long</span> <span class=o>*</span><span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=kt>long</span> <span class=kt>long</span><span class=o>*</span><span class=p>)</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>+=</span> <span class=n>__builtin_popcountl</span><span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The only two instructions required are load-fused popcount and addition. They both have a high throughput, so the code processes about $8+8=16$ bytes per cycle as it is limited by the decode width of 4 on this CPU.</p><p>These instructions were added to x86 CPUs around 2008 with SSE4. Let&rsquo;s temporarily go back in time before vectorization even became a thing and try to implement popcount by other means.</p><p>The naive way is to go through the binary string bit by bit:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>__attribute__</span> <span class=p>((</span> <span class=n>optimize</span><span class=p>(</span><span class=s>&#34;no-tree-vectorize&#34;</span><span class=p>)</span> <span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>popcnt</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=mi>32</span><span class=p>;</span> <span class=n>l</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span> <span class=o>+=</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;&gt;</span> <span class=n>l</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>As anticipated, it works just slightly faster than ⅛-th of a byte per cycle — at around 0.2.</p><p>We can try to process in bytes instead of individual bits by <a href=/hpc/compilation/precalc>precomputing</a> a small 256-element <em>lookup table</em> that contains the population counts of individual bytes and then query it while iterating over raw bytes of the array:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Precalc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>alignas</span><span class=p>(</span><span class=mi>64</span><span class=p>)</span> <span class=kt>char</span> <span class=n>counts</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>Precalc</span><span class=p>()</span> <span class=o>:</span> <span class=n>counts</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>m</span> <span class=o>&lt;</span> <span class=mi>256</span><span class=p>;</span> <span class=n>m</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>counts</span><span class=p>[</span><span class=n>m</span><span class=p>]</span> <span class=o>+=</span> <span class=p>(</span><span class=n>m</span> <span class=o>&gt;&gt;</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>Precalc</span> <span class=n>P</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>popcnt</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>b</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=n>a</span><span class=p>;</span> <span class=c1>// careful: plain &#34;char&#34; is signed
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>+=</span> <span class=n>P</span><span class=p>.</span><span class=n>counts</span><span class=p>[</span><span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It now processes around 2 bytes per cycle, rising to ~2.7 if we switch to 16-bit words (<code>unsigned short</code>).</p><p>This solution is still very slow compared to the <code>popcnt</code> instruction, but now it can be vectorized. Instead of trying to speed it up through <a href=../moving#non-contiguous-load>gather</a> instructions, we will go for another approach: make the lookup table small enough to fit inside a register and then use a special <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=pshuf&amp;techs=AVX,AVX2&amp;expand=6331">pshufb</a> instruction to look up its values in parallel.</p><p>The original <code>pshufb</code> introduced in 128-bit SSE3 takes two registers: the lookup table containing 16 byte values and a vector of 16 4-bit indices (0 to 15), specifying which bytes to pick for each position. In 256-bit AVX2, instead of a 32-byte lookup table with awkward 5-bit indices, we have an instruction that independently the same shuffling operation over two 128-bit lanes.</p><p>So, for our use case, we create a 16-byte lookup table with population counts for each nibble (half-byte), repeated twice:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>lookup</span> <span class=o>=</span> <span class=n>_mm256_setr_epi8</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 0 */</span> <span class=mi>0</span><span class=p>,</span> <span class=cm>/* 1 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 2 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 3 */</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 4 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 5 */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* 6 */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* 7 */</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 8 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 9 */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* a */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* b */</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* c */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* d */</span> <span class=mi>3</span><span class=p>,</span> <span class=cm>/* e */</span> <span class=mi>3</span><span class=p>,</span> <span class=cm>/* f */</span> <span class=mi>4</span><span class=p>,</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* 0 */</span> <span class=mi>0</span><span class=p>,</span> <span class=cm>/* 1 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 2 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 3 */</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 4 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 5 */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* 6 */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* 7 */</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 8 */</span> <span class=mi>1</span><span class=p>,</span> <span class=cm>/* 9 */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* a */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* b */</span> <span class=mi>3</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* c */</span> <span class=mi>2</span><span class=p>,</span> <span class=cm>/* d */</span> <span class=mi>3</span><span class=p>,</span> <span class=cm>/* e */</span> <span class=mi>3</span><span class=p>,</span> <span class=cm>/* f */</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><p>Now, to compute the population count of a vector, we split each of its bytes into the lower and higher nibbles and then use this lookup table to retrieve their counts. The only thing left is to carefully sum them up:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>low_mask</span> <span class=o>=</span> <span class=n>_mm256_set1_epi8</span><span class=p>(</span><span class=mh>0x0f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>popcnt</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>reg</span> <span class=n>t</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(;</span> <span class=n>k</span> <span class=o>+</span> <span class=mi>15</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>k</span> <span class=o>+=</span> <span class=mi>15</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_setzero_si256</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>15</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>k</span> <span class=o>+</span> <span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>reg</span> <span class=n>l</span> <span class=o>=</span> <span class=n>_mm256_and_si256</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>low_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>reg</span> <span class=n>h</span> <span class=o>=</span> <span class=n>_mm256_and_si256</span><span class=p>(</span><span class=n>_mm256_srli_epi16</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=mi>4</span><span class=p>),</span> <span class=n>low_mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>reg</span> <span class=n>pl</span> <span class=o>=</span> <span class=n>_mm256_shuffle_epi8</span><span class=p>(</span><span class=n>lookup</span><span class=p>,</span> <span class=n>l</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>reg</span> <span class=n>ph</span> <span class=o>=</span> <span class=n>_mm256_shuffle_epi8</span><span class=p>(</span><span class=n>lookup</span><span class=p>,</span> <span class=n>h</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_add_epi8</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>pl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span> <span class=o>=</span> <span class=n>_mm256_add_epi8</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>ph</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>t</span> <span class=o>=</span> <span class=n>_mm256_add_epi64</span><span class=p>(</span><span class=n>t</span><span class=p>,</span> <span class=n>_mm256_sad_epu8</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>_mm256_setzero_si256</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=n>hsum</span><span class=p>(</span><span class=n>t</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>k</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>+=</span> <span class=n>__builtin_popcount</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This code processes around 30 bytes per cycle. Theoretically, the inner loop could do 32, but we have to stop it every 15 iterations because the 8-bit counters can overflow.</p><p>The <code>pshufb</code> instruction is so instrumental in some SIMD algorithms that <a href=http://0x80.pl/>Wojciech Muła</a> — the guy who came up with this algorithm — took it as his <a href=https://twitter.com/pshufb>Twitter handle</a>. You can calculate population counts even faster: check out his <a href=https://github.com/WojciechMula/sse-popcount>GitHub repository</a> with different vectorized popcount implementations and his <a href=https://arxiv.org/pdf/1611.07612.pdf>recent paper</a> for a detailed explanation of the state-of-the-art.</p><span class=anchor id=permutations-and-lookup-tables></span><h3><a class=anchor-link href=http://jyang772.github.io/hugo-page/hpc/simd/shuffling/#permutations-and-lookup-tables>#</a>Permutations and Lookup Tables</h3><p>Our last major example in this chapter is the <code>filter</code>. It is a very important data processing primitive that takes an array as input and writes out only the elements that satisfy a given predicate (in their original order).</p><p>In a single-threaded scalar case, it is trivially implemented by maintaining a counter that is incremented on each write:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>[</span><span class=n>N</span><span class=p>],</span> <span class=n>b</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>filter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>P</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=p>[</span><span class=n>k</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To vectorize it, we will use the <code>_mm256_permutevar8x32_epi32</code> intrinsic. It takes a vector of values and individually selects them with a vector of indices. Despite the name, it doesn&rsquo;t <em>permute</em> values but just <em>copies</em> them to form a new vector: duplicates in the result are allowed.</p><p>The general idea of our algorithm is as follows:</p><ul><li>calculate the predicate on a vector of data — in this case, this means performing the comparisons to get the mask;</li><li>use the <code>movemask</code> instruction to get a scalar 8-bit mask;</li><li>use this mask to index a lookup table that returns a permutation moving the elements that satisfy the predicate to the beginning of the vector (in their original order);</li><li>use the <code>_mm256_permutevar8x32_epi32</code> intrinsic to permute the values;</li><li>write the whole permuted vector to the buffer — it may have some trailing garbage, but its prefix is correct;</li><li>calculate the population count of the scalar mask and move the buffer pointer by that number.</li></ul><p>First, we need to precompute the permutations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Precalc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>alignas</span><span class=p>(</span><span class=mi>64</span><span class=p>)</span> <span class=kt>int</span> <span class=n>permutation</span><span class=p>[</span><span class=mi>256</span><span class=p>][</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>constexpr</span> <span class=nf>Precalc</span><span class=p>()</span> <span class=o>:</span> <span class=n>permutation</span><span class=p>{}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>m</span> <span class=o>&lt;</span> <span class=mi>256</span><span class=p>;</span> <span class=n>m</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>8</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>m</span> <span class=o>&gt;&gt;</span> <span class=n>i</span> <span class=o>&amp;</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>permutation</span><span class=p>[</span><span class=n>m</span><span class=p>][</span><span class=n>k</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=n>Precalc</span> <span class=n>T</span><span class=p>;</span>
</span></span></code></pre></div><p>Then we can implement the algorithm itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>const</span> <span class=n>reg</span> <span class=n>p</span> <span class=o>=</span> <span class=n>_mm256_set1_epi32</span><span class=p>(</span><span class=n>P</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>filter</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=mi>8</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>m</span> <span class=o>=</span> <span class=n>_mm256_cmpgt_epi32</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>mask</span> <span class=o>=</span> <span class=n>_mm256_movemask_ps</span><span class=p>((</span><span class=n>__m256</span><span class=p>)</span> <span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>reg</span> <span class=n>permutation</span> <span class=o>=</span> <span class=n>_mm256_load_si256</span><span class=p>(</span> <span class=p>(</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>T</span><span class=p>.</span><span class=n>permutation</span><span class=p>[</span><span class=n>mask</span><span class=p>]</span> <span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>x</span> <span class=o>=</span> <span class=n>_mm256_permutevar8x32_epi32</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>permutation</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>_mm256_storeu_si256</span><span class=p>((</span><span class=n>reg</span><span class=o>*</span><span class=p>)</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>[</span><span class=n>k</span><span class=p>],</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>k</span> <span class=o>+=</span> <span class=n>__builtin_popcount</span><span class=p>(</span><span class=n>mask</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The vectorized version takes some work to implement, but it is 6-7x faster than the scalar one (the speedup is slightly less for either low or high values of <code>P</code> as the <a href=/hpc/pipelining/branching>branch becomes predictable</a>).</p><p><figure><img src=../img/filter.svg><figcaption></figcaption></figure></p><p>The loop performance is still relatively low — taking 4 CPU cycles per iteration — because, on this particular CPU (Zen 2), <code>movemask</code>, <code>permute</code>, and <code>store</code> have low throughput and all have to go through the same execution port (P2). On most other x86 CPUs, you can expect it to be ~2x faster.</p><p>Filtering can also be implemented considerably faster on AVX-512: it has a special &ldquo;<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#ig_expand=7395,7392,7269,4868,7269,7269,1820,1835,6385,5051,4909,4918,5051,7269,6423,7410,150,2138,1829,1944,3009,1029,7077,519,5183,4462,4490,1944,1395&amp;text=_mm512_mask_compress_epi32">compress</a>&rdquo; instruction that takes a vector of data and a mask and writes its unmasked elements contiguously. It makes a huge difference in algorithms that rely on various filtering subroutines, such as quicksort.</p></article><div class=nextprev><div class=left><a href=http://jyang772.github.io/hugo-page/hpc/simd/masking/ id=prev-article>← Masking and Blending</a></div><div class=right><a href=http://jyang772.github.io/hugo-page/hpc/simd/auto-vectorization/ id=next-article>Auto-Vectorization and SPMD →</a></div></div></main><footer>Copyright 2021–2022 Sergey Slotin<br></footer></div></body></html>