<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Data Structures Case Studies on Algorithmica</title>
    <link>https://en.algorithmica.org/hpc/data-structures/</link>
    <description>Recent content in Data Structures Case Studies on Algorithmica</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://en.algorithmica.org/hpc/data-structures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Binary Search</title>
      <link>https://en.algorithmica.org/hpc/data-structures/binary-search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://en.algorithmica.org/hpc/data-structures/binary-search/</guid>
      <description>While improving the speed of user-facing applications is the end goal of performance engineering, people don&amp;rsquo;t really get excited over 5-10% improvements in some databases. Yes, this is what software engineers are paid for, but these types of optimizations tend to be too intricate and system-specific to be readily generalized to other software.&#xA;Instead, the most fascinating showcases of performance engineering are multifold optimizations of textbook algorithms: the kinds that everybody knows and deemed so simple that it would never even occur to try to optimize them in the first place.</description>
    </item>
    <item>
      <title>Static B-Trees</title>
      <link>https://en.algorithmica.org/hpc/data-structures/s-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://en.algorithmica.org/hpc/data-structures/s-tree/</guid>
      <description>This section is a follow-up to the previous one, where we optimized binary search by the means of removing branching and improving the memory layout. Here, we will also be searching in sorted arrays, but this time we are not limited to fetching and comparing only one element at a time.&#xA;In this section, we generalize the techniques we developed for binary search to static B-trees and accelerate them further using SIMD instructions.</description>
    </item>
    <item>
      <title>Search Trees</title>
      <link>https://en.algorithmica.org/hpc/data-structures/b-tree/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://en.algorithmica.org/hpc/data-structures/b-tree/</guid>
      <description>In the previous article, we designed and implemented static B-trees to speed up binary searching in sorted arrays. In its last section, we briefly discussed how to make them dynamic back while retaining the performance gains from SIMD and validated our predictions by adding and following explicit pointers in the internal nodes of the S+ tree.&#xA;In this article, we follow up on that proposition and design a minimally functional search tree for integer keys, achieving up to 18x/8x speedup over std::set and up to 7x/2x speedup over absl::btree for lower_bound and insert queries, respectively â€” with yet ample room for improvement.</description>
    </item>
    <item>
      <title>Segment Trees</title>
      <link>https://en.algorithmica.org/hpc/data-structures/segment-trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://en.algorithmica.org/hpc/data-structures/segment-trees/</guid>
      <description>The lessons learned from optimizing binary search can be applied to a broad range of data structures.&#xA;In this article, instead of trying to optimize something from the STL again, we focus on segment trees, the structures that may be unfamiliar to most normal programmers and perhaps even most computer science researchers1, but that are used very extensively in programming competitions for their speed and simplicity of implementation.&#xA;(If you already know the context, jump straight to the last section for the novelty: the wide segment tree that works 4 to 12 times faster than the Fenwick tree.</description>
    </item>
  </channel>
</rss>
