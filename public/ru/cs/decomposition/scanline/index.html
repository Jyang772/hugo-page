<!doctype html><html lang=ru-ru><head><script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-WBN59M8Y5S")</script><script type=text/javascript>(function(e,t,n,s,o,i,a){e[o]=e[o]||function(){(e[o].a=e[o].a||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym"),ym(53961409,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0,webvisor:!0})</script><noscript><div><img src=https://mc.yandex.ru/watch/53961409 style=position:absolute;left:-9999px alt></div></noscript><meta charset=utf-8><link rel=stylesheet href=/hugo-page/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8+ZXdZy0="><link rel=stylesheet href=/syntax.css id=syntax-theme><link rel=stylesheet type=text/css href=https://tikzjax.com/v1/fonts.css><script src=https://tikzjax.com/v1/tikzjax.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js></script><script src=/scripts/lunr.stemmer.support.min.js></script><script src=/scripts/lunr.ru.min.js></script><script src=/scripts/lunr.multi.min.js></script><link rel=stylesheet id=theme><script>function toggleSidebar(){console.log("Toggling sidebar visibility");var e=document.getElementById("sidebar"),t=document.getElementById("wrapper");(e.classList.contains("sidebar-toggled")||window.getComputedStyle(e).display=="block")&&(e.classList.toggle("sidebar-hidden"),t.classList.toggle("sidebar-hidden")),e.classList.add("sidebar-toggled"),t.classList.add("sidebar-toggled")}function switchTheme(e){console.log("Changing theme:",e),document.getElementById("theme").href=e=="dark"?"/hugo-page/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css":"",document.getElementById("syntax-theme").href=e=="dark"?"/syntax-dark.css":"/syntax.css",localStorage.setItem("theme",e)}async function toggleSearch(){console.log("Toggling search");var e=document.getElementById("search");if(window.getComputedStyle(e).display=="none"?(e.style.display="block",window.scrollTo({top:0}),document.getElementById("search-bar").focus()):e.style.display="none",!index){console.log("Fetching index");const e=await fetch("/searchindex.json"),t=await e.json();index=lunr(function(){this.use(lunr.multiLanguage("en","ru")),this.field("title",{boost:5}),this.field("content",{boost:1}),t.forEach(function(e){this.add(e),articles.push(e)},this)}),console.log("Ready to search")}}var articles=[],index=void 0;function search(){var n,e=document.getElementById("search-bar").value,s=document.getElementById("search-results"),o=document.getElementById("search-count");if(e==""){s.innerHTML="",o.innerHTML="";return}n=index.search(e),o.innerHTML="Найдено <b>"+n.length+"</b> страниц";let t="";for(const a in n){const i=articles[n[a].ref];t+='<li><a href="'+i.path+'">'+i.title+"</a> <p>";const s=i.content,o=80;if(s.includes(e)){const n=s.indexOf(e);n>o&&(t+="…"),t+=s.substring(n-o,n)+"<b>"+e+"</b>"+s.substring(n+e.length,n+e.length+o)}else t+=s.substring(0,o*2);t+="…</p></li>"}s.innerHTML=t}localStorage.getItem("theme")=="dark"&&switchTheme("dark"),window.addEventListener("load",function(){var e=document.getElementById("active-element");e&&e.scrollIntoView({block:"center"})}),window.addEventListener("scroll",function(){var e=document.getElementById("menu");window.scrollY<120?e.classList.remove("scrolled"):e.classList.add("scrolled")}),window.addEventListener("keydown",function(e){if(e.altKey)return;if(document.activeElement.tagName=="INPUT")return;e.key=="ArrowLeft"?document.getElementById("prev-article").click():e.key=="ArrowRight"&&document.getElementById("next-article").click()})</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})'></script><title>Сканирующая прямая - Алгоритмика</title></head><body><nav id=sidebar><div class=title><a href=/>Алгоритмика</a>
<span class=slash>/</span>
<a href=/cs/ class=divisionAbbr>CS</a></div><ul><li class=part>Анализ алгоритмов</li><li><a href=/cs/complexity/>Вычислительная сложность</a></li><ol><li><a href=/cs/complexity/asymptotic/>Асимптотический анализ</a></li><li><a href=/cs/complexity/master-theorem/>Мастер-теорема</a></li></ol><li><a href=/cs/sorting/>Сортировки</a></li><ol><li><a href=/cs/sorting/bubble/>Сортировка пузырьком</a></li><li><a href=/cs/sorting/selection/>Сортировка выбором</a></li><li><a href=/cs/sorting/insertion/>Сортировка вставками</a></li><li><a href=/cs/sorting/heapsort/>Сортировка кучей</a></li><li><a href=/cs/sorting/counting/>Сортировка подсчетом</a></li><li><a href=/cs/sorting/radix/>Цифровая сортировка</a></li></ol><li><a href=/cs/interactive/>Бинпоиск и интерактивки</a></li><ol><li><a href=/cs/interactive/binary-search/>Бинарный поиск</a></li><li><a href=/cs/interactive/answer-search/>Бинарный поиск по ответу</a></li></ol><li><a href=/cs/sequences/>Последовательности</a></li><ol><li><a href=/cs/sequences/compression/>Сжатие координат</a></li></ol><li><a href=/cs/decomposition/>Декомпозиция задач</a></li><ol><li><a href=/cs/decomposition/scanline/ id=active-element>Сканирующая прямая</a></li><li><a href=/cs/decomposition/rollback/>Откатывание состояний</a></li><li><a href=/cs/decomposition/sqrt-heuristics/>Корневые эвристики</a></li><li><a href=/cs/decomposition/mo/>Алгоритм Мо</a></li><li><a href=/cs/decomposition/mitm/>Meet-in-the-middle</a></li></ol><li><a href=/cs/arithmetic/>Арифметика</a></li><ol><li><a href=/cs/arithmetic/bit-representation/>Битовое представление чисел</a></li><li><a href=/cs/arithmetic/simd/>Векторизация</a></li></ol><li class=part>Структуры данных</li><li><a href=/cs/basic-structures/>Базовые структуры данных</a></li><ol><li><a href=/cs/basic-structures/array/>Массивы и кортежи</a></li><li><a href=/cs/basic-structures/iterators/>Итераторы</a></li><li><a href=/cs/basic-structures/vector/>Динамический массив</a></li><li><a href=/cs/basic-structures/heap/>Двоичная куча</a></li></ol><li><a href=/cs/tree-structures/>Деревья поиска</a></li><ol><li><a href=/cs/tree-structures/stl-trees/>Деревья в STL</a></li><li><a href=/cs/tree-structures/treap/>Декартово дерево</a></li><li><a href=/cs/tree-structures/implicit/>Неявный ключ</a></li></ol><li><a href=/cs/set-structures/>Структуры для множеств</a></li><ol><li><a href=/cs/set-structures/bitset/>Битсет и битовое сжатие</a></li><li><a href=/cs/set-structures/dsu/>Система непересекающихся множеств</a></li></ol><li><a href=/cs/range-queries/>Запросы на отрезках</a></li><ol><li><a href=/cs/range-queries/prefix-sum/>Префиксные суммы</a></li><li><a href=/cs/range-queries/fenwick/>Дерево Фенвика</a></li><li><a href=/cs/range-queries/sparse-table/>Разреженная таблица</a></li><li><a href=/cs/range-queries/sqrt-structures/>Корневые структуры</a></li></ol><li><a href=/cs/persistent/>Персистентность</a></li><ol><li><a href=/cs/persistent/persistent-array/>Структуры с откатами</a></li><li><a href=/cs/persistent/path-copying/>Метод копирования пути</a></li><li><a href=/cs/persistent/persistent-segtree/>Персистентное дерево отрезков</a></li><li><a href=/cs/persistent/persistent-treap/>Персистентное декартово дерево</a></li></ol><li><a href=/cs/segment-tree/>Дерево отрезков</a></li><ol><li><a href=/cs/segment-tree/pointers/>Дерево отрезков на указателях</a></li><li><a href=/cs/segment-tree/lazy-propagation/>Отложенные операции</a></li><li><a href=/cs/segment-tree/lazy-initialization/>Отложенное построение</a></li></ol><li class=part>Динамическое программирование</li><li><a href=/cs/general-dynamic/>Общие приёмы динамики</a></li><ol><li><a href=/cs/general-dynamic/segments/>Динамика по подотрезкам</a></li><li><a href=/cs/general-dynamic/memoization/>Ленивая динамика</a></li></ol><li><a href=/cs/combinatorial-optimization/>Комбинаторная оптимизация</a></li><ol><li><a href=/cs/combinatorial-optimization/greedy/>Жадные алгоритмы</a></li><li><a href=/cs/combinatorial-optimization/matroid/>Матроиды</a></li><li><a href=/cs/combinatorial-optimization/annealing/>Метод отжига</a></li></ol><li><a href=/cs/games/>Теория игр</a></li><ol><li><a href=/cs/games/nim/>Игра «Ним»</a></li></ol><li><a href=/cs/layer-optimizations/>Пересчет динамики по слоям</a></li><ol><li><a href=/cs/layer-optimizations/divide-and-conquer/>Оптимизация через разделяй-и-властвуй</a></li><li><a href=/cs/layer-optimizations/knuth/>Оптимизация Кнута</a></li><li><a href=/cs/layer-optimizations/convex-hull-trick/>Convex Hull Trick</a></li><li><a href=/cs/layer-optimizations/lagrange/>Дискретный метод Лагранжа</a></li></ol><li class=part>Математика</li><li><a href=/cs/algebra/>Алгебра</a></li><ol><li><a href=/cs/algebra/binpow/>Бинарное возведение в степень</a></li><li><a href=/cs/algebra/matrix/>Матрицы</a></li><li><a href=/cs/algebra/matmul/>Задачи на умножение матриц</a></li><li><a href=/cs/algebra/gauss/>Линейные уравнения</a></li><li><a href=/cs/algebra/polynomials/>Многочлены</a></li><li><a href=/cs/algebra/interpolation/>Интерполяция</a></li><li><a href=/cs/algebra/karatsuba/>Алгоритм Карацубы</a></li><li><a href=/cs/algebra/fft/>Быстрое преобразование Фурье</a></li></ol><li><a href=/cs/modular/>Модулярная арифметика</a></li><ol><li><a href=/cs/modular/euclid/>Алгоритм Евклида</a></li><li><a href=/cs/modular/extended-euclid/>Расширенный алгоритм Евклида</a></li><li><a href=/cs/modular/reciprocal/>«Деление» по модулю</a></li></ol><li><a href=/cs/factorization/>Факторизация и простые числа</a></li><ol><li><a href=/cs/factorization/eratosthenes/>Решето Эратосфена</a></li><li><a href=/cs/factorization/pollard/>Ро-алгоритм Полларда</a></li></ol><li class=part>Графы</li><li><a href=/cs/graph-traversals/>Обходы графов</a></li><ol><li><a href=/cs/graph-traversals/storing-graphs/>Хранение графов</a></li><li><a href=/cs/graph-traversals/dfs/>Поиск в глубину</a></li><li><a href=/cs/graph-traversals/connectivity/>Поиск компонент связности</a></li><li><a href=/cs/graph-traversals/bipartite/>Двудольные графы и раскраски</a></li><li><a href=/cs/graph-traversals/cycle/>Нахождение цикла</a></li><li><a href=/cs/graph-traversals/topological-sorting/>Топологическая сортировка</a></li><li><a href=/cs/graph-traversals/euler-cycle/>Эйлеров цикл</a></li><li><a href=/cs/graph-traversals/bridges/>Мосты и точки сочленения</a></li><li><a href=/cs/graph-traversals/scc/>Компоненты сильной связности</a></li><li><a href=/cs/graph-traversals/2-sat/>2-SAT</a></li></ol><li><a href=/cs/shortest-paths/>Кратчайшие пути</a></li><ol><li><a href=/cs/shortest-paths/acyclic-paths/>Пути в ациклических графах</a></li><li><a href=/cs/shortest-paths/bfs/>Поиск в ширину</a></li><li><a href=/cs/shortest-paths/dijkstra/>Алгоритм Дейкстры</a></li></ol><li><a href=/cs/spanning-trees/>Связность и остовные деревья</a></li><ol><li><a href=/cs/spanning-trees/safe-edge/>Лемма о безопасном ребре</a></li><li><a href=/cs/spanning-trees/prim/>Алгоритм Прима</a></li><li><a href=/cs/spanning-trees/kruskal/>Алгоритм Краскала</a></li><li><a href=/cs/spanning-trees/boruvka/>Алгоритм Борувки</a></li><li><a href=/cs/spanning-trees/dcp/>Динамическая связность</a></li></ol><li><a href=/cs/matching/>Паросочетания</a></li><ol><li><a href=/cs/matching/berge/>Лемма Бержа</a></li><li><a href=/cs/matching/kuhn/>Алгоритм Куна</a></li><li><a href=/cs/matching/matching-problems/>Задачи на паросочетания</a></li><li><a href=/cs/matching/hall/>Теорема о свадьбах</a></li></ol><li><a href=/cs/trees/>Корневые деревья</a></li><ol><li><a href=/cs/trees/tree-queries/>Запросы на деревьях</a></li><li><a href=/cs/trees/lca-rmq/>Связь задачи LCA и static RMQ</a></li><li><a href=/cs/trees/binary-lifting/>Метод двоичных подъемов</a></li><li><a href=/cs/trees/centroid/>Центроидная декомпозиция</a></li><li><a href=/cs/trees/heavy-light/>Heavy-light декомпозиция</a></li></ol><li><a href=/cs/flows/>Потоки</a></li><ol><li><a href=/cs/flows/mincost-maxflow/>Поток минимальной стоимости</a></li></ol><li class=part>Геометрия</li><li><a href=/cs/geometry-basic/>Геометрические примитивы</a></li><ol><li><a href=/cs/geometry-basic/vectors/>Точки и вектора</a></li><li><a href=/cs/geometry-basic/products/>Скалярное и векторное произведение</a></li><li><a href=/cs/geometry-basic/segments/>Прямые и отрезки</a></li><li><a href=/cs/geometry-basic/polygons/>Многоугольники</a></li></ol><li><a href=/cs/convex-hulls/>Выпуклые оболочки</a></li><ol><li><a href=/cs/convex-hulls/hull-applications/>Применения выпуклых оболочек</a></li><li><a href=/cs/convex-hulls/jarvis/>Алгоритм Джарвиса</a></li><li><a href=/cs/convex-hulls/graham/>Алгоритм Грэхэма</a></li><li><a href=/cs/convex-hulls/chan/>Алгоритм Чана</a></li><li><a href=/cs/convex-hulls/envelope/>Верхние и нижние огибающие</a></li></ol><li class=part>Строки</li><li><a href=/cs/string-searching/>Поиск подстроки</a></li><ol><li><a href=/cs/string-searching/prefix-function/>Префикс-функция</a></li><li><a href=/cs/string-searching/z-function/>Z-функция</a></li><li><a href=/cs/string-searching/manacher/>Алгоритм Манакера</a></li></ol><li><a href=/cs/hashing/>Хеширование</a></li><ol><li><a href=/cs/hashing/polynomial/>Полиномиальное хеширование</a></li><li><a href=/cs/hashing/collision/>Коллизии хешей</a></li><li><a href=/cs/hashing/isomorphism/>Проверки на изоморфизм</a></li></ol><li><a href=/cs/string-structures/>Строковые структуры</a></li><ol><li><a href=/cs/string-structures/trie/>Префиксное дерево</a></li><li><a href=/cs/string-structures/aho-corasick/>Алгоритм Ахо-Корасик</a></li><li><a href=/cs/string-structures/palindromic-tree/>Дерево палиндромов</a></li><li><a href=/cs/string-structures/suffix-array/>Суффиксный массив</a></li></ol><li class=part>Разное</li><li><a href=/cs/numerical/>Численные методы</a></li><ol><li><a href=/cs/numerical/newton/>Метод Ньютона</a></li><li><a href=/cs/numerical/monte-carlo/>Методы Монте-Карло</a></li></ol><li><a href=/cs/programming/>Технологии программирования</a></li><ol><li><a href=/cs/programming/stress-test/>Стресс-тестирование</a></li><li><a href=/cs/programming/bayans/>Просто интересные задачи</a></li></ol></ul></nav><div id=wrapper><menu id=menu><div class=left><a><img src=/icons/bars-solid.svg onclick=toggleSidebar() title='open table of contents'>
</a><a><img src=/icons/adjust-solid.svg style=position:relative;top:-1px onclick='switchTheme(localStorage.getItem("theme")=="dark"?"light":"dark")' title='dark theme'>
</a><a><img src=/icons/search-solid.svg onclick=toggleSearch() title=search></a></div><div class=title>Сканирующая прямая</div><div class=right><a onclick=window.print()><img src=/icons/print-solid.svg title=print>
</a><a href=https://prose.io/#algorithmica-org/algorithmica/edit/master//cs%2fdecomposition%2fscanline.md><img src=/icons/edit-solid.svg title=edit style=width:18px;position:relative;right:-2px;top:-1px>
</a><a href=https://github.com/algorithmica-org/algorithmica/blob/master//cs/decomposition/scanline.md class=github-main><img src=/icons/github-brands.svg title='view on github'></a></div></menu><main><div id=search><input id=search-bar type=search placeholder='Поиск по сайту…' oninput=search()><div id=search-count></div><div id=search-results></div></div><header><h1>Сканирующая прямая</h1><div class=info><div><span>автор</span>
<span>Сергей Слотин</span></div><div><span>пререквизиты</span>
<span><a href=https://ru.algorithmica.org/cs/range-queries/>Запросы на отрезках</a></span>
<span><a href=https://ru.algorithmica.org/cs/segment-tree/>Дерево отрезков</a></span></div></div></header><article><p>Метод сканирующей прямой (англ. <em>scanline</em>) заключается в сортировке точек на координатной прямой либо каких-то абстрактных «событий» по какому-то признаку и последующему проходу по ним.</p><p>Он часто используется для решения задач на структуры данных, когда все запросы известны заранее, а также в геометрии для нахождения объединений фигур.</p><span class=anchor id=точка-покрытая-наибольшим-количеством-отрезков></span><h3><a class=anchor-link href=https://ru.algorithmica.org/cs/decomposition/scanline/#%d1%82%d0%be%d1%87%d0%ba%d0%b0-%d0%bf%d0%be%d0%ba%d1%80%d1%8b%d1%82%d0%b0%d1%8f-%d0%bd%d0%b0%d0%b8%d0%b1%d0%be%d0%bb%d1%8c%d1%88%d0%b8%d0%bc-%d0%ba%d0%be%d0%bb%d0%b8%d1%87%d0%b5%d1%81%d1%82%d0%b2%d0%be%d0%bc-%d0%be%d1%82%d1%80%d0%b5%d0%b7%d0%ba%d0%be%d0%b2>#</a>Точка, покрытая наибольшим количеством отрезков</h3><p><strong>Задача.</strong> Дан набор из $n$ отрезков на прямой, заданных координатами начал и концов $[l_i, r_i]$. Требуется найти любую точку на прямой, покрытую наибольшим количеством отрезков.</p><p>Рассмотрим функцию $f(x)$, равную числу отрезков, покрывающих точку $x$. Понятно, что каждую точку этой функции мы проверить не можем.</p><p>Назовем <em>интересными</em> те точки, в которых происходит смена количества отрезков, которыми она покрыта. Так как смена ответа может происходить только в интересной точке, то максимум достигается также в какой-то из интересных точек. Отсюда сразу следует решение за $O(n^2)$: просто перебрать все интересные точки (это будут концы заданных отрезков) и проверить для каждой по отдельности ответ.</p><p>Это решение можно улучшить. Отсортируем интересные точки по возрастанию координаты и пройдем по ним слева направо, поддерживая количество отрезков <code>cnt</code>, которые покрывают данную точку. Если в данной точке начинается отрезок, то надо увеличить <code>cnt</code> на единицу, а если заканчивается, то уменьшить. После этого пробуем обновить ответ на задачу текущим значением <code>cnt</code>.</p><p>Как такое писать: нужно представить интересные точки в виде структур с полями «координата» и «тип» (начало / конец) и отсортировать со своим компаратором. Удобно начало отрезка обозначать +1, а конец -1, чтобы просто прибавлять к <code>cnt</code> это значение и не разбивать на случаи.</p><p>Единственный нюанс — если координаты двух точек совпали, чтобы получить правильный ответ, сначала надо рассмотреть все начала отрезков, а только потом концы (чтобы при обновлении ответа в этой координате учлись и правые, и левые граничные отрезки).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>scanline</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>segments</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>event</span><span class=o>&gt;</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>]</span> <span class=o>:</span> <span class=n>segments</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>events</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span><span class=n>l</span><span class=p>,</span> <span class=mi>1</span><span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=n>events</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span><span class=n>r</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sort</span><span class=p>(</span><span class=n>events</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>events</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[](</span><span class=n>event</span> <span class=n>a</span><span class=p>,</span> <span class=n>event</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>||</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>==</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>.</span><span class=n>type</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>.</span><span class=n>type</span><span class=p>));</span> 
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>event</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>events</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>+=</span> <span class=n>e</span><span class=p>.</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>res</span><span class=p>,</span> <span class=n>cnt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Такое решение работает за $O(n \log n)$ на сортировку. Если координаты небольшие, то от логарифма можно избавиться, если создать <code>vector</code> событий для каждой различной координаты и просто итерироваться по всем целочисленным координатам и событиям в них. Также всегда хорошей идеей будет <a href=/cs/sequences/compression>сжать координаты</a>.</p><p>Рассмотрим теперь несколько смежных задач.</p><span class=anchor id=длина-объединения-отрезков></span><h3><a class=anchor-link href=https://ru.algorithmica.org/cs/decomposition/scanline/#%d0%b4%d0%bb%d0%b8%d0%bd%d0%b0-%d0%be%d0%b1%d1%8a%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d0%be%d1%82%d1%80%d0%b5%d0%b7%d0%ba%d0%be%d0%b2>#</a>Длина объединения отрезков</h3><p><strong>Задача.</strong> Дан набор из $n$ отрезков на прямой, заданных координатами начал и концов $[l_i, r_i]$. Требуется найти суммарную длину их объединения.</p><p>Как и в прошлой задаче, отсортируем все интересные точки и при проходе будем поддерживать число отрезков, покрывающих текущую точку. Если оно больше 0, то отрезок, который мы прошли с прошлой рассмотренной точки, принадлежит объединению, и его длину нужно прибавить к ответу:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>prev</span> <span class=o>=</span> <span class=o>-</span><span class=n>inf</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>event</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>events</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>prev</span> <span class=o>!=</span> <span class=o>-</span><span class=n>inf</span> <span class=o>&amp;&amp;</span> <span class=n>cnt</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>res</span> <span class=o>+=</span> <span class=n>e</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>prev</span><span class=p>;</span> <span class=c1>// весь отрезок [prev, e.x] покрыт cnt отрезками
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cnt</span> <span class=o>+=</span> <span class=n>e</span><span class=p>.</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>prev</span> <span class=o>=</span> <span class=n>e</span><span class=p>.</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Время работы $O(n \log n)$.</p><span class=anchor id=скольким-отрезкам-принадлежит-точка></span><h3><a class=anchor-link href=https://ru.algorithmica.org/cs/decomposition/scanline/#%d1%81%d0%ba%d0%be%d0%bb%d1%8c%d0%ba%d0%b8%d0%bc-%d0%be%d1%82%d1%80%d0%b5%d0%b7%d0%ba%d0%b0%d0%bc-%d0%bf%d1%80%d0%b8%d0%bd%d0%b0%d0%b4%d0%bb%d0%b5%d0%b6%d0%b8%d1%82-%d1%82%d0%be%d1%87%d0%ba%d0%b0>#</a>Скольким отрезкам принадлежит точка</h3><p>Пусть теперь надо для $q$ точек (не обязательно являющихся концами отрезков) ответить на вопрос: скольким отрезкам принадлежит данная точка?</p><p>Воспользуемся следующим приемом: сразу считаем все запросы и сохраним их, чтобы потом ответить на все сразу. Добавим точки запросов как события с новым типом 0, который будет означать, что в этой точке надо ответить на запрос, и отдельным полем для номера запроса.</p><p>Теперь аналогично отсортируем точки интереса и пройдем по ним слева направо, поддерживая <code>cnt</code> и отвечая на запросы, когда их встретим.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>event</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>type</span><span class=p>,</span> <span class=n>idx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>scanline</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>segments</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>queries</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>q</span> <span class=o>=</span> <span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=n>queries</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ans</span><span class=p>(</span><span class=n>q</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>event</span><span class=o>&gt;</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=p>[</span><span class=n>l</span><span class=p>,</span> <span class=n>r</span><span class=p>]</span> <span class=o>:</span> <span class=n>segments</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>events</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span><span class=n>l</span><span class=p>,</span> <span class=mi>1</span><span class=p>});</span>
</span></span><span class=line><span class=cl>        <span class=n>events</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span><span class=n>r</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>});</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>q</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>events</span><span class=p>.</span><span class=n>push_back</span><span class=p>({</span><span class=n>queries</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=mi>0</span><span class=p>,</span> <span class=n>i</span><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// при равенстве координат сначала идут добавления, потом запросы, потом удаления
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sort</span><span class=p>(</span><span class=n>events</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>events</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[](</span><span class=n>event</span> <span class=n>a</span><span class=p>,</span> <span class=n>event</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>||</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>==</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>&amp;&amp;</span> <span class=n>a</span><span class=p>.</span><span class=n>type</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>.</span><span class=n>type</span><span class=p>));</span> 
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>event</span> <span class=nl>e</span> <span class=p>:</span> <span class=n>events</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>+=</span> <span class=n>e</span><span class=p>.</span><span class=n>type</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>type</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>ans</span><span class=p>[</span><span class=n>e</span><span class=p>.</span><span class=n>idx</span><span class=p>]</span> <span class=o>=</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Асимптотика $O((n+q)\log(n+q))$.</p><span class=anchor id=количество-пересекающихся-отрезков></span><h3><a class=anchor-link href=https://ru.algorithmica.org/cs/decomposition/scanline/#%d0%ba%d0%be%d0%bb%d0%b8%d1%87%d0%b5%d1%81%d1%82%d0%b2%d0%be-%d0%bf%d0%b5%d1%80%d0%b5%d1%81%d0%b5%d0%ba%d0%b0%d1%8e%d1%89%d0%b8%d1%85%d1%81%d1%8f-%d0%be%d1%82%d1%80%d0%b5%d0%b7%d0%ba%d0%be%d0%b2>#</a>Количество пересекающихся отрезков</h3><p><strong>Задача.</strong> Дан набор из $n$ отрезков на прямой, заданных координатами начал и концов $[l_i, r_i]$. Требуется для каждого отрезка сказать, с каким количеством отрезков он пересекается (в частности, он может иметь одну общую точку или быть вложенным).</p><p>Вместо того, чтобы для каждого отрезка считать количество отрезков, с которыми он пересекается, посчитаем количество отрезков, с которыми он <em>не</em> пересекается, и вычтем это число из $(n-1)$.</p><p>Отрезок $[l_1, r_1]$ не пересекается с другим отрезком $[l_2, r_2]$ только если $r_2 &lt; l_1$ или $r_1 &lt; l_2$. Посчитаем количество отрезков для каждого из этих случаев. Без ограничения общности, рассмотрим первый случай, то есть найдем для каждого отрезка количество отрезков, лежащих строго слева. Для этого нужно ввести два типа событий:</p><ol><li>Какой-то отрезок закончился в координате $r_i$.</li><li>Какой-то отрезок с таким-то индексом начался в координате $l_j$.</li></ol><p>Теперь нам достаточно пройтись по этим событиям слева направо, поддерживая количество встреченных событий первого типа и вычитая его из ячейки ответа для событий второго типа.</p><p>Аналогично пройдемся справа налево, находя отрезки, лежащие строго справа. Итоговое время работы будет $O(n \log n)$ на сортировку.</p><span class=anchor id=сумма-на-прямоугольнике></span><h3><a class=anchor-link href=https://ru.algorithmica.org/cs/decomposition/scanline/#%d1%81%d1%83%d0%bc%d0%bc%d0%b0-%d0%bd%d0%b0-%d0%bf%d1%80%d1%8f%d0%bc%d0%be%d1%83%d0%b3%d0%be%d0%bb%d1%8c%d0%bd%d0%b8%d0%ba%d0%b5>#</a>Сумма на прямоугольнике</h3><p>Перейдем к двумерному сканлайну.</p><p><strong>Задача.</strong> Даны $n$ точек на плоскости. Требуется ответить на $m$ запросов количества точек на прямоугольнике.</p><p>Во-первых, сожмем все координаты (и точек, и запросов): будем считать, что они все порядка $O(n + m)$.</p><p>Теперь разобьём каждый запрос на два запроса суммы на префиксах: сумма на прямоугольнике $[x_1, x_2] \times [y_1, y_2]$ равна сумме на прямоугольнике $[0, x_2] \times [y_1, y_2]$ минус сумме на прямоугольнике $[0, x_1] \times [y_1, y_2]$.</p><p>Создадим дерево отрезков для суммы и массив <code>ans</code> для ответов на запросы. Теперь будем проходиться в порядке увеличения по всем интересным $x$ — координатам точек и правых границ префиксных запросов — и обрабатывать события трёх типов:</p><ol><li>Если мы встретили точку, то добавляем единицу к ячейке $y$ в дереве отрезков.</li><li>Если мы встретили «левый» запрос префиксной суммы, то посчитаем через дерево отрезков сумму на отрезке $[y_1, y_2]$ и <em>вычтем</em> его из ячейки ответа.</li><li>Если мы встретили «правый» запрос, то аналогично <em>прибавим</em> сумму на $[y_1, y_2]$ к ячейке ответа.</li></ol><p>Таким образом, мы решим задачу в оффлайн за $O(n \log n)$: сжатие координат / сортировка плюс $O(n)$ запросов к дереву отрезков (или любой другой структуре для динамической суммы).</p><p>Сумма на прямоугольнике как вспомогательная подзадача также часто используется в задачах на инверсии в перестановках и запросы на поддеревьях.</p><span class=anchor id=площадь-объединения-прямоугольников></span><h3><a class=anchor-link href=https://ru.algorithmica.org/cs/decomposition/scanline/#%d0%bf%d0%bb%d0%be%d1%89%d0%b0%d0%b4%d1%8c-%d0%be%d0%b1%d1%8a%d0%b5%d0%b4%d0%b8%d0%bd%d0%b5%d0%bd%d0%b8%d1%8f-%d0%bf%d1%80%d1%8f%d0%bc%d0%be%d1%83%d0%b3%d0%be%d0%bb%d1%8c%d0%bd%d0%b8%d0%ba%d0%be%d0%b2>#</a>Площадь объединения прямоугольников</h3><p><strong>Задача.</strong> Дано $n$ прямоугольников, требуется найти площадь их объединения.</p><p>Вдохновляясь предыдущим подходом, можно создать два типа событий:</p><ol><li>прямоугольник с $y$-координатами от $y_1$ до $y_2$ начинается в точке $x_1$;</li><li>прямоугольник с $y$-координатами от $y_1$ до $y_2$ заканчивается в точке $x_2$;</li></ol><p>и затем как-то пройтись по этим событиям в порядке увеличения $x$ и посчитать общую площадь подобно тому, как мы делали с одномерными отрезками.</p><p><figure><img src=../img/2d-scanline.jpg><figcaption></figcaption></figure></p><p>Если обобщать подход напрямую, то нам нужно завести массив размера $Y$ (максимальной $y$-координаты) и для каждой $y$-параллели поддерживать число прямоугольников, которые её покрывают, и каждый раз, когда $x$-координата события меняется, добавлять к ответу разницу $x$-координат старого и нового события, помноженную на число ненулевых элементов в массиве (точек на вертикальной сканирующей прямой, которые покрываются хотя бы одним прямоугольником).</p><p>Но это в худшем случае работает за $O(nY)$, что достаточно долго. Чтобы получить более приятную асимптотику, заменим массив деревом отрезков, в узлах которого будет храниться минимум и число элементов с таким минимумом (изначально минимум 0 и таких элементов на всём массиве $Y$).</p><p>Чтобы обновить ответ, нужно помножить разницу $x$-координат соседних событий на число ненулевых элементов, которое можно найти, вычтя из $Y$ количество минимумов-нулей на всём дереве. Одномерная задача пересчета этой информации при прибавлениях на отрезке остается <a href=/cs/segment-tree/lazy-propagation>упражнением читателю</a>.</p><p>Такой алгоритм работает за $O(n \log n)$, если аккуратно сжать координаты, и за $O(n \log Y)$, если этого не делать. Этот метод также обобщается на задачу нахождения площадей и других геометрических фигур.</p></article><div class=nextprev><div class=left><a href=https://ru.algorithmica.org/cs/decomposition/ id=prev-article>← ../Декомпозиция задач</a></div><div class=right><a href=https://ru.algorithmica.org/cs/decomposition/rollback/ id=next-article>Откатывание состояний →</a></div></div></main><footer>Copyleft 2017–2022 Algorithmica.org<br>Материалы распространяются под <a href=https://tldrlegal.com/license/creative-commons-attribution-sharealike-4.0-international-(cc-by-sa-4.0)>CC BY-SA</a></footer></div></body></html>