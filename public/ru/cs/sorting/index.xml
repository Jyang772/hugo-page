<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Сортировки on Алгоритмика</title><link>https://ru.algorithmica.org/cs/sorting/</link><description>Recent content in Сортировки on Алгоритмика</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Thu, 21 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ru.algorithmica.org/cs/sorting/index.xml" rel="self" type="application/rss+xml"/><item><title>Сортировка пузырьком</title><link>https://ru.algorithmica.org/cs/sorting/bubble/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/sorting/bubble/</guid><description>Наш первый подход будет заключаться в следующем: обозначим за $n$ длину массива и $n$ раз пройдёмся по нему слева направо, меняя два соседних элемента, если первый больше второго.
Каждую итерацию максимальный элемент «всплывает» как пузырек к концу массива — отсюда и название.
void bubble_sort(int *a, int n) { for (int k = 0; k &amp;lt; n; k++) for (int i = 0; i &amp;lt; n - 1; i++) // сравниваем элемент со следующим if (a[i] &amp;gt; a[i + 1]) // меняем местами, если следующий меньше swap(a[i], a[i + 1]); } int a[5] = {5, 2, 1, 3, 1}; bubble_sort(a, 5); for (int i = 0; i &amp;lt; 5; i++) cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;#34; &amp;#34;; Корректность.</description></item><item><title>Сортировка выбором</title><link>https://ru.algorithmica.org/cs/sorting/selection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/sorting/selection/</guid><description>Похожим методом является сортировка выбором (минимума или максимума).
Чтобы отсортировать массив, $n$ раз выберем минимум среди еще неотсортированных чисел и поставим его на свое место (а именно, на $k$-тую позицию после $k$-той итерации). Чтобы упростить реализацию, на $k$-ой итерации будем искать минимум на отрезке $[k, n - 1]$, меняя его местами с текущим $k$-тым элементом, после чего отрезок $[0, k]$ будет отсортирован.
void selection_sort(int *a, int n) { for (int k = 0; k &amp;lt; n - 1; k++) for (int j = k + 1; j &amp;lt; n; j++) if (a[k] &amp;gt; a[j]) swap(a[j], a[k]); } Доказательства корректности и времени работы аналогичны пузырьковой сортировке: после каждой из $O(n)$ итераций мы за время $O(n)$ получаем отсортированный префикс (первые $k$ элементов), а значит за $O(n^2)$ операций отсортируем весь массив целиком.</description></item><item><title>Сортировка вставками</title><link>https://ru.algorithmica.org/cs/sorting/insertion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/sorting/insertion/</guid><description>Пусть на $k$-ом шаге у нас уже отсортирован префикс длины $k$. Чтобы увеличить этот отсортированный префикс, мы можем взять элемент, следующий после него, и менять его с левым соседом, пока этот элемент не окажется больше своего левого соседа. Когда это произойдет, это будет означать, что он будет больше всех элементов слева и меньше всех элементов префикса справа, и значит мы правильно вставили этот элемент в отсортированную часть массива.
void insertion_sort(int *a, int n) { for (int k = 1; k &amp;lt; n; k++) for (int i = k; i &amp;gt; 0 &amp;amp;&amp;amp; a[i - 1] &amp;lt; a[i]; i--) // мы ещё не дошли до начала массива и предыдущий элемент меньше swap(a[i], a[i - 1]); } Время работы в худшем случае тоже квадратичное — например, когда массив упорядочен по убыванию.</description></item><item><title>Сортировка кучей</title><link>https://ru.algorithmica.org/cs/sorting/heapsort/</link><pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/sorting/heapsort/</guid><description>Причина, по которой сортировка выбором работает за квадратичное время — это линейный поиск минимума на каждом шаге.
Чтобы соптимизировать время работы алгоритма, мы можем завести специальную структуру данных, которая поддерживает быстрое извлечение минимума из набора неупорядоченных элементов, добавить весь исходных массив в неё, а затем по одному извлекать минимум в новый отсортированных массив.
Это ровно то, что делает двоичная куча — за $O(\log n)$ на операцию. Воспользовавшись ей, получаем алгоритм, работающий за $O(n \log n)$:</description></item><item><title>Сортировка подсчетом</title><link>https://ru.algorithmica.org/cs/sorting/counting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/sorting/counting/</guid><description>Все предыдущие алгоритмы работали с массивами, в которых лежат могут лежать абсолютно любые объекты, которые можно сравнивать: числа, строки, пары, другие массивы — почти все что угодно.
В особом случае, когда элементы могут принадлежать только какому-то небольшому множеству, можно использовать другой алгоритм — сортировку подсчетом (англ. counting sort).
Пусть, например, нам гарантируется, что все числа натуральные и лежат в промежутке от $1$ до $100$. Тогда есть такой простой алгоритм:
Создадим массив размера $100$, в котором будем хранить на $k$-ом месте, сколько раз число $k$ встретилось в этом массиве.</description></item><item><title>Цифровая сортировка</title><link>https://ru.algorithmica.org/cs/sorting/radix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/sorting/radix/</guid><description>Цифровая сортировка — это способ применить идею сортировки подсчетом на большие ключи.
Пусть нам нужно отсортировать большой массив int-ов — скажем, $10^5$ элементов. Мы можем сначала отсортировать его по первым двум байтам (то есть используя $\lfloor x / 2^{16} \rfloor$ как ключ) стабильной сортировкой подсчетом, а затем получившуюся последовательность отсортировать по вторым двум байтам (используя $x \bmod 2^{16}$ как ключ).
Реализация, использующая подсчет через массив векторов:
const int c = (1&amp;lt;&amp;lt;16); void radix_sort(vector&amp;lt;int&amp;gt; &amp;amp;a) { int n = (int) a.</description></item></channel></rss>