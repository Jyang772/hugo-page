<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Деревья поиска on Алгоритмика</title><link>https://ru.algorithmica.org/cs/tree-structures/</link><description>Recent content in Деревья поиска on Алгоритмика</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Sat, 22 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ru.algorithmica.org/cs/tree-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>Деревья в STL</title><link>https://ru.algorithmica.org/cs/tree-structures/stl-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/tree-structures/stl-trees/</guid><description>В STL конкретная реализация бинарного дерева представлена структурой set, поддерживающей упорядоченное множество уникальных элементов.
#Основные операцииСтруктуру set&amp;lt;T&amp;gt; можно объявить от любого типа, для которого реализован оператор сравнения — в частности, для пар и тюплов он реализован автоматически как лексикографическая сортировка.
set&amp;lt;int&amp;gt; s; s.insert(3); // s = {3} s.insert(2); // s = {2, 3} s.size(); // вернет |s| = 2 s.insert(3); // 3 не будет добавлено ещё раз, так как уже присутствует в множестве s.</description></item><item><title>Декартово дерево</title><link>https://ru.algorithmica.org/cs/tree-structures/treap/</link><pubDate>Sat, 22 Jan 2022 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/tree-structures/treap/</guid><description>Рене Декарт (фр. René Descartes) — великий французский математик и философ XVII века.
Рене Декарт не является создателем декартова дерева, однако он является создателем декартовой системы координат, которую мы все знаем и любим.
Декартово дерево же определяется и строится так:
Нанесём на плоскость набор из $n$ точек. Их $x$ зачем-то назовем ключом, а $y$ приоритетом. Выберем самую верхнюю точку (с наибольшим $y$, а если таких несколько — любую) и назовём её корнем.</description></item><item><title>Неявный ключ</title><link>https://ru.algorithmica.org/cs/tree-structures/implicit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/tree-structures/implicit/</guid><description>Обычное декартово дерево — это структура для множеств, каждый элемент которых имеет какой-то ключ. Эти ключи задают на этом множестве порядок, и все запросы к ДД обычно как-то привязаны к этому порядку.
Но что, если у нас есть запросы, которые этот порядок как-то нетривиально меняют? Например, если у нас есть массив, в котором нужно уметь
выводить сумму на произвольном отрезке, «переворачивать» произвольный отрезок, то есть переставлять элементы с $l$ по $r$ в обратном порядке, не меняя остальные.</description></item></channel></rss>