<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Связность и остовные деревья on Алгоритмика</title>
    <link>https://ru.algorithmica.org/cs/spanning-trees/</link>
    <description>Recent content in Связность и остовные деревья on Алгоритмика</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Sat, 25 Sep 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ru.algorithmica.org/cs/spanning-trees/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Лемма о безопасном ребре</title>
      <link>https://ru.algorithmica.org/cs/spanning-trees/safe-edge/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/spanning-trees/safe-edge/</guid>
      <description>Назовем подграф $T$ графа $G$ безопасным, если он является подграфом какого-то минимального остова.&#xA;Назовем ребро безопасным, если при добавлении его в подграф $T$ получившийся подграф $T&amp;rsquo;$ тоже является безопасным, то есть подграфом какого-то минимального остова.&#xA;Разрезом связного графа будем называть подмножество рёбер и вершин, образующих подграф, в котором есть ровно две компоненты связности. Ребро пересекает данный разрез, если при его добавлении граф снова становится связным.&#xA;Все алгоритмы для поиска минимального остова опираются на следующее утверждение:</description>
    </item>
    <item>
      <title>Алгоритм Прима</title>
      <link>https://ru.algorithmica.org/cs/spanning-trees/prim/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/spanning-trees/prim/</guid>
      <description>Лемма о безопасном ребре говорит, что мы можем строить минимальный остов постепенно, добавляя по одному ребра, про которые мы точно знаем, что они минимальные для соединения какого-то разреза.&#xA;Один из подходов это использовать заключается в алгоритме Прима:&#xA;Изначально остов — одна произвольная вершина. Пока минимальный остов не найден, выбирается ребро минимального веса, исходящее из какой-нибудь вершины текущего остова в вершину, которую мы ещё не добавили. Добавляем это ребро в остов и начинаем заново, пока остов не будет найден.</description>
    </item>
    <item>
      <title>Алгоритм Краскала</title>
      <link>https://ru.algorithmica.org/cs/spanning-trees/kruskal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/spanning-trees/kruskal/</guid>
      <description>Другой способ использовать лемму о безопасном ребре — отсортировать все ребра и пытаться добавлять их в изначально пустой остов в порядке возрастания их весов.&#xA;Если очередное ребро соединяет какие-то две уже соединенные вершины, то проигнорируем его. Иначе оно является безопасным, так как оно минимальное из соединяющих какие-то две различные компоненты, и его можно добавить.&#xA;Звучит очень просто: отсортировать все рёбра, пройтись по ним циклом и делать проверку, что вершины в разных компонентах.</description>
    </item>
    <item>
      <title>Алгоритм Борувки</title>
      <link>https://ru.algorithmica.org/cs/spanning-trees/boruvka/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/spanning-trees/boruvka/</guid>
      <description>Переформулируем лемму о безопасном ребре в частном случае:&#xA;Лемма. Для любой вершины минимальное инцидентное ей реборо является безопасным.&#xA;Доказательство. Пусть есть минимальный остов, в котором для какой-то вершины $v$ нет её минимального инцидентного ребра. Тогда, если добавить это ребро, образуется цикл, из которого можно удалить другое ребро, тоже инцидентное $v$, но имеющее не меньший вес.&#xA;Алгоритм Борувки опирается на этот факт и заключается в следующем:&#xA;Для каждой вершины найдем минимальное инцидентное ей ребро.</description>
    </item>
    <item>
      <title>Динамическая связность</title>
      <link>https://ru.algorithmica.org/cs/spanning-trees/dcp/</link>
      <pubDate>Sat, 25 Sep 2021 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/spanning-trees/dcp/</guid>
      <description>В контексте графов, система непересекающихся множеств напрямую решает следующую задачу:&#xA;Задача. Дан изначально пустой граф, и требуется обработать $n$ запросов добавления ребра (+) и проверки связности двух вершин (?).&#xA;Если немного подумать, можно решить и обратную ей:&#xA;Задача. Дан граф, и нужно обрабатывать $n$ заранее известных запросов удаления ребра (-) и проверки связности двух вершин (?).&#xA;Здесь ключевое условие — что все запросы известны заранее. Это позволяет заменить все - на + и пройтись по всем запросам в обратном порядке.</description>
    </item>
  </channel>
</rss>
