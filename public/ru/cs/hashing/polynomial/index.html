<!doctype html>
<html lang='ru-ru'><head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WBN59M8Y5S"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-WBN59M8Y5S');
</script>


<script type="text/javascript">
  (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
  m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
  (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

  ym(53961409, "init", {
       clickmap:true,
       trackLinks:true,
       accurateTrackBounce:true,
       webvisor:true
  });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/53961409" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<meta charset="utf-8">

  
  <link rel="stylesheet" href="/style.min.a3a4a7a8e8602aaa85b7cb3d655edde028ac80d73f2a97389e2cbcf995dd672d.css" integrity="sha256-o6SnqOhgKqqFt8s9ZV7d4CisgNc/Kpc4niy8&#43;ZXdZy0=">
  <link rel="stylesheet" href="/syntax.css" id="syntax-theme">

  <link rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css">
  <script src="https://tikzjax.com/v1/tikzjax.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js"></script>
  <script src="/scripts/lunr.stemmer.support.min.js"></script>
  <script src="/scripts/lunr.ru.min.js"></script>
  <script src="/scripts/lunr.multi.min.js"></script>

  
  <link rel="stylesheet" id="theme">

  <script>
    function toggleSidebar() {
      console.log("Toggling sidebar visibility")
      var sidebar = document.getElementById('sidebar')
      var wrapper = document.getElementById('wrapper')
      if (sidebar.classList.contains('sidebar-toggled') || window.getComputedStyle(sidebar).display == 'block') { 
        sidebar.classList.toggle('sidebar-hidden')
        wrapper.classList.toggle('sidebar-hidden')
      }
      sidebar.classList.add('sidebar-toggled')
      wrapper.classList.add('sidebar-toggled')
    }

    function switchTheme(theme) {
      console.log("Changing theme:", theme)
      document.getElementById('theme').href = (theme == 'dark' ? "\/dark.min.b3ae1169831434b11b48de5b3e3210547eea6b7884c295ab0030cb973ea0dc49.css" : "")
      document.getElementById('syntax-theme').href = (theme == 'dark' ? '/syntax-dark.css' : '/syntax.css')
      localStorage.setItem('theme', theme)
    }

    async function toggleSearch() {
      console.log("Toggling search")
      
      var searchDiv = document.getElementById('search')
      if (window.getComputedStyle(searchDiv).display == 'none') {
        searchDiv.style.display = 'block'
        window.scrollTo({ top: 0 });
        document.getElementById('search-bar').focus()
      } else {
        searchDiv.style.display = 'none'  
      }

      if (!index) {
        console.log("Fetching index")
        const response = await fetch('/searchindex.json')
        const pages = await response.json()
        index = lunr(function() {
          this.use(lunr.multiLanguage('en', 'ru'))
          this.field('title', {
            boost: 5
          })
          this.field('content', {
            boost: 1
          })
          pages.forEach(function(doc) {
            this.add(doc)
            articles.push(doc)
          }, this)
        })
        console.log("Ready to search")
      }
    }

    var articles = []
    var index = undefined

    function search() {
      var query = document.getElementById('search-bar').value
      var resultsDiv = document.getElementById('search-results')
      var countDiv = document.getElementById('search-count')
      
      if (query == '') {
        resultsDiv.innerHTML = ''
        countDiv.innerHTML = ''
        return
      }
      
      var results = index.search(query)

      countDiv.innerHTML = 'Найдено <b>' + results.length + '</b> страниц'

      let resultList = ''

      for (const n in results) {
        const item = articles[results[n].ref]
        resultList += '<li><a href="' + item.path + '">' + item.title + '</a> <p>'
        const text = item.content

        const contextLimit = 80

        if (text.includes(query)) {
          const start = text.indexOf(query)
          if (start > contextLimit)
            resultList += '…'
          resultList += text.substring(start - contextLimit, start)
                      + '<b>' + query + '</b>' + text.substring(start + query.length, start + query.length + contextLimit)

        } else {
          resultList += text.substring(0, contextLimit * 2)
        }
        resultList += '…</p></li>'
      }

      resultsDiv.innerHTML = resultList
    }

    if (localStorage.getItem('theme') == 'dark') {
      switchTheme('dark')
    }

    window.addEventListener('load', function() {
      var el = document.getElementById("active-element")
      
      if (el) {
        el.scrollIntoView({block: "center"})
      }
      

    })

    window.addEventListener('scroll', function() {
      var menu = document.getElementById('menu')
      if (window.scrollY < 120) {
        
        menu.classList.remove('scrolled')
      } else {
        
        menu.classList.add('scrolled')
      }
    })

    window.addEventListener('keydown', function(e) {
      if (e.altKey) { return }
      if (document.activeElement.tagName == 'INPUT') { return }
      if (e.key == 'ArrowLeft') {
        document.getElementById('prev-article').click()
      } else if (e.key == 'ArrowRight') {
        document.getElementById('next-article').click()
      }
    })
  </script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  })"></script>

  
  <title>Полиномиальное хеширование - Алгоритмика</title>
</head>
<body><nav id='sidebar' >
  
  
  <div class='title'>
    <a href='/'>Алгоритмика</a>
    
      
        
        <span class='slash'>/</span>
        <a href='/cs/' class='divisionAbbr'
           >
          CS
        </a>
      
    
  </div>
  <ul>
    
      
        
          <li class='part'>Анализ алгоритмов</li>
        
        <li class=' '><a href='/cs/complexity/'
          
          >Вычислительная сложность</a></li>
        
          <ol>
            
              <li ><a href='/cs/complexity/asymptotic/'
                
                >Асимптотический анализ</a></li>
            
              <li ><a href='/cs/complexity/master-theorem/'
                
                >Мастер-теорема</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/sorting/'
          
          >Сортировки</a></li>
        
          <ol>
            
              <li ><a href='/cs/sorting/bubble/'
                
                >Сортировка пузырьком</a></li>
            
              <li ><a href='/cs/sorting/selection/'
                
                >Сортировка выбором</a></li>
            
              <li ><a href='/cs/sorting/insertion/'
                
                >Сортировка вставками</a></li>
            
              <li ><a href='/cs/sorting/heapsort/'
                
                >Сортировка кучей</a></li>
            
              <li ><a href='/cs/sorting/counting/'
                
                >Сортировка подсчетом</a></li>
            
              <li ><a href='/cs/sorting/radix/'
                
                >Цифровая сортировка</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/interactive/'
          
          >Бинпоиск и интерактивки</a></li>
        
          <ol>
            
              <li ><a href='/cs/interactive/binary-search/'
                
                >Бинарный поиск</a></li>
            
              <li ><a href='/cs/interactive/answer-search/'
                
                >Бинарный поиск по ответу</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/sequences/'
          
          >Последовательности</a></li>
        
          <ol>
            
              <li ><a href='/cs/sequences/compression/'
                
                >Сжатие координат</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/decomposition/'
          
          >Декомпозиция задач</a></li>
        
          <ol>
            
              <li ><a href='/cs/decomposition/scanline/'
                
                >Сканирующая прямая</a></li>
            
              <li ><a href='/cs/decomposition/rollback/'
                
                >Откатывание состояний</a></li>
            
              <li ><a href='/cs/decomposition/sqrt-heuristics/'
                
                >Корневые эвристики</a></li>
            
              <li ><a href='/cs/decomposition/mo/'
                
                >Алгоритм Мо</a></li>
            
              <li ><a href='/cs/decomposition/mitm/'
                
                >Meet-in-the-middle</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/arithmetic/'
          
          >Арифметика</a></li>
        
          <ol>
            
              <li ><a href='/cs/arithmetic/bit-representation/'
                
                >Битовое представление чисел</a></li>
            
              <li ><a href='/cs/arithmetic/simd/'
                
                >Векторизация</a></li>
            
          </ol>
        
      
        
          <li class='part'>Структуры данных</li>
        
        <li class=' '><a href='/cs/basic-structures/'
          
          >Базовые структуры данных</a></li>
        
          <ol>
            
              <li ><a href='/cs/basic-structures/array/'
                
                >Массивы и кортежи</a></li>
            
              <li ><a href='/cs/basic-structures/iterators/'
                
                >Итераторы</a></li>
            
              <li ><a href='/cs/basic-structures/vector/'
                
                >Динамический массив</a></li>
            
              <li ><a href='/cs/basic-structures/heap/'
                
                >Двоичная куча</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/tree-structures/'
          
          >Деревья поиска</a></li>
        
          <ol>
            
              <li ><a href='/cs/tree-structures/stl-trees/'
                
                >Деревья в STL</a></li>
            
              <li ><a href='/cs/tree-structures/treap/'
                
                >Декартово дерево</a></li>
            
              <li ><a href='/cs/tree-structures/implicit/'
                
                >Неявный ключ</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/set-structures/'
          
          >Структуры для множеств</a></li>
        
          <ol>
            
              <li ><a href='/cs/set-structures/bitset/'
                
                >Битсет и битовое сжатие</a></li>
            
              <li ><a href='/cs/set-structures/dsu/'
                
                >Система непересекающихся множеств</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/range-queries/'
          
          >Запросы на отрезках</a></li>
        
          <ol>
            
              <li ><a href='/cs/range-queries/prefix-sum/'
                
                >Префиксные суммы</a></li>
            
              <li ><a href='/cs/range-queries/fenwick/'
                
                >Дерево Фенвика</a></li>
            
              <li ><a href='/cs/range-queries/sparse-table/'
                
                >Разреженная таблица</a></li>
            
              <li ><a href='/cs/range-queries/sqrt-structures/'
                
                >Корневые структуры</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/persistent/'
          
          >Персистентность</a></li>
        
          <ol>
            
              <li ><a href='/cs/persistent/persistent-array/'
                
                >Структуры с откатами</a></li>
            
              <li ><a href='/cs/persistent/path-copying/'
                
                >Метод копирования пути</a></li>
            
              <li ><a href='/cs/persistent/persistent-segtree/'
                
                >Персистентное дерево отрезков</a></li>
            
              <li ><a href='/cs/persistent/persistent-treap/'
                
                >Персистентное декартово дерево</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/segment-tree/'
          
          >Дерево отрезков</a></li>
        
          <ol>
            
              <li ><a href='/cs/segment-tree/pointers/'
                
                >Дерево отрезков на указателях</a></li>
            
              <li ><a href='/cs/segment-tree/lazy-propagation/'
                
                >Отложенные операции</a></li>
            
              <li ><a href='/cs/segment-tree/lazy-initialization/'
                
                >Отложенное построение</a></li>
            
          </ol>
        
      
        
          <li class='part'>Динамическое программирование</li>
        
        <li class=' '><a href='/cs/general-dynamic/'
          
          >Общие приёмы динамики</a></li>
        
          <ol>
            
              <li ><a href='/cs/general-dynamic/segments/'
                
                >Динамика по подотрезкам</a></li>
            
              <li ><a href='/cs/general-dynamic/memoization/'
                
                >Ленивая динамика</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/combinatorial-optimization/'
          
          >Комбинаторная оптимизация</a></li>
        
          <ol>
            
              <li ><a href='/cs/combinatorial-optimization/greedy/'
                
                >Жадные алгоритмы</a></li>
            
              <li ><a href='/cs/combinatorial-optimization/matroid/'
                
                >Матроиды</a></li>
            
              <li ><a href='/cs/combinatorial-optimization/annealing/'
                
                >Метод отжига</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/games/'
          
          >Теория игр</a></li>
        
          <ol>
            
              <li ><a href='/cs/games/nim/'
                
                >Игра «Ним»</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/layer-optimizations/'
          
          >Пересчет динамики по слоям</a></li>
        
          <ol>
            
              <li ><a href='/cs/layer-optimizations/divide-and-conquer/'
                
                >Оптимизация через разделяй-и-властвуй</a></li>
            
              <li ><a href='/cs/layer-optimizations/knuth/'
                
                >Оптимизация Кнута</a></li>
            
              <li ><a href='/cs/layer-optimizations/convex-hull-trick/'
                
                >Convex Hull Trick</a></li>
            
              <li ><a href='/cs/layer-optimizations/lagrange/'
                
                >Дискретный метод Лагранжа</a></li>
            
          </ol>
        
      
        
          <li class='part'>Математика</li>
        
        <li class=' '><a href='/cs/algebra/'
          
          >Алгебра</a></li>
        
          <ol>
            
              <li ><a href='/cs/algebra/binpow/'
                
                >Бинарное возведение в степень</a></li>
            
              <li ><a href='/cs/algebra/matrix/'
                
                >Матрицы</a></li>
            
              <li ><a href='/cs/algebra/matmul/'
                
                >Задачи на умножение матриц</a></li>
            
              <li ><a href='/cs/algebra/gauss/'
                
                >Линейные уравнения</a></li>
            
              <li ><a href='/cs/algebra/polynomials/'
                
                >Многочлены</a></li>
            
              <li ><a href='/cs/algebra/interpolation/'
                
                >Интерполяция</a></li>
            
              <li ><a href='/cs/algebra/karatsuba/'
                
                >Алгоритм Карацубы</a></li>
            
              <li ><a href='/cs/algebra/fft/'
                
                >Быстрое преобразование Фурье</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/modular/'
          
          >Модулярная арифметика</a></li>
        
          <ol>
            
              <li ><a href='/cs/modular/euclid/'
                
                >Алгоритм Евклида</a></li>
            
              <li ><a href='/cs/modular/extended-euclid/'
                
                >Расширенный алгоритм Евклида</a></li>
            
              <li ><a href='/cs/modular/reciprocal/'
                
                >«Деление» по модулю</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/factorization/'
          
          >Факторизация и простые числа</a></li>
        
          <ol>
            
              <li ><a href='/cs/factorization/eratosthenes/'
                
                >Решето Эратосфена</a></li>
            
              <li ><a href='/cs/factorization/pollard/'
                
                >Ро-алгоритм Полларда</a></li>
            
          </ol>
        
      
        
          <li class='part'>Графы</li>
        
        <li class=' '><a href='/cs/graph-traversals/'
          
          >Обходы графов</a></li>
        
          <ol>
            
              <li ><a href='/cs/graph-traversals/storing-graphs/'
                
                >Хранение графов</a></li>
            
              <li ><a href='/cs/graph-traversals/dfs/'
                
                >Поиск в глубину</a></li>
            
              <li ><a href='/cs/graph-traversals/connectivity/'
                
                >Поиск компонент связности</a></li>
            
              <li ><a href='/cs/graph-traversals/bipartite/'
                
                >Двудольные графы и раскраски</a></li>
            
              <li ><a href='/cs/graph-traversals/cycle/'
                
                >Нахождение цикла</a></li>
            
              <li ><a href='/cs/graph-traversals/topological-sorting/'
                
                >Топологическая сортировка</a></li>
            
              <li ><a href='/cs/graph-traversals/euler-cycle/'
                
                >Эйлеров цикл</a></li>
            
              <li ><a href='/cs/graph-traversals/bridges/'
                
                >Мосты и точки сочленения</a></li>
            
              <li ><a href='/cs/graph-traversals/scc/'
                
                >Компоненты сильной связности</a></li>
            
              <li ><a href='/cs/graph-traversals/2-sat/'
                
                >2-SAT</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/shortest-paths/'
          
          >Кратчайшие пути</a></li>
        
          <ol>
            
              <li ><a href='/cs/shortest-paths/acyclic-paths/'
                
                >Пути в ациклических графах</a></li>
            
              <li ><a href='/cs/shortest-paths/bfs/'
                
                >Поиск в ширину</a></li>
            
              <li ><a href='/cs/shortest-paths/dijkstra/'
                
                >Алгоритм Дейкстры</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/spanning-trees/'
          
          >Связность и остовные деревья</a></li>
        
          <ol>
            
              <li ><a href='/cs/spanning-trees/safe-edge/'
                
                >Лемма о безопасном ребре</a></li>
            
              <li ><a href='/cs/spanning-trees/prim/'
                
                >Алгоритм Прима</a></li>
            
              <li ><a href='/cs/spanning-trees/kruskal/'
                
                >Алгоритм Краскала</a></li>
            
              <li ><a href='/cs/spanning-trees/boruvka/'
                
                >Алгоритм Борувки</a></li>
            
              <li ><a href='/cs/spanning-trees/dcp/'
                
                >Динамическая связность</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/matching/'
          
          >Паросочетания</a></li>
        
          <ol>
            
              <li ><a href='/cs/matching/berge/'
                
                >Лемма Бержа</a></li>
            
              <li ><a href='/cs/matching/kuhn/'
                
                >Алгоритм Куна</a></li>
            
              <li ><a href='/cs/matching/matching-problems/'
                
                >Задачи на паросочетания</a></li>
            
              <li ><a href='/cs/matching/hall/'
                
                >Теорема о свадьбах</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/trees/'
          
          >Корневые деревья</a></li>
        
          <ol>
            
              <li ><a href='/cs/trees/tree-queries/'
                
                >Запросы на деревьях</a></li>
            
              <li ><a href='/cs/trees/lca-rmq/'
                
                >Связь задачи LCA и static RMQ</a></li>
            
              <li ><a href='/cs/trees/binary-lifting/'
                
                >Метод двоичных подъемов</a></li>
            
              <li ><a href='/cs/trees/centroid/'
                
                >Центроидная декомпозиция</a></li>
            
              <li ><a href='/cs/trees/heavy-light/'
                
                >Heavy-light декомпозиция</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/flows/'
          
          >Потоки</a></li>
        
          <ol>
            
              <li ><a href='/cs/flows/mincost-maxflow/'
                
                >Поток минимальной стоимости</a></li>
            
          </ol>
        
      
        
          <li class='part'>Геометрия</li>
        
        <li class=' '><a href='/cs/geometry-basic/'
          
          >Геометрические примитивы</a></li>
        
          <ol>
            
              <li ><a href='/cs/geometry-basic/vectors/'
                
                >Точки и вектора</a></li>
            
              <li ><a href='/cs/geometry-basic/products/'
                
                >Скалярное и векторное произведение</a></li>
            
              <li ><a href='/cs/geometry-basic/segments/'
                
                >Прямые и отрезки</a></li>
            
              <li ><a href='/cs/geometry-basic/polygons/'
                
                >Многоугольники</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/convex-hulls/'
          
          >Выпуклые оболочки</a></li>
        
          <ol>
            
              <li ><a href='/cs/convex-hulls/hull-applications/'
                
                >Применения выпуклых оболочек</a></li>
            
              <li ><a href='/cs/convex-hulls/jarvis/'
                
                >Алгоритм Джарвиса</a></li>
            
              <li ><a href='/cs/convex-hulls/graham/'
                
                >Алгоритм Грэхэма</a></li>
            
              <li ><a href='/cs/convex-hulls/chan/'
                
                >Алгоритм Чана</a></li>
            
              <li ><a href='/cs/convex-hulls/envelope/'
                
                >Верхние и нижние огибающие</a></li>
            
          </ol>
        
      
        
          <li class='part'>Строки</li>
        
        <li class=' '><a href='/cs/string-searching/'
          
          >Поиск подстроки</a></li>
        
          <ol>
            
              <li ><a href='/cs/string-searching/prefix-function/'
                
                >Префикс-функция</a></li>
            
              <li ><a href='/cs/string-searching/z-function/'
                
                >Z-функция</a></li>
            
              <li ><a href='/cs/string-searching/manacher/'
                
                >Алгоритм Манакера</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/hashing/'
          
          >Хеширование</a></li>
        
          <ol>
            
              <li ><a href='/cs/hashing/polynomial/'
                id='active-element'
                >Полиномиальное хеширование</a></li>
            
              <li ><a href='/cs/hashing/collision/'
                
                >Коллизии хешей</a></li>
            
              <li ><a href='/cs/hashing/isomorphism/'
                
                >Проверки на изоморфизм</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/string-structures/'
          
          >Строковые структуры</a></li>
        
          <ol>
            
              <li ><a href='/cs/string-structures/trie/'
                
                >Префиксное дерево</a></li>
            
              <li ><a href='/cs/string-structures/aho-corasick/'
                
                >Алгоритм Ахо-Корасик</a></li>
            
              <li ><a href='/cs/string-structures/palindromic-tree/'
                
                >Дерево палиндромов</a></li>
            
              <li ><a href='/cs/string-structures/suffix-array/'
                
                >Суффиксный массив</a></li>
            
          </ol>
        
      
        
          <li class='part'>Разное</li>
        
        <li class=' '><a href='/cs/numerical/'
          
          >Численные методы</a></li>
        
          <ol>
            
              <li ><a href='/cs/numerical/newton/'
                
                >Метод Ньютона</a></li>
            
              <li ><a href='/cs/numerical/monte-carlo/'
                
                >Методы Монте-Карло</a></li>
            
          </ol>
        
      
        
        <li class=' '><a href='/cs/programming/'
          
          >Технологии программирования</a></li>
        
          <ol>
            
              <li ><a href='/cs/programming/stress-test/'
                
                >Стресс-тестирование</a></li>
            
              <li ><a href='/cs/programming/bayans/'
                
                >Просто интересные задачи</a></li>
            
          </ol>
        
      
    
  </ul>
</nav>
<div id='wrapper' ><menu id='menu'>
  
  
  <div class='left'>
    <a>
      <img src='/icons/bars-solid.svg'
           onclick='toggleSidebar()'
           title='open table of contents'>
    </a>
    <a>
      <img src='/icons/adjust-solid.svg'
           style='position: relative; top: -1px'
           onclick='switchTheme(localStorage.getItem("theme") == "dark" ? "light" : "dark")'
           title='dark theme'>
    </a>
    <a>
      <img src='/icons/search-solid.svg'
           onclick='toggleSearch()'
           title='search'>
    </a>
  </div>
  <div class='title'>Полиномиальное хеширование</div>
  <div class='right'>
    <a onClick='window.print()'>
      <img src='/icons/print-solid.svg' title='print'>
    </a>
    <a href='https://prose.io/#algorithmica-org/algorithmica/edit/master//cs%2fhashing%2fpolynomial.md'>
      <img src='/icons/edit-solid.svg'
           title='edit'
           style='width: 18px; position: relative; right: -2px; top: -1px'>
    </a>
    <a href='https://github.com/algorithmica-org/algorithmica/blob/master//cs/hashing/polynomial.md' class='github-main'>
      <img src='/icons/github-brands.svg' title='view on github'>
    </a>
  </div>
</menu>
<main>
        <div id="search">
    <input id="search-bar" type="search" placeholder='Поиск по сайту…' oninput="search()">
    <div id="search-count"></div>
    <div id="search-results">
    </div>
</div>
<header>
  
  <h1>Полиномиальное хеширование</h1>
  
    <div class='info'><div>
          <span>автор</span>
          
            <span>Сергей Слотин</span>
          
        </div>
      <div>
          <span>опубликовано</span>
          <span>2019</span>
        </div>
      </div>
  
</header>
<article>
  


  
    
    
      
        <p><strong>Лайфхак</strong>: пока вы не выучили все детерминированные строковые алгоритмы, научитесь пользоваться хешами.</p>
<p>Будем считать, что строка — это последовательность чисел от $1$ до $m$ (размер алфавита). В C/C++ тип <code>char</code> это на самом деле тоже число (8-битное), поэтому можно вычитать из символов минимальный код и кастовать в число:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span></code></pre></div><p>Определим <em>прямой полиномиальный хеш</em> строки как значение следующего многочлена:</p>

      
    
  

  
    $$
    
h_f = (s_0 + s_1 k + s_2 k^2 + \ldots + s_n k^n) \bmod p

    $$
  

  
    
    
      
        <p>Здесь $k$ — произвольное число больше размера алфавита, а $p$ — достаточно большой модуль (вообще говоря, не обязательно простой).</p>
<p>Его можно посчитать за линейное время, поддерживая переменную, равную $k$ в нужной степени:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">31</span><span class="p">,</span> <span class="n">mod</span> <span class="o">=</span> <span class="mf">1e9</span><span class="o">+</span><span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&#34;abacabadaba&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Можем ещё определить <em>обратный полиномиальный хеш</em>:</p>

      
    
  

  
    $$
    
h_b = (s_0 k^n + s_1 k^{n-1} + \ldots + s_n) \mod p

    $$
  

  
    
    
      
        <p>Его преимущество в том, что можно писать на одну строчку кода меньше:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">long</span> <span class="kt">long</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="nl">c</span> <span class="p">:</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="n">k</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Автору проще думать об обычных многочленах, поэтому он будет везде использовать прямой полиномиальный хеш и обозначать его просто буквой $h$.</p>
<span class='anchor' id="зачем-это-нужно"></span>
<h2><a class="anchor-link" href="https://ru.algorithmica.org/cs/hashing/polynomial/#%d0%b7%d0%b0%d1%87%d0%b5%d0%bc-%d1%8d%d1%82%d0%be-%d0%bd%d1%83%d0%b6%d0%bd%d0%be">#</a>Зачем это нужно?</h2><p>Используя тот факт, что хеш — это значение многочлена, можно быстро пересчитывать хеш от результата выполнения многих строковых операций.</p>
<p>Например, если нужно посчитать хеш от конкатенации строк $a$ и $b$ (строку $b$ приписали в конец строки $a$), то можно просто хеш $b$ домножить на $k^{|a|}$ и сложить с хешом $a$:</p>

      
    
  

  
    $$
    
h(ab) = h(a) + k^{|a|} \cdot h(b)

    $$
  

  
    
    
      
        Удалить префикс строки можно так:
      
    
  

  
    $$
    
h(b) = \frac{h(ab) - h(a)}{k^{|a|}}

    $$
  

  
    
    
      
        А суффикс — ещё проще:
      
    
  

  
    $$
    
h(a) = h(ab) - k^{|a|} \cdot h(b)

    $$
  

  
    
    
      
        <p>В задачах нам часто понадобится домножать $k$ в какой-то степени, поэтому имеет смысл предпосчитать все нужные степени и сохранить в массиве:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">int</span> <span class="n">maxn</span> <span class="o">=</span> <span class="mf">1e5</span><span class="o">+</span><span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">p</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">maxn</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1ll</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span> <span class="c1">// аккуратно с переполнением
</span></span></span></code></pre></div><p>Как это использовать в реальных задачах? Пусть нам надо отвечать на запросы проверки на равенство произвольных подстрок одной большой строки. Подсчитаем значение хеш-функции для каждого префикса:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">h</span><span class="p">[</span><span class="n">maxn</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// h[k] -- хеш префикса длины k
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="c1">// будем считать, что s это уже последовательность int-ов
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    <span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span></code></pre></div><p>Теперь с помощью этих префиксных хешей мы можем определить функцию, которая будет считать хеш на произвольном подотрезке:</p>

      
    
  

  
    $$
    
h(s[l:r]) = \frac{h_r-h_l}{k^l}

    $$
  

  
    
    
      
        <p><a href="/cs/modular/reciprocal">Деление по модулю</a> возможно делать только при некоторых <code>k</code> и <code>mod</code> (а именно — при взаимно простых). В любом случае, писать его долго, и мы это делать не хотим.</p>
<p>Для нашей задачи не важно получать именно полиномиальный хеш — главное, чтобы наша функция возвращала одинаковый многочлен от одинаковых подстрок. Вместо приведения к нулевой степени приведём многочлен к какой-нибудь достаточно большой — например, к $n$-ной.</p>

      
    
  

  
    $$
    
\hat{h}(s[l:r]) = k^{n-l} (h_r-h_l)

    $$
  

  
    
    
      
        <p>Так проще — теперь нужно домножать, а не делить:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c++" data-lang="c++"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">hash_substring</span><span class="p">(</span><span class="kt">int</span> <span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">l</span><span class="p">])</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">l</span><span class="p">]</span> <span class="o">%</span> <span class="n">mod</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>Теперь мы можем просто вызывать эту функцию от двух отрезков и сравнивать числовое значение, отвечая на запрос за $O(1)$.</p>
<p><strong>Упражнение.</strong> Напишите то же самое, но используя <em>обратный</em> полиномиальный хеш — этот способ тоже имеет право на существование, и местами он даже проще. Обратный хеш подстроки принято считать и использовать в стандартном виде из определения, поскольку там нет необходимости в делении.</p>
<p><strong>Лайфхак.</strong> Если взять обратный полиномиальный хеш короткой строки на небольшом алфавите с $k=10$, то числовое значение хеша строки будет наглядно соотноситься с самой строкой:</p>

      
    
  

  
    $$
    
h(abacaba)=1213121

    $$
  

  
    
    
      
        <p>Этим удобно пользоваться при дебаге.</p>
<span class='anchor' id="примеры-задач"></span>
<h2><a class="anchor-link" href="https://ru.algorithmica.org/cs/hashing/polynomial/#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d1%8b-%d0%b7%d0%b0%d0%b4%d0%b0%d1%87">#</a>Примеры задач</h2><p><strong>Количество разных подстрок</strong>. Посчитаем хеши от всех подстрок за $O(n^2)$ и добавим их все в <code>std::set</code>. Чтобы получить ответ, просто вызовем <code>set.size()</code>.</p>
<p><strong>Поиск подстроки в строке</strong>. Можно посчитать хеши от шаблона (строки, которую ищем) и пройтись «окном» размера шаблона по тексту, поддерживая хеш текущей подстроки. Если хеш какой-то из этих подстрок совпал с хешом шаблона, то мы нашли нужную подстроку. Это называется алгоритмом Рабина-Карпа.</p>
<p><strong>Сравнение подстрок</strong> на больше-меньше, а не только на равенство. У любых двух строк есть какой-то общий префикс (возможно, пустой). Сделаем бинпоиск по его длине, а дальше  в обеих подстроках возьмём идущий за ним символ и сравним. Это будет работать за $O(\log n)$.</p>
<p><strong>Палиндромность подстроки</strong>. Можно посчитать два массива — обратные хеши и прямые. Проверка на палиндром будет заключаться в сравнении значений <code>hash_substring()</code> на первом массиве и на втором.</p>
<p><strong>Количество палиндромов</strong>. Можно перебрать центр палиндрома, а для каждого центра — бинпоиском его размер. Проверять подстроку на палиндромность мы уже умеем. Как и всегда в задачах на палиндромы, случаи четных и нечетных палиндромов нужно обрабатывать отдельно. Это будет работать за $O(n \log n)$, хотя это <a href="/cs/string-searching/manacher">можно решить и линейно</a>.</p>

      
    
  



        </article>
        <div class='nextprev'>
  
    
      
      

      
      
      
        
          
        
      
        
      
        
      

      
        <div class='left'>
        
          <a href='https://ru.algorithmica.org/cs/hashing/' id='prev-article'>← ../Хеширование</a>
        
        </div>
        <div class='right'>
        
          <a href='https://ru.algorithmica.org/cs/hashing/collision/' id='next-article'>Коллизии хешей →</a>
        
        </div>
      
    
  
</div>

      </main>
      <footer>
  Copyleft 2017–2022 Algorithmica.org
  <br>
  Материалы распространяются под <a href='https://tldrlegal.com/license/creative-commons-attribution-sharealike-4.0-international-(cc-by-sa-4.0)'>CC BY-SA</a>
</footer>

    </div>
  </body>
</html>
