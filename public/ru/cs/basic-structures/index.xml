<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Базовые структуры данных on Алгоритмика</title>
    <link>https://ru.algorithmica.org/cs/basic-structures/</link>
    <description>Recent content in Базовые структуры данных on Алгоритмика</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-ru</language>
    <lastBuildDate>Thu, 21 Oct 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://ru.algorithmica.org/cs/basic-structures/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Массивы и кортежи</title>
      <link>https://ru.algorithmica.org/cs/basic-structures/array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/basic-structures/array/</guid>
      <description>В C++ есть несколько способов объединить группу переменных фиксированного размера в одну переменную.&#xA;#Массивы в CВ языке C есть три основных способа определить массив:&#xA;int a[100]; int main() { int b[100]; int *c = new int[100]; del[] c; return 0; } Получившиеся переменные функционально идентичные, но немного отличаются:&#xA;Определенный глобально массив a будет лежать в заранее выделенной области памяти на протяжении всего времени исполнения программы. Все элементы изначально заполнены своим значением по умолчанию (для int, нулём).</description>
    </item>
    <item>
      <title>Итераторы</title>
      <link>https://ru.algorithmica.org/cs/basic-structures/iterators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/basic-structures/iterators/</guid>
      <description>Итератор — это объект, указывающий на элемент какого-то контейнера.&#xA;Итератор является абстракцией над концепцией указателей. Если указатели работают только с последовательными данными (массивами), то итераторы работают с любыми контейнерами — например со связными списками или деревьями поиска — причём в единообразном синтаксисе, что сильно помогает разработчикам библиотек избегать дублирования кода.&#xA;#СинтаксисЧтобы получить элемент, на который указывает итератор it, необходимо воспользоваться оператором разыменования: *it. Если нужно перейти к следующему элементу надо использовать инкремент: ++it (постфиксного инкремента у итераторов нет).</description>
    </item>
    <item>
      <title>Динамический массив</title>
      <link>https://ru.algorithmica.org/cs/basic-structures/vector/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/basic-structures/vector/</guid>
      <description>Массив — это набор однотипных переменных, доступ к которым осуществляется по индексу.&#xA;Динамический или расширяющийся массив — это массив, который может изменять свой размер в зависимости от количества элементов в нём.&#xA;Динамические массивы обычно используют, когда заранее предсказать размер массива сложно или невозможно. В таком контексте у динамических массивов помимо операций доступа и изменения произвольных элементов есть ещё три:&#xA;Добавить в конец массива элемент $x$. Удалить последний элемент массива. Узнать размер массива.</description>
    </item>
    <item>
      <title>Двоичная куча</title>
      <link>https://ru.algorithmica.org/cs/basic-structures/heap/</link>
      <pubDate>Thu, 21 Oct 2021 00:00:00 +0000</pubDate>
      <guid>https://ru.algorithmica.org/cs/basic-structures/heap/</guid>
      <description>Куча (англ. heap) — абстрактная структура данных, поддерживающая следующие операции:&#xA;Нахождение минимума. Удаление минимума. Добавление нового элемента в кучу. Другое название, лучше отражающее функциональность — очередь с приоритетами (англ. priority queue).&#xA;Кучи используются во многих алгоритмах. Например, кучи используются в алгоритмах поиска кратчайшего пути, а также с помощью кучи можно проводить сортировку (путём превращения массива в кучу, а кучу в отсортированный массив).&#xA;#Устройство двоичной кучиДвоичная куча (пирамида, сортирующее дерево, англ. binary heap) — реализация очереди с приоритетами, использующая корневое дерево, для которого выполнены три условия:</description>
    </item>
  </channel>
</rss>
