<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Обходы графов on Алгоритмика</title><link>https://ru.algorithmica.org/cs/graph-traversals/</link><description>Recent content in Обходы графов on Алгоритмика</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><atom:link href="https://ru.algorithmica.org/cs/graph-traversals/index.xml" rel="self" type="application/rss+xml"/><item><title>Хранение графов</title><link>https://ru.algorithmica.org/cs/graph-traversals/storing-graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/storing-graphs/</guid><description>Чаще всего в задачах по программированию вершины графа пронумерованы числами от $0$ до $(n-1)$, чтобы было удобно обращаться к ним как к индексам в разных массивах.
В задачах графы чаще всего задаются списком всех ребер, которые нужно считать из ввода. В каком формате оптимально хранить граф? В зависимости от задачи есть несколько способов.
#Список рёберИногда достаточно хранить просто список ребер, которые нам дают на вход. Однако часто такой подход оказывается неэффективным для определенных операций.</description></item><item><title>Поиск в глубину</title><link>https://ru.algorithmica.org/cs/graph-traversals/dfs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/dfs/</guid><description>Поиском в глубину (англ. depth-first search, DFS) или эйлеровым обходом называется рекурсивный алгоритм обхода корневого дерева или графа, начинающий в корневой вершине (в случае графа может быть выбрана произвольная вершина) и рекурсивно обходящий весь граф, посещая каждую вершину ровно один раз.
const int maxn = 1e5; bool used[maxn]; // тут будем отмечать посещенные вершины void dfs(int v) { used[v] = true; for (int u : g[v]) if (!used[u]) dfs(u); } Немного его модифицируем, а именно будем сохранять для каждой вершины, в какой момент мы в неё вошли и в какой вышли — соответствующие массивы будем называть $tin$ и $tout$.</description></item><item><title>Поиск компонент связности</title><link>https://ru.algorithmica.org/cs/graph-traversals/connectivity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/connectivity/</guid><description>Компонентой связности неориентированного графа называется подмножество вершин, достижимых из какой-то заданной вершины. Как следствие неориентированности, все вершины компоненты связности достижимы друг из друга.
Граф с двумя компонентами связности Дан неориентированный граф $G$ с $n$ вершинами и $m$ рёбрами. Требуется найти в нём все компоненты связности, то есть разбить вершины графа на несколько групп так, что внутри одной группы можно дойти от одной вершины до любой другой, а между разными группами путей не существует.</description></item><item><title>Двудольные графы и раскраски</title><link>https://ru.algorithmica.org/cs/graph-traversals/bipartite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/bipartite/</guid><description>Корректной раскраской графа в два цвета называется такая раскраска, что никакое ребро не соединяет две вершины одного цвета. Графы, которые можно так раскрасить, называют двудольными.
Заметим, что если такая раскраска существует, и если зафиксировать цвет одной вершины, то все цвета всех достижимых из неё вершин определяются однозначно: пусть цвет этой вершины белый, тогда все её соседи будут иметь черный цвет, все вершины на расстоянии 2 будут иметь снова белый цвет, все вершины на расстоянии 3 снова черный, и так далее.</description></item><item><title>Нахождение цикла</title><link>https://ru.algorithmica.org/cs/graph-traversals/cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/cycle/</guid><description>Напомним, что циклом в графе $G$ называется ненулевой путь, ведущий из вершины $v$ в саму себя. Граф называют ацикличным, если в нем нет циклов.
Для нахождения цикла, рассмотрим такой альтернативные способ делать обход в глубину:
void dfs(int v, int p = -1) { for (int u : g[v]) if (u != p) dfs(u, v); } Здесь мы вместо массива used передаем в рекурсию параметр $p$, равный номеру вершины, откуда мы пришли, или $-1$, если мы начали обход в этой вершине.</description></item><item><title>Топологическая сортировка</title><link>https://ru.algorithmica.org/cs/graph-traversals/topological-sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/topological-sorting/</guid><description>Задача топологической сортировки графа звучит так: дан ориентированный граф, и требуется найти такой порядок вершин, в котором все рёбра графа вели из более ранней вершины в более позднюю.
Это может быть полезно, например, при планировании выполнения связанных задач: вам нужно одеться, в правильном порядке надев шорты (1), штаны (2), ботинки (3), подвернуть штаны (4) — как хипстеры — и завязать шнурки (5).
Во-первых, сразу заметим, что граф с циклом топологически отсортировать не получится — как ни располагай цикл в массиве, все время идти вправо по ребрам цикла не получится.</description></item><item><title>Эйлеров цикл</title><link>https://ru.algorithmica.org/cs/graph-traversals/euler-cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/euler-cycle/</guid><description>Определение. Эйлеров путь — это путь в графе, проходящий через все его рёбра.
Определение. Эйлеров цикл — это эйлеров путь, являющийся циклом.
Для простоты в обоих случаях будем считать, что граф неориентированный.
Граф на пяти вершинах и один из его эйлеровых циклов: CDCBBADEBC Также существует понятие гамильтонова пути и цикла — они посещают все вершины по разу, а не рёбра. Нахождение гамильтонова цикла (задача коммивояжера, англ. travelling salesman problem) — одна из самых известных NP-полных задач, в то время как нахождение эйлерова цика решается за линейное время, и мы сейчас покажем, как.</description></item><item><title>Мосты и точки сочленения</title><link>https://ru.algorithmica.org/cs/graph-traversals/bridges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/bridges/</guid><description>Определение. Мостом называется ребро, при удалении которого связный неориентированный граф становится несвязным.
Определение. Точкой сочленения называется вершина, при удалении которой связный неориентированный граф становится несвязным.
Пример задачи, где их интересно искать: дана топология сети (компьютеры и физические соединения между ними) и требуется установить все единые точки отказа — узлы и связи, без которых будут существовать два узла, между которыми не будет пути.
Наивный алгоритм поочередного удаления каждого ребра $(u, v)$ и проверки наличия пути $u \leadsto v$ потребует $O(m^2)$ операций.</description></item><item><title>Компоненты сильной связности</title><link>https://ru.algorithmica.org/cs/graph-traversals/scc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/scc/</guid><description>Ранее мы научились топологически сортировать ациклические графы. Но в циклических графах тоже иногда требуется найти какую-то структуру, для чего нам нужно ввести понятие сильной связности.
Определение. Две вершины ориентированного графа связаны сильно (англ. strongly connected), если существует путь из одной в другую и наоборот. Иными словами, они обе лежат в каком-то цикле.
Понятно, что такое отношение транзитивно: если $a$ и $b$ сильно связны, и $b$ и $c$ сильно связны, то $a$ и $c$ тоже сильно связны.</description></item><item><title>2-SAT</title><link>https://ru.algorithmica.org/cs/graph-traversals/2-sat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/graph-traversals/2-sat/</guid><description>Ликбез. Конъюнкция — это «правильный» термин для логического «И» (обозначается $\wedge$ или &amp;amp;). Конъюнкция возвращает true тогда и только тогда, когда обе переменные true.
Ликбез. Дизъюнкция — это «правильный» термин для логического «ИЛИ» (обозначается $\vee$ или |). Дизъюнкция возвращает false тогда и только тогда, когда обе переменные false.
Рассмотрим конъюнкцию дизъюнктов, то есть «И» от «ИЛИ» от каких-то переменных или их отрицаний. Например, такое выражение:
(a | b) &amp;amp; (!c | d) &amp;amp; (!</description></item></channel></rss>