<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Персистентность on Алгоритмика</title><link>https://ru.algorithmica.org/cs/persistent/</link><description>Recent content in Персистентность on Алгоритмика</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Sat, 11 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ru.algorithmica.org/cs/persistent/index.xml" rel="self" type="application/rss+xml"/><item><title>Структуры с откатами</title><link>https://ru.algorithmica.org/cs/persistent/persistent-array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/persistent/persistent-array/</guid><description>Состояние любой структуры как-то лежит в памяти: в каких-то массивах, или в более общем случае, по каким-то определенным адресам в памяти. Для простоты, пусть у нас есть некоторый массив $a$ размера $n$, и нам нужно обрабатывать запросы присвоения и чтения, а также иногда откатывать изменения обратно.
#Список измененийОдин из самых простых и общих способов поддерживать простой откат состояний — поддерживать лог изменений всех затронутых элементов.
Если нужно только откатывать изменения до некоторого прошлого состояния (как &amp;ldquo;ctrl+z&amp;rdquo;), то можно просто создать стек, в котором будут храниться пары «какая ячейка изменилась, какое значение там было раньше», и для отката состояния пройтись по нему в обратном порядке, восстанавливая исходные значения.</description></item><item><title>Метод копирования пути</title><link>https://ru.algorithmica.org/cs/persistent/path-copying/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/persistent/path-copying/</guid><description>В широком смысле, структура данных — это набор связанных ссылками узлов, в которых хранятся данные.
Обычный массив тоже попадает под это определение: в нём узел один, в котором хранятся $n$ ячеек.
Рассмотрим немного более узкий класс структур, в котором каждый узел хранит $O(1)$ полей и ссылок. Например, дерево отрезков и декартово дерево, которые мы рассмотрим далее, удовлетворяют этому свойству.
Для таких структур существует простой и общий способ сделать их полностью персистентными — метод копирования путей.</description></item><item><title>Персистентное дерево отрезков</title><link>https://ru.algorithmica.org/cs/persistent/persistent-segtree/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/persistent/persistent-segtree/</guid><description>Общий подход к персистентности почти любой ссылочной структуры — это создавать копии всех вершин, в которых хоть что-то меняется, и менять это что-то в копиях, никогда не изменяя уже существующие вершины.
Персистентное дерево отрезков здесь не исключение. Просто будем при спуске создавать копию вершины перед тем, как что-либо менять в ней самой или её потомках. Асимптотика операций от этого не изменится, разве что общее потребление памяти увеличится до $O(m \log n)$.</description></item><item><title>Персистентное декартово дерево</title><link>https://ru.algorithmica.org/cs/persistent/persistent-treap/</link><pubDate>Mon, 13 Sep 2021 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/persistent/persistent-treap/</guid><description>Так же, как и с деревом отрезков, персистентной версией декартова дерева можно решать интересные задачи — особенно часто связанные со строками. Разберем сначала несколько примеров, а потом перейдем к реализации.
#Примеры задачЗадача. Дана строка. Требуется выполнять в ней копирования, удаления и вставки в произвольные позиции.
Построим персистентное ДД поверх символов. Тогда просто вызвав два split-а, мы можем получить копию любой подстроки (указатель вершину), которую потом можно вставлять куда угодно, при этом оригинальную подстроку мы не изменим.</description></item></channel></rss>