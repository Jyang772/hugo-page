<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Пересчет динамики по слоям on Алгоритмика</title><link>https://ru.algorithmica.org/cs/layer-optimizations/</link><description>Recent content in Пересчет динамики по слоям on Алгоритмика</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Sun, 29 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://ru.algorithmica.org/cs/layer-optimizations/index.xml" rel="self" type="application/rss+xml"/><item><title>Оптимизация через разделяй-и-властвуй</title><link>https://ru.algorithmica.org/cs/layer-optimizations/divide-and-conquer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/layer-optimizations/divide-and-conquer/</guid><description>Эта статья — одна из серии. Рекомендуется сначала прочитать все предыдущие.
Посмотрим на формулу пересчета динамики из базового решения:
$$ f[i, j] = \min_{k &amp;lt; i} {f[k, j-1] + (x_{i-1}-x_k)^2 } $$
Обозначим за $opt[i, j]$ оптимальный $k$ для данного состояния — то есть аргминимум от выражения выше. Для однозначности, если оптимальный индекс не один, то выберем среди них самый правый.
Конкретно в задаче покрытия точек отрезками можно заметить следующее:</description></item><item><title>Оптимизация Кнута</title><link>https://ru.algorithmica.org/cs/layer-optimizations/knuth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/layer-optimizations/knuth/</guid><description>Эта статья — одна из серии. Рекомендуется сначала прочитать все предыдущие.
Предыдущий метод оптимизации опирался на тот факт, что $opt[i, j] \leq opt[i, j + 1]$.
Асимптотику можно ещё улучшить, заметив, что $opt$ монотонен также и по второму параметру:
$$ opt[i - 1, j] \leq opt[i, j] \leq opt[i, j + 1] $$
В задаче про покрытие отрезками это выполняется примерно по той же причине: если нам доступно больше отрезков, то последний отрезок в оптимальном решении точно не будет длиннее, чем раньше.</description></item><item><title>Convex Hull Trick</title><link>https://ru.algorithmica.org/cs/layer-optimizations/convex-hull-trick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/layer-optimizations/convex-hull-trick/</guid><description>Эта статья — одна из серии. Рекомендуется сначала прочитать все предыдущие.
Возьмём исходную формулу для $f$ и раскроем скобки в cost:
$$ \begin{aligned} f[i, j] &amp;amp;= \min_{k &amp;lt; i} { f[k, j-1] + (x_{i-1}-x_k)^2 } \ &amp;amp;= \min_{k &amp;lt; i} { f[k, j-1] + x_{i-1}^2 - 2x_{i-1} x_k + x_k^2 } \end{aligned} $$
Заметим, что $x_{i-1}^2$ не зависит от $k$, значит его можно вынести. Под минимумом тогда останется только
$$ \underbrace{(f[k, j-1] + x_k^2)}{a_k} + \underbrace{(-2 x_k)}{b_k} \cdot x_{i-1} $$</description></item><item><title>Дискретный метод Лагранжа</title><link>https://ru.algorithmica.org/cs/layer-optimizations/lagrange/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ru.algorithmica.org/cs/layer-optimizations/lagrange/</guid><description>Эта статья — одна из серии. Рекомендуется сначала прочитать все предыдущие.
В качестве финальной оптимизации мы рассмотрим метод, вдохновленный методом множителей Лагранжа, также в олимпиадной среде называемый «лямбда-оптимизацией».
#Модификация задачиРассмотрим немного измененную версию исходной задачи. Пусть нам нужно покрыть те же точки, но теперь нас не ограничивают жёстко в количестве отрезков, а просто штрафуют на какую-то константу $\lambda$ за использование каждого дополнительного отрезка.
Нашу оптимизируемую функцию $g$ тогда можно выразить через $f$ следующим образом:</description></item></channel></rss>